// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/activeinfo"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/algorithm"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/algorithmalarmtype"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/area"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/camera"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/device"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/devicealgo"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/devicecamera"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/devicetoken"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/equipattr"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/eventsubscription"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/fileupload"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/inform"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/organization"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/setting"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/signature"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/task"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/taskcamera"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/tasklimits"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/upplatform"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/user"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warningtype"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warnpush"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warnpushlog"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warnsmserr"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ActiveInfo is the client for interacting with the ActiveInfo builders.
	ActiveInfo *ActiveInfoClient
	// Algorithm is the client for interacting with the Algorithm builders.
	Algorithm *AlgorithmClient
	// AlgorithmAlarmType is the client for interacting with the AlgorithmAlarmType builders.
	AlgorithmAlarmType *AlgorithmAlarmTypeClient
	// Area is the client for interacting with the Area builders.
	Area *AreaClient
	// Camera is the client for interacting with the Camera builders.
	Camera *CameraClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// DeviceAlgo is the client for interacting with the DeviceAlgo builders.
	DeviceAlgo *DeviceAlgoClient
	// DeviceCamera is the client for interacting with the DeviceCamera builders.
	DeviceCamera *DeviceCameraClient
	// DeviceToken is the client for interacting with the DeviceToken builders.
	DeviceToken *DeviceTokenClient
	// EquipAttr is the client for interacting with the EquipAttr builders.
	EquipAttr *EquipAttrClient
	// EventSubscription is the client for interacting with the EventSubscription builders.
	EventSubscription *EventSubscriptionClient
	// FileUpload is the client for interacting with the FileUpload builders.
	FileUpload *FileUploadClient
	// Inform is the client for interacting with the Inform builders.
	Inform *InformClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Signature is the client for interacting with the Signature builders.
	Signature *SignatureClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// TaskCamera is the client for interacting with the TaskCamera builders.
	TaskCamera *TaskCameraClient
	// TaskLimits is the client for interacting with the TaskLimits builders.
	TaskLimits *TaskLimitsClient
	// UpPlatform is the client for interacting with the UpPlatform builders.
	UpPlatform *UpPlatformClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// WarnPush is the client for interacting with the WarnPush builders.
	WarnPush *WarnPushClient
	// WarnPushLog is the client for interacting with the WarnPushLog builders.
	WarnPushLog *WarnPushLogClient
	// WarnSmsErr is the client for interacting with the WarnSmsErr builders.
	WarnSmsErr *WarnSmsErrClient
	// WarningType is the client for interacting with the WarningType builders.
	WarningType *WarningTypeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ActiveInfo = NewActiveInfoClient(c.config)
	c.Algorithm = NewAlgorithmClient(c.config)
	c.AlgorithmAlarmType = NewAlgorithmAlarmTypeClient(c.config)
	c.Area = NewAreaClient(c.config)
	c.Camera = NewCameraClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.DeviceAlgo = NewDeviceAlgoClient(c.config)
	c.DeviceCamera = NewDeviceCameraClient(c.config)
	c.DeviceToken = NewDeviceTokenClient(c.config)
	c.EquipAttr = NewEquipAttrClient(c.config)
	c.EventSubscription = NewEventSubscriptionClient(c.config)
	c.FileUpload = NewFileUploadClient(c.config)
	c.Inform = NewInformClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Signature = NewSignatureClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.TaskCamera = NewTaskCameraClient(c.config)
	c.TaskLimits = NewTaskLimitsClient(c.config)
	c.UpPlatform = NewUpPlatformClient(c.config)
	c.User = NewUserClient(c.config)
	c.WarnPush = NewWarnPushClient(c.config)
	c.WarnPushLog = NewWarnPushLogClient(c.config)
	c.WarnSmsErr = NewWarnSmsErrClient(c.config)
	c.WarningType = NewWarningTypeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		ActiveInfo:         NewActiveInfoClient(cfg),
		Algorithm:          NewAlgorithmClient(cfg),
		AlgorithmAlarmType: NewAlgorithmAlarmTypeClient(cfg),
		Area:               NewAreaClient(cfg),
		Camera:             NewCameraClient(cfg),
		Device:             NewDeviceClient(cfg),
		DeviceAlgo:         NewDeviceAlgoClient(cfg),
		DeviceCamera:       NewDeviceCameraClient(cfg),
		DeviceToken:        NewDeviceTokenClient(cfg),
		EquipAttr:          NewEquipAttrClient(cfg),
		EventSubscription:  NewEventSubscriptionClient(cfg),
		FileUpload:         NewFileUploadClient(cfg),
		Inform:             NewInformClient(cfg),
		Organization:       NewOrganizationClient(cfg),
		Setting:            NewSettingClient(cfg),
		Signature:          NewSignatureClient(cfg),
		Task:               NewTaskClient(cfg),
		TaskCamera:         NewTaskCameraClient(cfg),
		TaskLimits:         NewTaskLimitsClient(cfg),
		UpPlatform:         NewUpPlatformClient(cfg),
		User:               NewUserClient(cfg),
		WarnPush:           NewWarnPushClient(cfg),
		WarnPushLog:        NewWarnPushLogClient(cfg),
		WarnSmsErr:         NewWarnSmsErrClient(cfg),
		WarningType:        NewWarningTypeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		ActiveInfo:         NewActiveInfoClient(cfg),
		Algorithm:          NewAlgorithmClient(cfg),
		AlgorithmAlarmType: NewAlgorithmAlarmTypeClient(cfg),
		Area:               NewAreaClient(cfg),
		Camera:             NewCameraClient(cfg),
		Device:             NewDeviceClient(cfg),
		DeviceAlgo:         NewDeviceAlgoClient(cfg),
		DeviceCamera:       NewDeviceCameraClient(cfg),
		DeviceToken:        NewDeviceTokenClient(cfg),
		EquipAttr:          NewEquipAttrClient(cfg),
		EventSubscription:  NewEventSubscriptionClient(cfg),
		FileUpload:         NewFileUploadClient(cfg),
		Inform:             NewInformClient(cfg),
		Organization:       NewOrganizationClient(cfg),
		Setting:            NewSettingClient(cfg),
		Signature:          NewSignatureClient(cfg),
		Task:               NewTaskClient(cfg),
		TaskCamera:         NewTaskCameraClient(cfg),
		TaskLimits:         NewTaskLimitsClient(cfg),
		UpPlatform:         NewUpPlatformClient(cfg),
		User:               NewUserClient(cfg),
		WarnPush:           NewWarnPushClient(cfg),
		WarnPushLog:        NewWarnPushLogClient(cfg),
		WarnSmsErr:         NewWarnSmsErrClient(cfg),
		WarningType:        NewWarningTypeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ActiveInfo.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ActiveInfo, c.Algorithm, c.AlgorithmAlarmType, c.Area, c.Camera, c.Device,
		c.DeviceAlgo, c.DeviceCamera, c.DeviceToken, c.EquipAttr, c.EventSubscription,
		c.FileUpload, c.Inform, c.Organization, c.Setting, c.Signature, c.Task,
		c.TaskCamera, c.TaskLimits, c.UpPlatform, c.User, c.WarnPush, c.WarnPushLog,
		c.WarnSmsErr, c.WarningType,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ActiveInfo, c.Algorithm, c.AlgorithmAlarmType, c.Area, c.Camera, c.Device,
		c.DeviceAlgo, c.DeviceCamera, c.DeviceToken, c.EquipAttr, c.EventSubscription,
		c.FileUpload, c.Inform, c.Organization, c.Setting, c.Signature, c.Task,
		c.TaskCamera, c.TaskLimits, c.UpPlatform, c.User, c.WarnPush, c.WarnPushLog,
		c.WarnSmsErr, c.WarningType,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ActiveInfoMutation:
		return c.ActiveInfo.mutate(ctx, m)
	case *AlgorithmMutation:
		return c.Algorithm.mutate(ctx, m)
	case *AlgorithmAlarmTypeMutation:
		return c.AlgorithmAlarmType.mutate(ctx, m)
	case *AreaMutation:
		return c.Area.mutate(ctx, m)
	case *CameraMutation:
		return c.Camera.mutate(ctx, m)
	case *DeviceMutation:
		return c.Device.mutate(ctx, m)
	case *DeviceAlgoMutation:
		return c.DeviceAlgo.mutate(ctx, m)
	case *DeviceCameraMutation:
		return c.DeviceCamera.mutate(ctx, m)
	case *DeviceTokenMutation:
		return c.DeviceToken.mutate(ctx, m)
	case *EquipAttrMutation:
		return c.EquipAttr.mutate(ctx, m)
	case *EventSubscriptionMutation:
		return c.EventSubscription.mutate(ctx, m)
	case *FileUploadMutation:
		return c.FileUpload.mutate(ctx, m)
	case *InformMutation:
		return c.Inform.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *SignatureMutation:
		return c.Signature.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TaskCameraMutation:
		return c.TaskCamera.mutate(ctx, m)
	case *TaskLimitsMutation:
		return c.TaskLimits.mutate(ctx, m)
	case *UpPlatformMutation:
		return c.UpPlatform.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *WarnPushMutation:
		return c.WarnPush.mutate(ctx, m)
	case *WarnPushLogMutation:
		return c.WarnPushLog.mutate(ctx, m)
	case *WarnSmsErrMutation:
		return c.WarnSmsErr.mutate(ctx, m)
	case *WarningTypeMutation:
		return c.WarningType.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ActiveInfoClient is a client for the ActiveInfo schema.
type ActiveInfoClient struct {
	config
}

// NewActiveInfoClient returns a client for the ActiveInfo from the given config.
func NewActiveInfoClient(c config) *ActiveInfoClient {
	return &ActiveInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activeinfo.Hooks(f(g(h())))`.
func (c *ActiveInfoClient) Use(hooks ...Hook) {
	c.hooks.ActiveInfo = append(c.hooks.ActiveInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activeinfo.Intercept(f(g(h())))`.
func (c *ActiveInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActiveInfo = append(c.inters.ActiveInfo, interceptors...)
}

// Create returns a builder for creating a ActiveInfo entity.
func (c *ActiveInfoClient) Create() *ActiveInfoCreate {
	mutation := newActiveInfoMutation(c.config, OpCreate)
	return &ActiveInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActiveInfo entities.
func (c *ActiveInfoClient) CreateBulk(builders ...*ActiveInfoCreate) *ActiveInfoCreateBulk {
	return &ActiveInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActiveInfoClient) MapCreateBulk(slice any, setFunc func(*ActiveInfoCreate, int)) *ActiveInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActiveInfoCreateBulk{err: fmt.Errorf("calling to ActiveInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActiveInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActiveInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActiveInfo.
func (c *ActiveInfoClient) Update() *ActiveInfoUpdate {
	mutation := newActiveInfoMutation(c.config, OpUpdate)
	return &ActiveInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActiveInfoClient) UpdateOne(ai *ActiveInfo) *ActiveInfoUpdateOne {
	mutation := newActiveInfoMutation(c.config, OpUpdateOne, withActiveInfo(ai))
	return &ActiveInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActiveInfoClient) UpdateOneID(id uint64) *ActiveInfoUpdateOne {
	mutation := newActiveInfoMutation(c.config, OpUpdateOne, withActiveInfoID(id))
	return &ActiveInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActiveInfo.
func (c *ActiveInfoClient) Delete() *ActiveInfoDelete {
	mutation := newActiveInfoMutation(c.config, OpDelete)
	return &ActiveInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActiveInfoClient) DeleteOne(ai *ActiveInfo) *ActiveInfoDeleteOne {
	return c.DeleteOneID(ai.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActiveInfoClient) DeleteOneID(id uint64) *ActiveInfoDeleteOne {
	builder := c.Delete().Where(activeinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActiveInfoDeleteOne{builder}
}

// Query returns a query builder for ActiveInfo.
func (c *ActiveInfoClient) Query() *ActiveInfoQuery {
	return &ActiveInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActiveInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a ActiveInfo entity by its id.
func (c *ActiveInfoClient) Get(ctx context.Context, id uint64) (*ActiveInfo, error) {
	return c.Query().Where(activeinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActiveInfoClient) GetX(ctx context.Context, id uint64) *ActiveInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ActiveInfoClient) Hooks() []Hook {
	hooks := c.hooks.ActiveInfo
	return append(hooks[:len(hooks):len(hooks)], activeinfo.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ActiveInfoClient) Interceptors() []Interceptor {
	inters := c.inters.ActiveInfo
	return append(inters[:len(inters):len(inters)], activeinfo.Interceptors[:]...)
}

func (c *ActiveInfoClient) mutate(ctx context.Context, m *ActiveInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActiveInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActiveInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActiveInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActiveInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActiveInfo mutation op: %q", m.Op())
	}
}

// AlgorithmClient is a client for the Algorithm schema.
type AlgorithmClient struct {
	config
}

// NewAlgorithmClient returns a client for the Algorithm from the given config.
func NewAlgorithmClient(c config) *AlgorithmClient {
	return &AlgorithmClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `algorithm.Hooks(f(g(h())))`.
func (c *AlgorithmClient) Use(hooks ...Hook) {
	c.hooks.Algorithm = append(c.hooks.Algorithm, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `algorithm.Intercept(f(g(h())))`.
func (c *AlgorithmClient) Intercept(interceptors ...Interceptor) {
	c.inters.Algorithm = append(c.inters.Algorithm, interceptors...)
}

// Create returns a builder for creating a Algorithm entity.
func (c *AlgorithmClient) Create() *AlgorithmCreate {
	mutation := newAlgorithmMutation(c.config, OpCreate)
	return &AlgorithmCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Algorithm entities.
func (c *AlgorithmClient) CreateBulk(builders ...*AlgorithmCreate) *AlgorithmCreateBulk {
	return &AlgorithmCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlgorithmClient) MapCreateBulk(slice any, setFunc func(*AlgorithmCreate, int)) *AlgorithmCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlgorithmCreateBulk{err: fmt.Errorf("calling to AlgorithmClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlgorithmCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlgorithmCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Algorithm.
func (c *AlgorithmClient) Update() *AlgorithmUpdate {
	mutation := newAlgorithmMutation(c.config, OpUpdate)
	return &AlgorithmUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlgorithmClient) UpdateOne(a *Algorithm) *AlgorithmUpdateOne {
	mutation := newAlgorithmMutation(c.config, OpUpdateOne, withAlgorithm(a))
	return &AlgorithmUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlgorithmClient) UpdateOneID(id uint64) *AlgorithmUpdateOne {
	mutation := newAlgorithmMutation(c.config, OpUpdateOne, withAlgorithmID(id))
	return &AlgorithmUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Algorithm.
func (c *AlgorithmClient) Delete() *AlgorithmDelete {
	mutation := newAlgorithmMutation(c.config, OpDelete)
	return &AlgorithmDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlgorithmClient) DeleteOne(a *Algorithm) *AlgorithmDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlgorithmClient) DeleteOneID(id uint64) *AlgorithmDeleteOne {
	builder := c.Delete().Where(algorithm.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlgorithmDeleteOne{builder}
}

// Query returns a query builder for Algorithm.
func (c *AlgorithmClient) Query() *AlgorithmQuery {
	return &AlgorithmQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlgorithm},
		inters: c.Interceptors(),
	}
}

// Get returns a Algorithm entity by its id.
func (c *AlgorithmClient) Get(ctx context.Context, id uint64) (*Algorithm, error) {
	return c.Query().Where(algorithm.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlgorithmClient) GetX(ctx context.Context, id uint64) *Algorithm {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTasks queries the tasks edge of a Algorithm.
func (c *AlgorithmClient) QueryTasks(a *Algorithm) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(algorithm.Table, algorithm.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, algorithm.TasksTable, algorithm.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlgorithmClient) Hooks() []Hook {
	hooks := c.hooks.Algorithm
	return append(hooks[:len(hooks):len(hooks)], algorithm.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AlgorithmClient) Interceptors() []Interceptor {
	inters := c.inters.Algorithm
	return append(inters[:len(inters):len(inters)], algorithm.Interceptors[:]...)
}

func (c *AlgorithmClient) mutate(ctx context.Context, m *AlgorithmMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlgorithmCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlgorithmUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlgorithmUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlgorithmDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Algorithm mutation op: %q", m.Op())
	}
}

// AlgorithmAlarmTypeClient is a client for the AlgorithmAlarmType schema.
type AlgorithmAlarmTypeClient struct {
	config
}

// NewAlgorithmAlarmTypeClient returns a client for the AlgorithmAlarmType from the given config.
func NewAlgorithmAlarmTypeClient(c config) *AlgorithmAlarmTypeClient {
	return &AlgorithmAlarmTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `algorithmalarmtype.Hooks(f(g(h())))`.
func (c *AlgorithmAlarmTypeClient) Use(hooks ...Hook) {
	c.hooks.AlgorithmAlarmType = append(c.hooks.AlgorithmAlarmType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `algorithmalarmtype.Intercept(f(g(h())))`.
func (c *AlgorithmAlarmTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AlgorithmAlarmType = append(c.inters.AlgorithmAlarmType, interceptors...)
}

// Create returns a builder for creating a AlgorithmAlarmType entity.
func (c *AlgorithmAlarmTypeClient) Create() *AlgorithmAlarmTypeCreate {
	mutation := newAlgorithmAlarmTypeMutation(c.config, OpCreate)
	return &AlgorithmAlarmTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AlgorithmAlarmType entities.
func (c *AlgorithmAlarmTypeClient) CreateBulk(builders ...*AlgorithmAlarmTypeCreate) *AlgorithmAlarmTypeCreateBulk {
	return &AlgorithmAlarmTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlgorithmAlarmTypeClient) MapCreateBulk(slice any, setFunc func(*AlgorithmAlarmTypeCreate, int)) *AlgorithmAlarmTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlgorithmAlarmTypeCreateBulk{err: fmt.Errorf("calling to AlgorithmAlarmTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlgorithmAlarmTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlgorithmAlarmTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AlgorithmAlarmType.
func (c *AlgorithmAlarmTypeClient) Update() *AlgorithmAlarmTypeUpdate {
	mutation := newAlgorithmAlarmTypeMutation(c.config, OpUpdate)
	return &AlgorithmAlarmTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlgorithmAlarmTypeClient) UpdateOne(aat *AlgorithmAlarmType) *AlgorithmAlarmTypeUpdateOne {
	mutation := newAlgorithmAlarmTypeMutation(c.config, OpUpdateOne, withAlgorithmAlarmType(aat))
	return &AlgorithmAlarmTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlgorithmAlarmTypeClient) UpdateOneID(id uint64) *AlgorithmAlarmTypeUpdateOne {
	mutation := newAlgorithmAlarmTypeMutation(c.config, OpUpdateOne, withAlgorithmAlarmTypeID(id))
	return &AlgorithmAlarmTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AlgorithmAlarmType.
func (c *AlgorithmAlarmTypeClient) Delete() *AlgorithmAlarmTypeDelete {
	mutation := newAlgorithmAlarmTypeMutation(c.config, OpDelete)
	return &AlgorithmAlarmTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlgorithmAlarmTypeClient) DeleteOne(aat *AlgorithmAlarmType) *AlgorithmAlarmTypeDeleteOne {
	return c.DeleteOneID(aat.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlgorithmAlarmTypeClient) DeleteOneID(id uint64) *AlgorithmAlarmTypeDeleteOne {
	builder := c.Delete().Where(algorithmalarmtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlgorithmAlarmTypeDeleteOne{builder}
}

// Query returns a query builder for AlgorithmAlarmType.
func (c *AlgorithmAlarmTypeClient) Query() *AlgorithmAlarmTypeQuery {
	return &AlgorithmAlarmTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlgorithmAlarmType},
		inters: c.Interceptors(),
	}
}

// Get returns a AlgorithmAlarmType entity by its id.
func (c *AlgorithmAlarmTypeClient) Get(ctx context.Context, id uint64) (*AlgorithmAlarmType, error) {
	return c.Query().Where(algorithmalarmtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlgorithmAlarmTypeClient) GetX(ctx context.Context, id uint64) *AlgorithmAlarmType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AlgorithmAlarmTypeClient) Hooks() []Hook {
	hooks := c.hooks.AlgorithmAlarmType
	return append(hooks[:len(hooks):len(hooks)], algorithmalarmtype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AlgorithmAlarmTypeClient) Interceptors() []Interceptor {
	inters := c.inters.AlgorithmAlarmType
	return append(inters[:len(inters):len(inters)], algorithmalarmtype.Interceptors[:]...)
}

func (c *AlgorithmAlarmTypeClient) mutate(ctx context.Context, m *AlgorithmAlarmTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlgorithmAlarmTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlgorithmAlarmTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlgorithmAlarmTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlgorithmAlarmTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AlgorithmAlarmType mutation op: %q", m.Op())
	}
}

// AreaClient is a client for the Area schema.
type AreaClient struct {
	config
}

// NewAreaClient returns a client for the Area from the given config.
func NewAreaClient(c config) *AreaClient {
	return &AreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `area.Hooks(f(g(h())))`.
func (c *AreaClient) Use(hooks ...Hook) {
	c.hooks.Area = append(c.hooks.Area, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `area.Intercept(f(g(h())))`.
func (c *AreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Area = append(c.inters.Area, interceptors...)
}

// Create returns a builder for creating a Area entity.
func (c *AreaClient) Create() *AreaCreate {
	mutation := newAreaMutation(c.config, OpCreate)
	return &AreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Area entities.
func (c *AreaClient) CreateBulk(builders ...*AreaCreate) *AreaCreateBulk {
	return &AreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AreaClient) MapCreateBulk(slice any, setFunc func(*AreaCreate, int)) *AreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AreaCreateBulk{err: fmt.Errorf("calling to AreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Area.
func (c *AreaClient) Update() *AreaUpdate {
	mutation := newAreaMutation(c.config, OpUpdate)
	return &AreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AreaClient) UpdateOne(a *Area) *AreaUpdateOne {
	mutation := newAreaMutation(c.config, OpUpdateOne, withArea(a))
	return &AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AreaClient) UpdateOneID(id uint64) *AreaUpdateOne {
	mutation := newAreaMutation(c.config, OpUpdateOne, withAreaID(id))
	return &AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Area.
func (c *AreaClient) Delete() *AreaDelete {
	mutation := newAreaMutation(c.config, OpDelete)
	return &AreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AreaClient) DeleteOne(a *Area) *AreaDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AreaClient) DeleteOneID(id uint64) *AreaDeleteOne {
	builder := c.Delete().Where(area.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AreaDeleteOne{builder}
}

// Query returns a query builder for Area.
func (c *AreaClient) Query() *AreaQuery {
	return &AreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArea},
		inters: c.Interceptors(),
	}
}

// Get returns a Area entity by its id.
func (c *AreaClient) Get(ctx context.Context, id uint64) (*Area, error) {
	return c.Query().Where(area.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AreaClient) GetX(ctx context.Context, id uint64) *Area {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AreaClient) Hooks() []Hook {
	return c.hooks.Area
}

// Interceptors returns the client interceptors.
func (c *AreaClient) Interceptors() []Interceptor {
	return c.inters.Area
}

func (c *AreaClient) mutate(ctx context.Context, m *AreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Area mutation op: %q", m.Op())
	}
}

// CameraClient is a client for the Camera schema.
type CameraClient struct {
	config
}

// NewCameraClient returns a client for the Camera from the given config.
func NewCameraClient(c config) *CameraClient {
	return &CameraClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `camera.Hooks(f(g(h())))`.
func (c *CameraClient) Use(hooks ...Hook) {
	c.hooks.Camera = append(c.hooks.Camera, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `camera.Intercept(f(g(h())))`.
func (c *CameraClient) Intercept(interceptors ...Interceptor) {
	c.inters.Camera = append(c.inters.Camera, interceptors...)
}

// Create returns a builder for creating a Camera entity.
func (c *CameraClient) Create() *CameraCreate {
	mutation := newCameraMutation(c.config, OpCreate)
	return &CameraCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Camera entities.
func (c *CameraClient) CreateBulk(builders ...*CameraCreate) *CameraCreateBulk {
	return &CameraCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CameraClient) MapCreateBulk(slice any, setFunc func(*CameraCreate, int)) *CameraCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CameraCreateBulk{err: fmt.Errorf("calling to CameraClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CameraCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CameraCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Camera.
func (c *CameraClient) Update() *CameraUpdate {
	mutation := newCameraMutation(c.config, OpUpdate)
	return &CameraUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CameraClient) UpdateOne(ca *Camera) *CameraUpdateOne {
	mutation := newCameraMutation(c.config, OpUpdateOne, withCamera(ca))
	return &CameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CameraClient) UpdateOneID(id uint64) *CameraUpdateOne {
	mutation := newCameraMutation(c.config, OpUpdateOne, withCameraID(id))
	return &CameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Camera.
func (c *CameraClient) Delete() *CameraDelete {
	mutation := newCameraMutation(c.config, OpDelete)
	return &CameraDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CameraClient) DeleteOne(ca *Camera) *CameraDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CameraClient) DeleteOneID(id uint64) *CameraDeleteOne {
	builder := c.Delete().Where(camera.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CameraDeleteOne{builder}
}

// Query returns a query builder for Camera.
func (c *CameraClient) Query() *CameraQuery {
	return &CameraQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCamera},
		inters: c.Interceptors(),
	}
}

// Get returns a Camera entity by its id.
func (c *CameraClient) Get(ctx context.Context, id uint64) (*Camera, error) {
	return c.Query().Where(camera.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CameraClient) GetX(ctx context.Context, id uint64) *Camera {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTask queries the task edge of a Camera.
func (c *CameraClient) QueryTask(ca *Camera) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, camera.TaskTable, camera.TaskPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a Camera.
func (c *CameraClient) QueryDevice(ca *Camera) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, camera.DeviceTable, camera.DevicePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTaskCamera queries the task_camera edge of a Camera.
func (c *CameraClient) QueryTaskCamera(ca *Camera) *TaskCameraQuery {
	query := (&TaskCameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(taskcamera.Table, taskcamera.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, camera.TaskCameraTable, camera.TaskCameraColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceCamera queries the device_camera edge of a Camera.
func (c *CameraClient) QueryDeviceCamera(ca *Camera) *DeviceCameraQuery {
	query := (&DeviceCameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(devicecamera.Table, devicecamera.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, camera.DeviceCameraTable, camera.DeviceCameraColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CameraClient) Hooks() []Hook {
	hooks := c.hooks.Camera
	return append(hooks[:len(hooks):len(hooks)], camera.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CameraClient) Interceptors() []Interceptor {
	inters := c.inters.Camera
	return append(inters[:len(inters):len(inters)], camera.Interceptors[:]...)
}

func (c *CameraClient) mutate(ctx context.Context, m *CameraMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CameraCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CameraUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CameraDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Camera mutation op: %q", m.Op())
	}
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `device.Intercept(f(g(h())))`.
func (c *DeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Device = append(c.inters.Device, interceptors...)
}

// Create returns a builder for creating a Device entity.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceClient) MapCreateBulk(slice any, setFunc func(*DeviceCreate, int)) *DeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceCreateBulk{err: fmt.Errorf("calling to DeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id uint64) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceClient) DeleteOneID(id uint64) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id uint64) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id uint64) *Device {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCamera queries the camera edge of a Device.
func (c *DeviceClient) QueryCamera(d *Device) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, device.CameraTable, device.CameraPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTaskDevice queries the task_device edge of a Device.
func (c *DeviceClient) QueryTaskDevice(d *Device) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, device.TaskDeviceTable, device.TaskDeviceColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeviceCamera queries the device_camera edge of a Device.
func (c *DeviceClient) QueryDeviceCamera(d *Device) *DeviceCameraQuery {
	query := (&DeviceCameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(devicecamera.Table, devicecamera.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, device.DeviceCameraTable, device.DeviceCameraColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	hooks := c.hooks.Device
	return append(hooks[:len(hooks):len(hooks)], device.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DeviceClient) Interceptors() []Interceptor {
	inters := c.inters.Device
	return append(inters[:len(inters):len(inters)], device.Interceptors[:]...)
}

func (c *DeviceClient) mutate(ctx context.Context, m *DeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Device mutation op: %q", m.Op())
	}
}

// DeviceAlgoClient is a client for the DeviceAlgo schema.
type DeviceAlgoClient struct {
	config
}

// NewDeviceAlgoClient returns a client for the DeviceAlgo from the given config.
func NewDeviceAlgoClient(c config) *DeviceAlgoClient {
	return &DeviceAlgoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicealgo.Hooks(f(g(h())))`.
func (c *DeviceAlgoClient) Use(hooks ...Hook) {
	c.hooks.DeviceAlgo = append(c.hooks.DeviceAlgo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicealgo.Intercept(f(g(h())))`.
func (c *DeviceAlgoClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceAlgo = append(c.inters.DeviceAlgo, interceptors...)
}

// Create returns a builder for creating a DeviceAlgo entity.
func (c *DeviceAlgoClient) Create() *DeviceAlgoCreate {
	mutation := newDeviceAlgoMutation(c.config, OpCreate)
	return &DeviceAlgoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceAlgo entities.
func (c *DeviceAlgoClient) CreateBulk(builders ...*DeviceAlgoCreate) *DeviceAlgoCreateBulk {
	return &DeviceAlgoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceAlgoClient) MapCreateBulk(slice any, setFunc func(*DeviceAlgoCreate, int)) *DeviceAlgoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceAlgoCreateBulk{err: fmt.Errorf("calling to DeviceAlgoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceAlgoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceAlgoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceAlgo.
func (c *DeviceAlgoClient) Update() *DeviceAlgoUpdate {
	mutation := newDeviceAlgoMutation(c.config, OpUpdate)
	return &DeviceAlgoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceAlgoClient) UpdateOne(da *DeviceAlgo) *DeviceAlgoUpdateOne {
	mutation := newDeviceAlgoMutation(c.config, OpUpdateOne, withDeviceAlgo(da))
	return &DeviceAlgoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceAlgoClient) UpdateOneID(id uint64) *DeviceAlgoUpdateOne {
	mutation := newDeviceAlgoMutation(c.config, OpUpdateOne, withDeviceAlgoID(id))
	return &DeviceAlgoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceAlgo.
func (c *DeviceAlgoClient) Delete() *DeviceAlgoDelete {
	mutation := newDeviceAlgoMutation(c.config, OpDelete)
	return &DeviceAlgoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceAlgoClient) DeleteOne(da *DeviceAlgo) *DeviceAlgoDeleteOne {
	return c.DeleteOneID(da.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceAlgoClient) DeleteOneID(id uint64) *DeviceAlgoDeleteOne {
	builder := c.Delete().Where(devicealgo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceAlgoDeleteOne{builder}
}

// Query returns a query builder for DeviceAlgo.
func (c *DeviceAlgoClient) Query() *DeviceAlgoQuery {
	return &DeviceAlgoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceAlgo},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceAlgo entity by its id.
func (c *DeviceAlgoClient) Get(ctx context.Context, id uint64) (*DeviceAlgo, error) {
	return c.Query().Where(devicealgo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceAlgoClient) GetX(ctx context.Context, id uint64) *DeviceAlgo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DeviceAlgoClient) Hooks() []Hook {
	return c.hooks.DeviceAlgo
}

// Interceptors returns the client interceptors.
func (c *DeviceAlgoClient) Interceptors() []Interceptor {
	return c.inters.DeviceAlgo
}

func (c *DeviceAlgoClient) mutate(ctx context.Context, m *DeviceAlgoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceAlgoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceAlgoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceAlgoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceAlgoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeviceAlgo mutation op: %q", m.Op())
	}
}

// DeviceCameraClient is a client for the DeviceCamera schema.
type DeviceCameraClient struct {
	config
}

// NewDeviceCameraClient returns a client for the DeviceCamera from the given config.
func NewDeviceCameraClient(c config) *DeviceCameraClient {
	return &DeviceCameraClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicecamera.Hooks(f(g(h())))`.
func (c *DeviceCameraClient) Use(hooks ...Hook) {
	c.hooks.DeviceCamera = append(c.hooks.DeviceCamera, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicecamera.Intercept(f(g(h())))`.
func (c *DeviceCameraClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceCamera = append(c.inters.DeviceCamera, interceptors...)
}

// Create returns a builder for creating a DeviceCamera entity.
func (c *DeviceCameraClient) Create() *DeviceCameraCreate {
	mutation := newDeviceCameraMutation(c.config, OpCreate)
	return &DeviceCameraCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceCamera entities.
func (c *DeviceCameraClient) CreateBulk(builders ...*DeviceCameraCreate) *DeviceCameraCreateBulk {
	return &DeviceCameraCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceCameraClient) MapCreateBulk(slice any, setFunc func(*DeviceCameraCreate, int)) *DeviceCameraCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceCameraCreateBulk{err: fmt.Errorf("calling to DeviceCameraClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceCameraCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceCameraCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceCamera.
func (c *DeviceCameraClient) Update() *DeviceCameraUpdate {
	mutation := newDeviceCameraMutation(c.config, OpUpdate)
	return &DeviceCameraUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceCameraClient) UpdateOne(dc *DeviceCamera) *DeviceCameraUpdateOne {
	mutation := newDeviceCameraMutation(c.config, OpUpdateOne, withDeviceCamera(dc))
	return &DeviceCameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceCameraClient) UpdateOneID(id uint64) *DeviceCameraUpdateOne {
	mutation := newDeviceCameraMutation(c.config, OpUpdateOne, withDeviceCameraID(id))
	return &DeviceCameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceCamera.
func (c *DeviceCameraClient) Delete() *DeviceCameraDelete {
	mutation := newDeviceCameraMutation(c.config, OpDelete)
	return &DeviceCameraDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceCameraClient) DeleteOne(dc *DeviceCamera) *DeviceCameraDeleteOne {
	return c.DeleteOneID(dc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceCameraClient) DeleteOneID(id uint64) *DeviceCameraDeleteOne {
	builder := c.Delete().Where(devicecamera.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceCameraDeleteOne{builder}
}

// Query returns a query builder for DeviceCamera.
func (c *DeviceCameraClient) Query() *DeviceCameraQuery {
	return &DeviceCameraQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceCamera},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceCamera entity by its id.
func (c *DeviceCameraClient) Get(ctx context.Context, id uint64) (*DeviceCamera, error) {
	return c.Query().Where(devicecamera.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceCameraClient) GetX(ctx context.Context, id uint64) *DeviceCamera {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCamera queries the camera edge of a DeviceCamera.
func (c *DeviceCameraClient) QueryCamera(dc *DeviceCamera) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicecamera.Table, devicecamera.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, devicecamera.CameraTable, devicecamera.CameraColumn),
		)
		fromV = sqlgraph.Neighbors(dc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a DeviceCamera.
func (c *DeviceCameraClient) QueryDevice(dc *DeviceCamera) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(devicecamera.Table, devicecamera.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, devicecamera.DeviceTable, devicecamera.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(dc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceCameraClient) Hooks() []Hook {
	return c.hooks.DeviceCamera
}

// Interceptors returns the client interceptors.
func (c *DeviceCameraClient) Interceptors() []Interceptor {
	return c.inters.DeviceCamera
}

func (c *DeviceCameraClient) mutate(ctx context.Context, m *DeviceCameraMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceCameraCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceCameraUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceCameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceCameraDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeviceCamera mutation op: %q", m.Op())
	}
}

// DeviceTokenClient is a client for the DeviceToken schema.
type DeviceTokenClient struct {
	config
}

// NewDeviceTokenClient returns a client for the DeviceToken from the given config.
func NewDeviceTokenClient(c config) *DeviceTokenClient {
	return &DeviceTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devicetoken.Hooks(f(g(h())))`.
func (c *DeviceTokenClient) Use(hooks ...Hook) {
	c.hooks.DeviceToken = append(c.hooks.DeviceToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devicetoken.Intercept(f(g(h())))`.
func (c *DeviceTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.DeviceToken = append(c.inters.DeviceToken, interceptors...)
}

// Create returns a builder for creating a DeviceToken entity.
func (c *DeviceTokenClient) Create() *DeviceTokenCreate {
	mutation := newDeviceTokenMutation(c.config, OpCreate)
	return &DeviceTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DeviceToken entities.
func (c *DeviceTokenClient) CreateBulk(builders ...*DeviceTokenCreate) *DeviceTokenCreateBulk {
	return &DeviceTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeviceTokenClient) MapCreateBulk(slice any, setFunc func(*DeviceTokenCreate, int)) *DeviceTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeviceTokenCreateBulk{err: fmt.Errorf("calling to DeviceTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeviceTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeviceTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DeviceToken.
func (c *DeviceTokenClient) Update() *DeviceTokenUpdate {
	mutation := newDeviceTokenMutation(c.config, OpUpdate)
	return &DeviceTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceTokenClient) UpdateOne(dt *DeviceToken) *DeviceTokenUpdateOne {
	mutation := newDeviceTokenMutation(c.config, OpUpdateOne, withDeviceToken(dt))
	return &DeviceTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceTokenClient) UpdateOneID(id uint64) *DeviceTokenUpdateOne {
	mutation := newDeviceTokenMutation(c.config, OpUpdateOne, withDeviceTokenID(id))
	return &DeviceTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DeviceToken.
func (c *DeviceTokenClient) Delete() *DeviceTokenDelete {
	mutation := newDeviceTokenMutation(c.config, OpDelete)
	return &DeviceTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceTokenClient) DeleteOne(dt *DeviceToken) *DeviceTokenDeleteOne {
	return c.DeleteOneID(dt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceTokenClient) DeleteOneID(id uint64) *DeviceTokenDeleteOne {
	builder := c.Delete().Where(devicetoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceTokenDeleteOne{builder}
}

// Query returns a query builder for DeviceToken.
func (c *DeviceTokenClient) Query() *DeviceTokenQuery {
	return &DeviceTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeviceToken},
		inters: c.Interceptors(),
	}
}

// Get returns a DeviceToken entity by its id.
func (c *DeviceTokenClient) Get(ctx context.Context, id uint64) (*DeviceToken, error) {
	return c.Query().Where(devicetoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceTokenClient) GetX(ctx context.Context, id uint64) *DeviceToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DeviceTokenClient) Hooks() []Hook {
	hooks := c.hooks.DeviceToken
	return append(hooks[:len(hooks):len(hooks)], devicetoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DeviceTokenClient) Interceptors() []Interceptor {
	inters := c.inters.DeviceToken
	return append(inters[:len(inters):len(inters)], devicetoken.Interceptors[:]...)
}

func (c *DeviceTokenClient) mutate(ctx context.Context, m *DeviceTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeviceTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeviceTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeviceTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeviceTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DeviceToken mutation op: %q", m.Op())
	}
}

// EquipAttrClient is a client for the EquipAttr schema.
type EquipAttrClient struct {
	config
}

// NewEquipAttrClient returns a client for the EquipAttr from the given config.
func NewEquipAttrClient(c config) *EquipAttrClient {
	return &EquipAttrClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `equipattr.Hooks(f(g(h())))`.
func (c *EquipAttrClient) Use(hooks ...Hook) {
	c.hooks.EquipAttr = append(c.hooks.EquipAttr, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `equipattr.Intercept(f(g(h())))`.
func (c *EquipAttrClient) Intercept(interceptors ...Interceptor) {
	c.inters.EquipAttr = append(c.inters.EquipAttr, interceptors...)
}

// Create returns a builder for creating a EquipAttr entity.
func (c *EquipAttrClient) Create() *EquipAttrCreate {
	mutation := newEquipAttrMutation(c.config, OpCreate)
	return &EquipAttrCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EquipAttr entities.
func (c *EquipAttrClient) CreateBulk(builders ...*EquipAttrCreate) *EquipAttrCreateBulk {
	return &EquipAttrCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EquipAttrClient) MapCreateBulk(slice any, setFunc func(*EquipAttrCreate, int)) *EquipAttrCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EquipAttrCreateBulk{err: fmt.Errorf("calling to EquipAttrClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EquipAttrCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EquipAttrCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EquipAttr.
func (c *EquipAttrClient) Update() *EquipAttrUpdate {
	mutation := newEquipAttrMutation(c.config, OpUpdate)
	return &EquipAttrUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EquipAttrClient) UpdateOne(ea *EquipAttr) *EquipAttrUpdateOne {
	mutation := newEquipAttrMutation(c.config, OpUpdateOne, withEquipAttr(ea))
	return &EquipAttrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EquipAttrClient) UpdateOneID(id uint64) *EquipAttrUpdateOne {
	mutation := newEquipAttrMutation(c.config, OpUpdateOne, withEquipAttrID(id))
	return &EquipAttrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EquipAttr.
func (c *EquipAttrClient) Delete() *EquipAttrDelete {
	mutation := newEquipAttrMutation(c.config, OpDelete)
	return &EquipAttrDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EquipAttrClient) DeleteOne(ea *EquipAttr) *EquipAttrDeleteOne {
	return c.DeleteOneID(ea.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EquipAttrClient) DeleteOneID(id uint64) *EquipAttrDeleteOne {
	builder := c.Delete().Where(equipattr.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EquipAttrDeleteOne{builder}
}

// Query returns a query builder for EquipAttr.
func (c *EquipAttrClient) Query() *EquipAttrQuery {
	return &EquipAttrQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEquipAttr},
		inters: c.Interceptors(),
	}
}

// Get returns a EquipAttr entity by its id.
func (c *EquipAttrClient) Get(ctx context.Context, id uint64) (*EquipAttr, error) {
	return c.Query().Where(equipattr.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EquipAttrClient) GetX(ctx context.Context, id uint64) *EquipAttr {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EquipAttrClient) Hooks() []Hook {
	hooks := c.hooks.EquipAttr
	return append(hooks[:len(hooks):len(hooks)], equipattr.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EquipAttrClient) Interceptors() []Interceptor {
	inters := c.inters.EquipAttr
	return append(inters[:len(inters):len(inters)], equipattr.Interceptors[:]...)
}

func (c *EquipAttrClient) mutate(ctx context.Context, m *EquipAttrMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EquipAttrCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EquipAttrUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EquipAttrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EquipAttrDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EquipAttr mutation op: %q", m.Op())
	}
}

// EventSubscriptionClient is a client for the EventSubscription schema.
type EventSubscriptionClient struct {
	config
}

// NewEventSubscriptionClient returns a client for the EventSubscription from the given config.
func NewEventSubscriptionClient(c config) *EventSubscriptionClient {
	return &EventSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventsubscription.Hooks(f(g(h())))`.
func (c *EventSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.EventSubscription = append(c.hooks.EventSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventsubscription.Intercept(f(g(h())))`.
func (c *EventSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventSubscription = append(c.inters.EventSubscription, interceptors...)
}

// Create returns a builder for creating a EventSubscription entity.
func (c *EventSubscriptionClient) Create() *EventSubscriptionCreate {
	mutation := newEventSubscriptionMutation(c.config, OpCreate)
	return &EventSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventSubscription entities.
func (c *EventSubscriptionClient) CreateBulk(builders ...*EventSubscriptionCreate) *EventSubscriptionCreateBulk {
	return &EventSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventSubscriptionClient) MapCreateBulk(slice any, setFunc func(*EventSubscriptionCreate, int)) *EventSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventSubscriptionCreateBulk{err: fmt.Errorf("calling to EventSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventSubscription.
func (c *EventSubscriptionClient) Update() *EventSubscriptionUpdate {
	mutation := newEventSubscriptionMutation(c.config, OpUpdate)
	return &EventSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventSubscriptionClient) UpdateOne(es *EventSubscription) *EventSubscriptionUpdateOne {
	mutation := newEventSubscriptionMutation(c.config, OpUpdateOne, withEventSubscription(es))
	return &EventSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventSubscriptionClient) UpdateOneID(id uint64) *EventSubscriptionUpdateOne {
	mutation := newEventSubscriptionMutation(c.config, OpUpdateOne, withEventSubscriptionID(id))
	return &EventSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventSubscription.
func (c *EventSubscriptionClient) Delete() *EventSubscriptionDelete {
	mutation := newEventSubscriptionMutation(c.config, OpDelete)
	return &EventSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventSubscriptionClient) DeleteOne(es *EventSubscription) *EventSubscriptionDeleteOne {
	return c.DeleteOneID(es.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventSubscriptionClient) DeleteOneID(id uint64) *EventSubscriptionDeleteOne {
	builder := c.Delete().Where(eventsubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventSubscriptionDeleteOne{builder}
}

// Query returns a query builder for EventSubscription.
func (c *EventSubscriptionClient) Query() *EventSubscriptionQuery {
	return &EventSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a EventSubscription entity by its id.
func (c *EventSubscriptionClient) Get(ctx context.Context, id uint64) (*EventSubscription, error) {
	return c.Query().Where(eventsubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventSubscriptionClient) GetX(ctx context.Context, id uint64) *EventSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventSubscriptionClient) Hooks() []Hook {
	hooks := c.hooks.EventSubscription
	return append(hooks[:len(hooks):len(hooks)], eventsubscription.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EventSubscriptionClient) Interceptors() []Interceptor {
	inters := c.inters.EventSubscription
	return append(inters[:len(inters):len(inters)], eventsubscription.Interceptors[:]...)
}

func (c *EventSubscriptionClient) mutate(ctx context.Context, m *EventSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventSubscription mutation op: %q", m.Op())
	}
}

// FileUploadClient is a client for the FileUpload schema.
type FileUploadClient struct {
	config
}

// NewFileUploadClient returns a client for the FileUpload from the given config.
func NewFileUploadClient(c config) *FileUploadClient {
	return &FileUploadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fileupload.Hooks(f(g(h())))`.
func (c *FileUploadClient) Use(hooks ...Hook) {
	c.hooks.FileUpload = append(c.hooks.FileUpload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fileupload.Intercept(f(g(h())))`.
func (c *FileUploadClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileUpload = append(c.inters.FileUpload, interceptors...)
}

// Create returns a builder for creating a FileUpload entity.
func (c *FileUploadClient) Create() *FileUploadCreate {
	mutation := newFileUploadMutation(c.config, OpCreate)
	return &FileUploadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileUpload entities.
func (c *FileUploadClient) CreateBulk(builders ...*FileUploadCreate) *FileUploadCreateBulk {
	return &FileUploadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileUploadClient) MapCreateBulk(slice any, setFunc func(*FileUploadCreate, int)) *FileUploadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileUploadCreateBulk{err: fmt.Errorf("calling to FileUploadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileUploadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileUploadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileUpload.
func (c *FileUploadClient) Update() *FileUploadUpdate {
	mutation := newFileUploadMutation(c.config, OpUpdate)
	return &FileUploadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileUploadClient) UpdateOne(fu *FileUpload) *FileUploadUpdateOne {
	mutation := newFileUploadMutation(c.config, OpUpdateOne, withFileUpload(fu))
	return &FileUploadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileUploadClient) UpdateOneID(id uint64) *FileUploadUpdateOne {
	mutation := newFileUploadMutation(c.config, OpUpdateOne, withFileUploadID(id))
	return &FileUploadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileUpload.
func (c *FileUploadClient) Delete() *FileUploadDelete {
	mutation := newFileUploadMutation(c.config, OpDelete)
	return &FileUploadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileUploadClient) DeleteOne(fu *FileUpload) *FileUploadDeleteOne {
	return c.DeleteOneID(fu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileUploadClient) DeleteOneID(id uint64) *FileUploadDeleteOne {
	builder := c.Delete().Where(fileupload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileUploadDeleteOne{builder}
}

// Query returns a query builder for FileUpload.
func (c *FileUploadClient) Query() *FileUploadQuery {
	return &FileUploadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileUpload},
		inters: c.Interceptors(),
	}
}

// Get returns a FileUpload entity by its id.
func (c *FileUploadClient) Get(ctx context.Context, id uint64) (*FileUpload, error) {
	return c.Query().Where(fileupload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileUploadClient) GetX(ctx context.Context, id uint64) *FileUpload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FileUploadClient) Hooks() []Hook {
	hooks := c.hooks.FileUpload
	return append(hooks[:len(hooks):len(hooks)], fileupload.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileUploadClient) Interceptors() []Interceptor {
	inters := c.inters.FileUpload
	return append(inters[:len(inters):len(inters)], fileupload.Interceptors[:]...)
}

func (c *FileUploadClient) mutate(ctx context.Context, m *FileUploadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileUploadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUploadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUploadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileUploadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileUpload mutation op: %q", m.Op())
	}
}

// InformClient is a client for the Inform schema.
type InformClient struct {
	config
}

// NewInformClient returns a client for the Inform from the given config.
func NewInformClient(c config) *InformClient {
	return &InformClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inform.Hooks(f(g(h())))`.
func (c *InformClient) Use(hooks ...Hook) {
	c.hooks.Inform = append(c.hooks.Inform, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inform.Intercept(f(g(h())))`.
func (c *InformClient) Intercept(interceptors ...Interceptor) {
	c.inters.Inform = append(c.inters.Inform, interceptors...)
}

// Create returns a builder for creating a Inform entity.
func (c *InformClient) Create() *InformCreate {
	mutation := newInformMutation(c.config, OpCreate)
	return &InformCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Inform entities.
func (c *InformClient) CreateBulk(builders ...*InformCreate) *InformCreateBulk {
	return &InformCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InformClient) MapCreateBulk(slice any, setFunc func(*InformCreate, int)) *InformCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InformCreateBulk{err: fmt.Errorf("calling to InformClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InformCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InformCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Inform.
func (c *InformClient) Update() *InformUpdate {
	mutation := newInformMutation(c.config, OpUpdate)
	return &InformUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InformClient) UpdateOne(i *Inform) *InformUpdateOne {
	mutation := newInformMutation(c.config, OpUpdateOne, withInform(i))
	return &InformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InformClient) UpdateOneID(id uint64) *InformUpdateOne {
	mutation := newInformMutation(c.config, OpUpdateOne, withInformID(id))
	return &InformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Inform.
func (c *InformClient) Delete() *InformDelete {
	mutation := newInformMutation(c.config, OpDelete)
	return &InformDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InformClient) DeleteOne(i *Inform) *InformDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InformClient) DeleteOneID(id uint64) *InformDeleteOne {
	builder := c.Delete().Where(inform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InformDeleteOne{builder}
}

// Query returns a query builder for Inform.
func (c *InformClient) Query() *InformQuery {
	return &InformQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInform},
		inters: c.Interceptors(),
	}
}

// Get returns a Inform entity by its id.
func (c *InformClient) Get(ctx context.Context, id uint64) (*Inform, error) {
	return c.Query().Where(inform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InformClient) GetX(ctx context.Context, id uint64) *Inform {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InformClient) Hooks() []Hook {
	hooks := c.hooks.Inform
	return append(hooks[:len(hooks):len(hooks)], inform.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InformClient) Interceptors() []Interceptor {
	inters := c.inters.Inform
	return append(inters[:len(inters):len(inters)], inform.Interceptors[:]...)
}

func (c *InformClient) mutate(ctx context.Context, m *InformMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InformCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InformUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InformDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Inform mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id uint32) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id uint32) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id uint32) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id uint32) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Organization
	return append(hooks[:len(hooks):len(hooks)], organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	inters := c.inters.Organization
	return append(inters[:len(inters):len(inters)], organization.Interceptors[:]...)
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(s *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(s))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id uint64) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(s *Setting) *SettingDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id uint64) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id uint64) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id uint64) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// SignatureClient is a client for the Signature schema.
type SignatureClient struct {
	config
}

// NewSignatureClient returns a client for the Signature from the given config.
func NewSignatureClient(c config) *SignatureClient {
	return &SignatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `signature.Hooks(f(g(h())))`.
func (c *SignatureClient) Use(hooks ...Hook) {
	c.hooks.Signature = append(c.hooks.Signature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `signature.Intercept(f(g(h())))`.
func (c *SignatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Signature = append(c.inters.Signature, interceptors...)
}

// Create returns a builder for creating a Signature entity.
func (c *SignatureClient) Create() *SignatureCreate {
	mutation := newSignatureMutation(c.config, OpCreate)
	return &SignatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Signature entities.
func (c *SignatureClient) CreateBulk(builders ...*SignatureCreate) *SignatureCreateBulk {
	return &SignatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SignatureClient) MapCreateBulk(slice any, setFunc func(*SignatureCreate, int)) *SignatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SignatureCreateBulk{err: fmt.Errorf("calling to SignatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SignatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SignatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Signature.
func (c *SignatureClient) Update() *SignatureUpdate {
	mutation := newSignatureMutation(c.config, OpUpdate)
	return &SignatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SignatureClient) UpdateOne(s *Signature) *SignatureUpdateOne {
	mutation := newSignatureMutation(c.config, OpUpdateOne, withSignature(s))
	return &SignatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SignatureClient) UpdateOneID(id uint64) *SignatureUpdateOne {
	mutation := newSignatureMutation(c.config, OpUpdateOne, withSignatureID(id))
	return &SignatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Signature.
func (c *SignatureClient) Delete() *SignatureDelete {
	mutation := newSignatureMutation(c.config, OpDelete)
	return &SignatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SignatureClient) DeleteOne(s *Signature) *SignatureDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SignatureClient) DeleteOneID(id uint64) *SignatureDeleteOne {
	builder := c.Delete().Where(signature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SignatureDeleteOne{builder}
}

// Query returns a query builder for Signature.
func (c *SignatureClient) Query() *SignatureQuery {
	return &SignatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSignature},
		inters: c.Interceptors(),
	}
}

// Get returns a Signature entity by its id.
func (c *SignatureClient) Get(ctx context.Context, id uint64) (*Signature, error) {
	return c.Query().Where(signature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SignatureClient) GetX(ctx context.Context, id uint64) *Signature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SignatureClient) Hooks() []Hook {
	hooks := c.hooks.Signature
	return append(hooks[:len(hooks):len(hooks)], signature.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SignatureClient) Interceptors() []Interceptor {
	inters := c.inters.Signature
	return append(inters[:len(inters):len(inters)], signature.Interceptors[:]...)
}

func (c *SignatureClient) mutate(ctx context.Context, m *SignatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SignatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SignatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SignatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SignatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Signature mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id uint64) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id uint64) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id uint64) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id uint64) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCamera queries the camera edge of a Task.
func (c *TaskClient) QueryCamera(t *Task) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, task.CameraTable, task.CameraPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlgorithm queries the algorithm edge of a Task.
func (c *TaskClient) QueryAlgorithm(t *Task) *AlgorithmQuery {
	query := (&AlgorithmClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(algorithm.Table, algorithm.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AlgorithmTable, task.AlgorithmColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a Task.
func (c *TaskClient) QueryDevice(t *Task) *DeviceQuery {
	query := (&DeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.DeviceTable, task.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTaskCamera queries the task_camera edge of a Task.
func (c *TaskClient) QueryTaskCamera(t *Task) *TaskCameraQuery {
	query := (&TaskCameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(taskcamera.Table, taskcamera.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, task.TaskCameraTable, task.TaskCameraColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	hooks := c.hooks.Task
	return append(hooks[:len(hooks):len(hooks)], task.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	inters := c.inters.Task
	return append(inters[:len(inters):len(inters)], task.Interceptors[:]...)
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// TaskCameraClient is a client for the TaskCamera schema.
type TaskCameraClient struct {
	config
}

// NewTaskCameraClient returns a client for the TaskCamera from the given config.
func NewTaskCameraClient(c config) *TaskCameraClient {
	return &TaskCameraClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskcamera.Hooks(f(g(h())))`.
func (c *TaskCameraClient) Use(hooks ...Hook) {
	c.hooks.TaskCamera = append(c.hooks.TaskCamera, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskcamera.Intercept(f(g(h())))`.
func (c *TaskCameraClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskCamera = append(c.inters.TaskCamera, interceptors...)
}

// Create returns a builder for creating a TaskCamera entity.
func (c *TaskCameraClient) Create() *TaskCameraCreate {
	mutation := newTaskCameraMutation(c.config, OpCreate)
	return &TaskCameraCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskCamera entities.
func (c *TaskCameraClient) CreateBulk(builders ...*TaskCameraCreate) *TaskCameraCreateBulk {
	return &TaskCameraCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskCameraClient) MapCreateBulk(slice any, setFunc func(*TaskCameraCreate, int)) *TaskCameraCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCameraCreateBulk{err: fmt.Errorf("calling to TaskCameraClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCameraCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCameraCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskCamera.
func (c *TaskCameraClient) Update() *TaskCameraUpdate {
	mutation := newTaskCameraMutation(c.config, OpUpdate)
	return &TaskCameraUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskCameraClient) UpdateOne(tc *TaskCamera) *TaskCameraUpdateOne {
	mutation := newTaskCameraMutation(c.config, OpUpdateOne, withTaskCamera(tc))
	return &TaskCameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskCameraClient) UpdateOneID(id uint64) *TaskCameraUpdateOne {
	mutation := newTaskCameraMutation(c.config, OpUpdateOne, withTaskCameraID(id))
	return &TaskCameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskCamera.
func (c *TaskCameraClient) Delete() *TaskCameraDelete {
	mutation := newTaskCameraMutation(c.config, OpDelete)
	return &TaskCameraDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskCameraClient) DeleteOne(tc *TaskCamera) *TaskCameraDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskCameraClient) DeleteOneID(id uint64) *TaskCameraDeleteOne {
	builder := c.Delete().Where(taskcamera.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskCameraDeleteOne{builder}
}

// Query returns a query builder for TaskCamera.
func (c *TaskCameraClient) Query() *TaskCameraQuery {
	return &TaskCameraQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskCamera},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskCamera entity by its id.
func (c *TaskCameraClient) Get(ctx context.Context, id uint64) (*TaskCamera, error) {
	return c.Query().Where(taskcamera.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskCameraClient) GetX(ctx context.Context, id uint64) *TaskCamera {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCamera queries the camera edge of a TaskCamera.
func (c *TaskCameraClient) QueryCamera(tc *TaskCamera) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskcamera.Table, taskcamera.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, taskcamera.CameraTable, taskcamera.CameraColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a TaskCamera.
func (c *TaskCameraClient) QueryTask(tc *TaskCamera) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskcamera.Table, taskcamera.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, taskcamera.TaskTable, taskcamera.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskCameraClient) Hooks() []Hook {
	hooks := c.hooks.TaskCamera
	return append(hooks[:len(hooks):len(hooks)], taskcamera.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskCameraClient) Interceptors() []Interceptor {
	inters := c.inters.TaskCamera
	return append(inters[:len(inters):len(inters)], taskcamera.Interceptors[:]...)
}

func (c *TaskCameraClient) mutate(ctx context.Context, m *TaskCameraMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCameraCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskCameraUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskCameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskCameraDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TaskCamera mutation op: %q", m.Op())
	}
}

// TaskLimitsClient is a client for the TaskLimits schema.
type TaskLimitsClient struct {
	config
}

// NewTaskLimitsClient returns a client for the TaskLimits from the given config.
func NewTaskLimitsClient(c config) *TaskLimitsClient {
	return &TaskLimitsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tasklimits.Hooks(f(g(h())))`.
func (c *TaskLimitsClient) Use(hooks ...Hook) {
	c.hooks.TaskLimits = append(c.hooks.TaskLimits, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tasklimits.Intercept(f(g(h())))`.
func (c *TaskLimitsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskLimits = append(c.inters.TaskLimits, interceptors...)
}

// Create returns a builder for creating a TaskLimits entity.
func (c *TaskLimitsClient) Create() *TaskLimitsCreate {
	mutation := newTaskLimitsMutation(c.config, OpCreate)
	return &TaskLimitsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskLimits entities.
func (c *TaskLimitsClient) CreateBulk(builders ...*TaskLimitsCreate) *TaskLimitsCreateBulk {
	return &TaskLimitsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskLimitsClient) MapCreateBulk(slice any, setFunc func(*TaskLimitsCreate, int)) *TaskLimitsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskLimitsCreateBulk{err: fmt.Errorf("calling to TaskLimitsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskLimitsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskLimitsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskLimits.
func (c *TaskLimitsClient) Update() *TaskLimitsUpdate {
	mutation := newTaskLimitsMutation(c.config, OpUpdate)
	return &TaskLimitsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskLimitsClient) UpdateOne(tl *TaskLimits) *TaskLimitsUpdateOne {
	mutation := newTaskLimitsMutation(c.config, OpUpdateOne, withTaskLimits(tl))
	return &TaskLimitsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskLimitsClient) UpdateOneID(id uint64) *TaskLimitsUpdateOne {
	mutation := newTaskLimitsMutation(c.config, OpUpdateOne, withTaskLimitsID(id))
	return &TaskLimitsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskLimits.
func (c *TaskLimitsClient) Delete() *TaskLimitsDelete {
	mutation := newTaskLimitsMutation(c.config, OpDelete)
	return &TaskLimitsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskLimitsClient) DeleteOne(tl *TaskLimits) *TaskLimitsDeleteOne {
	return c.DeleteOneID(tl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskLimitsClient) DeleteOneID(id uint64) *TaskLimitsDeleteOne {
	builder := c.Delete().Where(tasklimits.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskLimitsDeleteOne{builder}
}

// Query returns a query builder for TaskLimits.
func (c *TaskLimitsClient) Query() *TaskLimitsQuery {
	return &TaskLimitsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskLimits},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskLimits entity by its id.
func (c *TaskLimitsClient) Get(ctx context.Context, id uint64) (*TaskLimits, error) {
	return c.Query().Where(tasklimits.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskLimitsClient) GetX(ctx context.Context, id uint64) *TaskLimits {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskLimitsClient) Hooks() []Hook {
	hooks := c.hooks.TaskLimits
	return append(hooks[:len(hooks):len(hooks)], tasklimits.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskLimitsClient) Interceptors() []Interceptor {
	inters := c.inters.TaskLimits
	return append(inters[:len(inters):len(inters)], tasklimits.Interceptors[:]...)
}

func (c *TaskLimitsClient) mutate(ctx context.Context, m *TaskLimitsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskLimitsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskLimitsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskLimitsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskLimitsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TaskLimits mutation op: %q", m.Op())
	}
}

// UpPlatformClient is a client for the UpPlatform schema.
type UpPlatformClient struct {
	config
}

// NewUpPlatformClient returns a client for the UpPlatform from the given config.
func NewUpPlatformClient(c config) *UpPlatformClient {
	return &UpPlatformClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `upplatform.Hooks(f(g(h())))`.
func (c *UpPlatformClient) Use(hooks ...Hook) {
	c.hooks.UpPlatform = append(c.hooks.UpPlatform, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `upplatform.Intercept(f(g(h())))`.
func (c *UpPlatformClient) Intercept(interceptors ...Interceptor) {
	c.inters.UpPlatform = append(c.inters.UpPlatform, interceptors...)
}

// Create returns a builder for creating a UpPlatform entity.
func (c *UpPlatformClient) Create() *UpPlatformCreate {
	mutation := newUpPlatformMutation(c.config, OpCreate)
	return &UpPlatformCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UpPlatform entities.
func (c *UpPlatformClient) CreateBulk(builders ...*UpPlatformCreate) *UpPlatformCreateBulk {
	return &UpPlatformCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UpPlatformClient) MapCreateBulk(slice any, setFunc func(*UpPlatformCreate, int)) *UpPlatformCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UpPlatformCreateBulk{err: fmt.Errorf("calling to UpPlatformClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UpPlatformCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UpPlatformCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UpPlatform.
func (c *UpPlatformClient) Update() *UpPlatformUpdate {
	mutation := newUpPlatformMutation(c.config, OpUpdate)
	return &UpPlatformUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UpPlatformClient) UpdateOne(up *UpPlatform) *UpPlatformUpdateOne {
	mutation := newUpPlatformMutation(c.config, OpUpdateOne, withUpPlatform(up))
	return &UpPlatformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UpPlatformClient) UpdateOneID(id int) *UpPlatformUpdateOne {
	mutation := newUpPlatformMutation(c.config, OpUpdateOne, withUpPlatformID(id))
	return &UpPlatformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UpPlatform.
func (c *UpPlatformClient) Delete() *UpPlatformDelete {
	mutation := newUpPlatformMutation(c.config, OpDelete)
	return &UpPlatformDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UpPlatformClient) DeleteOne(up *UpPlatform) *UpPlatformDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UpPlatformClient) DeleteOneID(id int) *UpPlatformDeleteOne {
	builder := c.Delete().Where(upplatform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UpPlatformDeleteOne{builder}
}

// Query returns a query builder for UpPlatform.
func (c *UpPlatformClient) Query() *UpPlatformQuery {
	return &UpPlatformQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUpPlatform},
		inters: c.Interceptors(),
	}
}

// Get returns a UpPlatform entity by its id.
func (c *UpPlatformClient) Get(ctx context.Context, id int) (*UpPlatform, error) {
	return c.Query().Where(upplatform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UpPlatformClient) GetX(ctx context.Context, id int) *UpPlatform {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UpPlatformClient) Hooks() []Hook {
	hooks := c.hooks.UpPlatform
	return append(hooks[:len(hooks):len(hooks)], upplatform.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UpPlatformClient) Interceptors() []Interceptor {
	inters := c.inters.UpPlatform
	return append(inters[:len(inters):len(inters)], upplatform.Interceptors[:]...)
}

func (c *UpPlatformClient) mutate(ctx context.Context, m *UpPlatformMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UpPlatformCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UpPlatformUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UpPlatformUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UpPlatformDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UpPlatform mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uint64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// WarnPushClient is a client for the WarnPush schema.
type WarnPushClient struct {
	config
}

// NewWarnPushClient returns a client for the WarnPush from the given config.
func NewWarnPushClient(c config) *WarnPushClient {
	return &WarnPushClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `warnpush.Hooks(f(g(h())))`.
func (c *WarnPushClient) Use(hooks ...Hook) {
	c.hooks.WarnPush = append(c.hooks.WarnPush, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `warnpush.Intercept(f(g(h())))`.
func (c *WarnPushClient) Intercept(interceptors ...Interceptor) {
	c.inters.WarnPush = append(c.inters.WarnPush, interceptors...)
}

// Create returns a builder for creating a WarnPush entity.
func (c *WarnPushClient) Create() *WarnPushCreate {
	mutation := newWarnPushMutation(c.config, OpCreate)
	return &WarnPushCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WarnPush entities.
func (c *WarnPushClient) CreateBulk(builders ...*WarnPushCreate) *WarnPushCreateBulk {
	return &WarnPushCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WarnPushClient) MapCreateBulk(slice any, setFunc func(*WarnPushCreate, int)) *WarnPushCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WarnPushCreateBulk{err: fmt.Errorf("calling to WarnPushClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WarnPushCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WarnPushCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WarnPush.
func (c *WarnPushClient) Update() *WarnPushUpdate {
	mutation := newWarnPushMutation(c.config, OpUpdate)
	return &WarnPushUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WarnPushClient) UpdateOne(wp *WarnPush) *WarnPushUpdateOne {
	mutation := newWarnPushMutation(c.config, OpUpdateOne, withWarnPush(wp))
	return &WarnPushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WarnPushClient) UpdateOneID(id uint64) *WarnPushUpdateOne {
	mutation := newWarnPushMutation(c.config, OpUpdateOne, withWarnPushID(id))
	return &WarnPushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WarnPush.
func (c *WarnPushClient) Delete() *WarnPushDelete {
	mutation := newWarnPushMutation(c.config, OpDelete)
	return &WarnPushDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WarnPushClient) DeleteOne(wp *WarnPush) *WarnPushDeleteOne {
	return c.DeleteOneID(wp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WarnPushClient) DeleteOneID(id uint64) *WarnPushDeleteOne {
	builder := c.Delete().Where(warnpush.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WarnPushDeleteOne{builder}
}

// Query returns a query builder for WarnPush.
func (c *WarnPushClient) Query() *WarnPushQuery {
	return &WarnPushQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWarnPush},
		inters: c.Interceptors(),
	}
}

// Get returns a WarnPush entity by its id.
func (c *WarnPushClient) Get(ctx context.Context, id uint64) (*WarnPush, error) {
	return c.Query().Where(warnpush.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WarnPushClient) GetX(ctx context.Context, id uint64) *WarnPush {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WarnPushClient) Hooks() []Hook {
	hooks := c.hooks.WarnPush
	return append(hooks[:len(hooks):len(hooks)], warnpush.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WarnPushClient) Interceptors() []Interceptor {
	inters := c.inters.WarnPush
	return append(inters[:len(inters):len(inters)], warnpush.Interceptors[:]...)
}

func (c *WarnPushClient) mutate(ctx context.Context, m *WarnPushMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WarnPushCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WarnPushUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WarnPushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WarnPushDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WarnPush mutation op: %q", m.Op())
	}
}

// WarnPushLogClient is a client for the WarnPushLog schema.
type WarnPushLogClient struct {
	config
}

// NewWarnPushLogClient returns a client for the WarnPushLog from the given config.
func NewWarnPushLogClient(c config) *WarnPushLogClient {
	return &WarnPushLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `warnpushlog.Hooks(f(g(h())))`.
func (c *WarnPushLogClient) Use(hooks ...Hook) {
	c.hooks.WarnPushLog = append(c.hooks.WarnPushLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `warnpushlog.Intercept(f(g(h())))`.
func (c *WarnPushLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.WarnPushLog = append(c.inters.WarnPushLog, interceptors...)
}

// Create returns a builder for creating a WarnPushLog entity.
func (c *WarnPushLogClient) Create() *WarnPushLogCreate {
	mutation := newWarnPushLogMutation(c.config, OpCreate)
	return &WarnPushLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WarnPushLog entities.
func (c *WarnPushLogClient) CreateBulk(builders ...*WarnPushLogCreate) *WarnPushLogCreateBulk {
	return &WarnPushLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WarnPushLogClient) MapCreateBulk(slice any, setFunc func(*WarnPushLogCreate, int)) *WarnPushLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WarnPushLogCreateBulk{err: fmt.Errorf("calling to WarnPushLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WarnPushLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WarnPushLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WarnPushLog.
func (c *WarnPushLogClient) Update() *WarnPushLogUpdate {
	mutation := newWarnPushLogMutation(c.config, OpUpdate)
	return &WarnPushLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WarnPushLogClient) UpdateOne(wpl *WarnPushLog) *WarnPushLogUpdateOne {
	mutation := newWarnPushLogMutation(c.config, OpUpdateOne, withWarnPushLog(wpl))
	return &WarnPushLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WarnPushLogClient) UpdateOneID(id uint64) *WarnPushLogUpdateOne {
	mutation := newWarnPushLogMutation(c.config, OpUpdateOne, withWarnPushLogID(id))
	return &WarnPushLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WarnPushLog.
func (c *WarnPushLogClient) Delete() *WarnPushLogDelete {
	mutation := newWarnPushLogMutation(c.config, OpDelete)
	return &WarnPushLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WarnPushLogClient) DeleteOne(wpl *WarnPushLog) *WarnPushLogDeleteOne {
	return c.DeleteOneID(wpl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WarnPushLogClient) DeleteOneID(id uint64) *WarnPushLogDeleteOne {
	builder := c.Delete().Where(warnpushlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WarnPushLogDeleteOne{builder}
}

// Query returns a query builder for WarnPushLog.
func (c *WarnPushLogClient) Query() *WarnPushLogQuery {
	return &WarnPushLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWarnPushLog},
		inters: c.Interceptors(),
	}
}

// Get returns a WarnPushLog entity by its id.
func (c *WarnPushLogClient) Get(ctx context.Context, id uint64) (*WarnPushLog, error) {
	return c.Query().Where(warnpushlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WarnPushLogClient) GetX(ctx context.Context, id uint64) *WarnPushLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPush queries the push edge of a WarnPushLog.
func (c *WarnPushLogClient) QueryPush(wpl *WarnPushLog) *WarnPushQuery {
	query := (&WarnPushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wpl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(warnpushlog.Table, warnpushlog.FieldID, id),
			sqlgraph.To(warnpush.Table, warnpush.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, warnpushlog.PushTable, warnpushlog.PushColumn),
		)
		fromV = sqlgraph.Neighbors(wpl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WarnPushLogClient) Hooks() []Hook {
	hooks := c.hooks.WarnPushLog
	return append(hooks[:len(hooks):len(hooks)], warnpushlog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WarnPushLogClient) Interceptors() []Interceptor {
	inters := c.inters.WarnPushLog
	return append(inters[:len(inters):len(inters)], warnpushlog.Interceptors[:]...)
}

func (c *WarnPushLogClient) mutate(ctx context.Context, m *WarnPushLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WarnPushLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WarnPushLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WarnPushLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WarnPushLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WarnPushLog mutation op: %q", m.Op())
	}
}

// WarnSmsErrClient is a client for the WarnSmsErr schema.
type WarnSmsErrClient struct {
	config
}

// NewWarnSmsErrClient returns a client for the WarnSmsErr from the given config.
func NewWarnSmsErrClient(c config) *WarnSmsErrClient {
	return &WarnSmsErrClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `warnsmserr.Hooks(f(g(h())))`.
func (c *WarnSmsErrClient) Use(hooks ...Hook) {
	c.hooks.WarnSmsErr = append(c.hooks.WarnSmsErr, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `warnsmserr.Intercept(f(g(h())))`.
func (c *WarnSmsErrClient) Intercept(interceptors ...Interceptor) {
	c.inters.WarnSmsErr = append(c.inters.WarnSmsErr, interceptors...)
}

// Create returns a builder for creating a WarnSmsErr entity.
func (c *WarnSmsErrClient) Create() *WarnSmsErrCreate {
	mutation := newWarnSmsErrMutation(c.config, OpCreate)
	return &WarnSmsErrCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WarnSmsErr entities.
func (c *WarnSmsErrClient) CreateBulk(builders ...*WarnSmsErrCreate) *WarnSmsErrCreateBulk {
	return &WarnSmsErrCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WarnSmsErrClient) MapCreateBulk(slice any, setFunc func(*WarnSmsErrCreate, int)) *WarnSmsErrCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WarnSmsErrCreateBulk{err: fmt.Errorf("calling to WarnSmsErrClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WarnSmsErrCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WarnSmsErrCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WarnSmsErr.
func (c *WarnSmsErrClient) Update() *WarnSmsErrUpdate {
	mutation := newWarnSmsErrMutation(c.config, OpUpdate)
	return &WarnSmsErrUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WarnSmsErrClient) UpdateOne(wse *WarnSmsErr) *WarnSmsErrUpdateOne {
	mutation := newWarnSmsErrMutation(c.config, OpUpdateOne, withWarnSmsErr(wse))
	return &WarnSmsErrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WarnSmsErrClient) UpdateOneID(id uint64) *WarnSmsErrUpdateOne {
	mutation := newWarnSmsErrMutation(c.config, OpUpdateOne, withWarnSmsErrID(id))
	return &WarnSmsErrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WarnSmsErr.
func (c *WarnSmsErrClient) Delete() *WarnSmsErrDelete {
	mutation := newWarnSmsErrMutation(c.config, OpDelete)
	return &WarnSmsErrDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WarnSmsErrClient) DeleteOne(wse *WarnSmsErr) *WarnSmsErrDeleteOne {
	return c.DeleteOneID(wse.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WarnSmsErrClient) DeleteOneID(id uint64) *WarnSmsErrDeleteOne {
	builder := c.Delete().Where(warnsmserr.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WarnSmsErrDeleteOne{builder}
}

// Query returns a query builder for WarnSmsErr.
func (c *WarnSmsErrClient) Query() *WarnSmsErrQuery {
	return &WarnSmsErrQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWarnSmsErr},
		inters: c.Interceptors(),
	}
}

// Get returns a WarnSmsErr entity by its id.
func (c *WarnSmsErrClient) Get(ctx context.Context, id uint64) (*WarnSmsErr, error) {
	return c.Query().Where(warnsmserr.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WarnSmsErrClient) GetX(ctx context.Context, id uint64) *WarnSmsErr {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WarnSmsErrClient) Hooks() []Hook {
	hooks := c.hooks.WarnSmsErr
	return append(hooks[:len(hooks):len(hooks)], warnsmserr.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WarnSmsErrClient) Interceptors() []Interceptor {
	inters := c.inters.WarnSmsErr
	return append(inters[:len(inters):len(inters)], warnsmserr.Interceptors[:]...)
}

func (c *WarnSmsErrClient) mutate(ctx context.Context, m *WarnSmsErrMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WarnSmsErrCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WarnSmsErrUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WarnSmsErrUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WarnSmsErrDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WarnSmsErr mutation op: %q", m.Op())
	}
}

// WarningTypeClient is a client for the WarningType schema.
type WarningTypeClient struct {
	config
}

// NewWarningTypeClient returns a client for the WarningType from the given config.
func NewWarningTypeClient(c config) *WarningTypeClient {
	return &WarningTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `warningtype.Hooks(f(g(h())))`.
func (c *WarningTypeClient) Use(hooks ...Hook) {
	c.hooks.WarningType = append(c.hooks.WarningType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `warningtype.Intercept(f(g(h())))`.
func (c *WarningTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.WarningType = append(c.inters.WarningType, interceptors...)
}

// Create returns a builder for creating a WarningType entity.
func (c *WarningTypeClient) Create() *WarningTypeCreate {
	mutation := newWarningTypeMutation(c.config, OpCreate)
	return &WarningTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WarningType entities.
func (c *WarningTypeClient) CreateBulk(builders ...*WarningTypeCreate) *WarningTypeCreateBulk {
	return &WarningTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WarningTypeClient) MapCreateBulk(slice any, setFunc func(*WarningTypeCreate, int)) *WarningTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WarningTypeCreateBulk{err: fmt.Errorf("calling to WarningTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WarningTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WarningTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WarningType.
func (c *WarningTypeClient) Update() *WarningTypeUpdate {
	mutation := newWarningTypeMutation(c.config, OpUpdate)
	return &WarningTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WarningTypeClient) UpdateOne(wt *WarningType) *WarningTypeUpdateOne {
	mutation := newWarningTypeMutation(c.config, OpUpdateOne, withWarningType(wt))
	return &WarningTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WarningTypeClient) UpdateOneID(id uint64) *WarningTypeUpdateOne {
	mutation := newWarningTypeMutation(c.config, OpUpdateOne, withWarningTypeID(id))
	return &WarningTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WarningType.
func (c *WarningTypeClient) Delete() *WarningTypeDelete {
	mutation := newWarningTypeMutation(c.config, OpDelete)
	return &WarningTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WarningTypeClient) DeleteOne(wt *WarningType) *WarningTypeDeleteOne {
	return c.DeleteOneID(wt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WarningTypeClient) DeleteOneID(id uint64) *WarningTypeDeleteOne {
	builder := c.Delete().Where(warningtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WarningTypeDeleteOne{builder}
}

// Query returns a query builder for WarningType.
func (c *WarningTypeClient) Query() *WarningTypeQuery {
	return &WarningTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWarningType},
		inters: c.Interceptors(),
	}
}

// Get returns a WarningType entity by its id.
func (c *WarningTypeClient) Get(ctx context.Context, id uint64) (*WarningType, error) {
	return c.Query().Where(warningtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WarningTypeClient) GetX(ctx context.Context, id uint64) *WarningType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WarningTypeClient) Hooks() []Hook {
	hooks := c.hooks.WarningType
	return append(hooks[:len(hooks):len(hooks)], warningtype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WarningTypeClient) Interceptors() []Interceptor {
	inters := c.inters.WarningType
	return append(inters[:len(inters):len(inters)], warningtype.Interceptors[:]...)
}

func (c *WarningTypeClient) mutate(ctx context.Context, m *WarningTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WarningTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WarningTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WarningTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WarningTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WarningType mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ActiveInfo, Algorithm, AlgorithmAlarmType, Area, Camera, Device, DeviceAlgo,
		DeviceCamera, DeviceToken, EquipAttr, EventSubscription, FileUpload, Inform,
		Organization, Setting, Signature, Task, TaskCamera, TaskLimits, UpPlatform,
		User, WarnPush, WarnPushLog, WarnSmsErr, WarningType []ent.Hook
	}
	inters struct {
		ActiveInfo, Algorithm, AlgorithmAlarmType, Area, Camera, Device, DeviceAlgo,
		DeviceCamera, DeviceToken, EquipAttr, EventSubscription, FileUpload, Inform,
		Organization, Setting, Signature, Task, TaskCamera, TaskLimits, UpPlatform,
		User, WarnPush, WarnPushLog, WarnSmsErr, WarningType []ent.Interceptor
	}
)
