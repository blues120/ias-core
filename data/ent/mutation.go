// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"gitlab.ctyuncdn.cn/ias/ias-core/biz"
	"gitlab.ctyuncdn.cn/ias/ias-core/biz/streaming"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/activeinfo"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/algorithm"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/algorithmalarmtype"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/area"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/camera"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/device"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/devicealgo"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/devicecamera"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/devicetoken"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/equipattr"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/eventsubscription"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/fileupload"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/inform"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/organization"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/predicate"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/setting"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/signature"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/task"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/taskcamera"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/tasklimits"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/upplatform"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/user"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warningtype"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warnpush"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warnpushlog"
	"gitlab.ctyuncdn.cn/ias/ias-core/data/ent/warnsmserr"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActiveInfo         = "ActiveInfo"
	TypeAlgorithm          = "Algorithm"
	TypeAlgorithmAlarmType = "AlgorithmAlarmType"
	TypeArea               = "Area"
	TypeCamera             = "Camera"
	TypeDevice             = "Device"
	TypeDeviceAlgo         = "DeviceAlgo"
	TypeDeviceCamera       = "DeviceCamera"
	TypeDeviceToken        = "DeviceToken"
	TypeEquipAttr          = "EquipAttr"
	TypeEventSubscription  = "EventSubscription"
	TypeFileUpload         = "FileUpload"
	TypeInform             = "Inform"
	TypeOrganization       = "Organization"
	TypeSetting            = "Setting"
	TypeSignature          = "Signature"
	TypeTask               = "Task"
	TypeTaskCamera         = "TaskCamera"
	TypeTaskLimits         = "TaskLimits"
	TypeUpPlatform         = "UpPlatform"
	TypeUser               = "User"
	TypeWarnPush           = "WarnPush"
	TypeWarnPushLog        = "WarnPushLog"
	TypeWarnSmsErr         = "WarnSmsErr"
	TypeWarningType        = "WarningType"
)

// ActiveInfoMutation represents an operation that mutates the ActiveInfo nodes in the graph.
type ActiveInfoMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	process_id    *string
	start_time    *string
	result        *string
	msg           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ActiveInfo, error)
	predicates    []predicate.ActiveInfo
}

var _ ent.Mutation = (*ActiveInfoMutation)(nil)

// activeinfoOption allows management of the mutation configuration using functional options.
type activeinfoOption func(*ActiveInfoMutation)

// newActiveInfoMutation creates new mutation for the ActiveInfo entity.
func newActiveInfoMutation(c config, op Op, opts ...activeinfoOption) *ActiveInfoMutation {
	m := &ActiveInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeActiveInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActiveInfoID sets the ID field of the mutation.
func withActiveInfoID(id uint64) activeinfoOption {
	return func(m *ActiveInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ActiveInfo
		)
		m.oldValue = func(ctx context.Context) (*ActiveInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActiveInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActiveInfo sets the old ActiveInfo of the mutation.
func withActiveInfo(node *ActiveInfo) activeinfoOption {
	return func(m *ActiveInfoMutation) {
		m.oldValue = func(context.Context) (*ActiveInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActiveInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActiveInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActiveInfo entities.
func (m *ActiveInfoMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActiveInfoMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActiveInfoMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActiveInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ActiveInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActiveInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActiveInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActiveInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActiveInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActiveInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActiveInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActiveInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActiveInfoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[activeinfo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActiveInfoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[activeinfo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActiveInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, activeinfo.FieldDeletedAt)
}

// SetProcessID sets the "process_id" field.
func (m *ActiveInfoMutation) SetProcessID(s string) {
	m.process_id = &s
}

// ProcessID returns the value of the "process_id" field in the mutation.
func (m *ActiveInfoMutation) ProcessID() (r string, exists bool) {
	v := m.process_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessID returns the old "process_id" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldProcessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessID: %w", err)
	}
	return oldValue.ProcessID, nil
}

// ResetProcessID resets all changes to the "process_id" field.
func (m *ActiveInfoMutation) ResetProcessID() {
	m.process_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *ActiveInfoMutation) SetStartTime(s string) {
	m.start_time = &s
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ActiveInfoMutation) StartTime() (r string, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ActiveInfoMutation) ResetStartTime() {
	m.start_time = nil
}

// SetResult sets the "result" field.
func (m *ActiveInfoMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *ActiveInfoMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *ActiveInfoMutation) ResetResult() {
	m.result = nil
}

// SetMsg sets the "msg" field.
func (m *ActiveInfoMutation) SetMsg(s string) {
	m.msg = &s
}

// Msg returns the value of the "msg" field in the mutation.
func (m *ActiveInfoMutation) Msg() (r string, exists bool) {
	v := m.msg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsg returns the old "msg" field's value of the ActiveInfo entity.
// If the ActiveInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveInfoMutation) OldMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsg: %w", err)
	}
	return oldValue.Msg, nil
}

// ResetMsg resets all changes to the "msg" field.
func (m *ActiveInfoMutation) ResetMsg() {
	m.msg = nil
}

// Where appends a list predicates to the ActiveInfoMutation builder.
func (m *ActiveInfoMutation) Where(ps ...predicate.ActiveInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActiveInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActiveInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActiveInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActiveInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActiveInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActiveInfo).
func (m *ActiveInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActiveInfoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, activeinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activeinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, activeinfo.FieldDeletedAt)
	}
	if m.process_id != nil {
		fields = append(fields, activeinfo.FieldProcessID)
	}
	if m.start_time != nil {
		fields = append(fields, activeinfo.FieldStartTime)
	}
	if m.result != nil {
		fields = append(fields, activeinfo.FieldResult)
	}
	if m.msg != nil {
		fields = append(fields, activeinfo.FieldMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActiveInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activeinfo.FieldCreatedAt:
		return m.CreatedAt()
	case activeinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case activeinfo.FieldDeletedAt:
		return m.DeletedAt()
	case activeinfo.FieldProcessID:
		return m.ProcessID()
	case activeinfo.FieldStartTime:
		return m.StartTime()
	case activeinfo.FieldResult:
		return m.Result()
	case activeinfo.FieldMsg:
		return m.Msg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActiveInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activeinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activeinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activeinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case activeinfo.FieldProcessID:
		return m.OldProcessID(ctx)
	case activeinfo.FieldStartTime:
		return m.OldStartTime(ctx)
	case activeinfo.FieldResult:
		return m.OldResult(ctx)
	case activeinfo.FieldMsg:
		return m.OldMsg(ctx)
	}
	return nil, fmt.Errorf("unknown ActiveInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActiveInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activeinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activeinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activeinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case activeinfo.FieldProcessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessID(v)
		return nil
	case activeinfo.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case activeinfo.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case activeinfo.FieldMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsg(v)
		return nil
	}
	return fmt.Errorf("unknown ActiveInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActiveInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActiveInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActiveInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActiveInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActiveInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activeinfo.FieldDeletedAt) {
		fields = append(fields, activeinfo.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActiveInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActiveInfoMutation) ClearField(name string) error {
	switch name {
	case activeinfo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ActiveInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActiveInfoMutation) ResetField(name string) error {
	switch name {
	case activeinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activeinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activeinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case activeinfo.FieldProcessID:
		m.ResetProcessID()
		return nil
	case activeinfo.FieldStartTime:
		m.ResetStartTime()
		return nil
	case activeinfo.FieldResult:
		m.ResetResult()
		return nil
	case activeinfo.FieldMsg:
		m.ResetMsg()
		return nil
	}
	return fmt.Errorf("unknown ActiveInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActiveInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActiveInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActiveInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActiveInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActiveInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActiveInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActiveInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ActiveInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActiveInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ActiveInfo edge %s", name)
}

// AlgorithmMutation represents an operation that mutates the Algorithm nodes in the graph.
type AlgorithmMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	_type              *string
	description        *string
	version            *string
	app_name           *string
	alarm_type         *string
	alarm_name         *string
	notify             *uint
	addnotify          *int
	extend             *map[string]interface{}
	draw_type          *uint
	adddraw_type       *int
	base_type          *uint
	addbase_type       *int
	available          *uint
	addavailable       *int
	image              *string
	label_map          *string
	target             *string
	algo_name_en       *string
	algo_group_id      *uint
	addalgo_group_id   *int
	algo_group_name    *string
	algo_group_version *string
	_config            *string
	provider           *string
	algo_id            *string
	platform           *string
	device_model       *string
	is_group_type      *uint
	addis_group_type   *int
	prefix             *string
	clearedFields      map[string]struct{}
	tasks              map[uint64]struct{}
	removedtasks       map[uint64]struct{}
	clearedtasks       bool
	done               bool
	oldValue           func(context.Context) (*Algorithm, error)
	predicates         []predicate.Algorithm
}

var _ ent.Mutation = (*AlgorithmMutation)(nil)

// algorithmOption allows management of the mutation configuration using functional options.
type algorithmOption func(*AlgorithmMutation)

// newAlgorithmMutation creates new mutation for the Algorithm entity.
func newAlgorithmMutation(c config, op Op, opts ...algorithmOption) *AlgorithmMutation {
	m := &AlgorithmMutation{
		config:        c,
		op:            op,
		typ:           TypeAlgorithm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlgorithmID sets the ID field of the mutation.
func withAlgorithmID(id uint64) algorithmOption {
	return func(m *AlgorithmMutation) {
		var (
			err   error
			once  sync.Once
			value *Algorithm
		)
		m.oldValue = func(ctx context.Context) (*Algorithm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Algorithm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlgorithm sets the old Algorithm of the mutation.
func withAlgorithm(node *Algorithm) algorithmOption {
	return func(m *AlgorithmMutation) {
		m.oldValue = func(context.Context) (*Algorithm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlgorithmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlgorithmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Algorithm entities.
func (m *AlgorithmMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlgorithmMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlgorithmMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Algorithm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlgorithmMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlgorithmMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlgorithmMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlgorithmMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlgorithmMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlgorithmMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlgorithmMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlgorithmMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlgorithmMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[algorithm.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlgorithmMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlgorithmMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, algorithm.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AlgorithmMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlgorithmMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlgorithmMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AlgorithmMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AlgorithmMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AlgorithmMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *AlgorithmMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlgorithmMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AlgorithmMutation) ResetDescription() {
	m.description = nil
}

// SetVersion sets the "version" field.
func (m *AlgorithmMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AlgorithmMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AlgorithmMutation) ResetVersion() {
	m.version = nil
}

// SetAppName sets the "app_name" field.
func (m *AlgorithmMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *AlgorithmMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *AlgorithmMutation) ResetAppName() {
	m.app_name = nil
}

// SetAlarmType sets the "alarm_type" field.
func (m *AlgorithmMutation) SetAlarmType(s string) {
	m.alarm_type = &s
}

// AlarmType returns the value of the "alarm_type" field in the mutation.
func (m *AlgorithmMutation) AlarmType() (r string, exists bool) {
	v := m.alarm_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmType returns the old "alarm_type" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlarmType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmType: %w", err)
	}
	return oldValue.AlarmType, nil
}

// ResetAlarmType resets all changes to the "alarm_type" field.
func (m *AlgorithmMutation) ResetAlarmType() {
	m.alarm_type = nil
}

// SetAlarmName sets the "alarm_name" field.
func (m *AlgorithmMutation) SetAlarmName(s string) {
	m.alarm_name = &s
}

// AlarmName returns the value of the "alarm_name" field in the mutation.
func (m *AlgorithmMutation) AlarmName() (r string, exists bool) {
	v := m.alarm_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmName returns the old "alarm_name" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmName: %w", err)
	}
	return oldValue.AlarmName, nil
}

// ResetAlarmName resets all changes to the "alarm_name" field.
func (m *AlgorithmMutation) ResetAlarmName() {
	m.alarm_name = nil
}

// SetNotify sets the "notify" field.
func (m *AlgorithmMutation) SetNotify(u uint) {
	m.notify = &u
	m.addnotify = nil
}

// Notify returns the value of the "notify" field in the mutation.
func (m *AlgorithmMutation) Notify() (r uint, exists bool) {
	v := m.notify
	if v == nil {
		return
	}
	return *v, true
}

// OldNotify returns the old "notify" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldNotify(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotify: %w", err)
	}
	return oldValue.Notify, nil
}

// AddNotify adds u to the "notify" field.
func (m *AlgorithmMutation) AddNotify(u int) {
	if m.addnotify != nil {
		*m.addnotify += u
	} else {
		m.addnotify = &u
	}
}

// AddedNotify returns the value that was added to the "notify" field in this mutation.
func (m *AlgorithmMutation) AddedNotify() (r int, exists bool) {
	v := m.addnotify
	if v == nil {
		return
	}
	return *v, true
}

// ResetNotify resets all changes to the "notify" field.
func (m *AlgorithmMutation) ResetNotify() {
	m.notify = nil
	m.addnotify = nil
}

// SetExtend sets the "extend" field.
func (m *AlgorithmMutation) SetExtend(value map[string]interface{}) {
	m.extend = &value
}

// Extend returns the value of the "extend" field in the mutation.
func (m *AlgorithmMutation) Extend() (r map[string]interface{}, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldExtend(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *AlgorithmMutation) ResetExtend() {
	m.extend = nil
}

// SetDrawType sets the "draw_type" field.
func (m *AlgorithmMutation) SetDrawType(u uint) {
	m.draw_type = &u
	m.adddraw_type = nil
}

// DrawType returns the value of the "draw_type" field in the mutation.
func (m *AlgorithmMutation) DrawType() (r uint, exists bool) {
	v := m.draw_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDrawType returns the old "draw_type" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldDrawType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrawType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrawType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrawType: %w", err)
	}
	return oldValue.DrawType, nil
}

// AddDrawType adds u to the "draw_type" field.
func (m *AlgorithmMutation) AddDrawType(u int) {
	if m.adddraw_type != nil {
		*m.adddraw_type += u
	} else {
		m.adddraw_type = &u
	}
}

// AddedDrawType returns the value that was added to the "draw_type" field in this mutation.
func (m *AlgorithmMutation) AddedDrawType() (r int, exists bool) {
	v := m.adddraw_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDrawType resets all changes to the "draw_type" field.
func (m *AlgorithmMutation) ResetDrawType() {
	m.draw_type = nil
	m.adddraw_type = nil
}

// SetBaseType sets the "base_type" field.
func (m *AlgorithmMutation) SetBaseType(u uint) {
	m.base_type = &u
	m.addbase_type = nil
}

// BaseType returns the value of the "base_type" field in the mutation.
func (m *AlgorithmMutation) BaseType() (r uint, exists bool) {
	v := m.base_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseType returns the old "base_type" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldBaseType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseType: %w", err)
	}
	return oldValue.BaseType, nil
}

// AddBaseType adds u to the "base_type" field.
func (m *AlgorithmMutation) AddBaseType(u int) {
	if m.addbase_type != nil {
		*m.addbase_type += u
	} else {
		m.addbase_type = &u
	}
}

// AddedBaseType returns the value that was added to the "base_type" field in this mutation.
func (m *AlgorithmMutation) AddedBaseType() (r int, exists bool) {
	v := m.addbase_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseType resets all changes to the "base_type" field.
func (m *AlgorithmMutation) ResetBaseType() {
	m.base_type = nil
	m.addbase_type = nil
}

// SetAvailable sets the "available" field.
func (m *AlgorithmMutation) SetAvailable(u uint) {
	m.available = &u
	m.addavailable = nil
}

// Available returns the value of the "available" field in the mutation.
func (m *AlgorithmMutation) Available() (r uint, exists bool) {
	v := m.available
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailable returns the old "available" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAvailable(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailable: %w", err)
	}
	return oldValue.Available, nil
}

// AddAvailable adds u to the "available" field.
func (m *AlgorithmMutation) AddAvailable(u int) {
	if m.addavailable != nil {
		*m.addavailable += u
	} else {
		m.addavailable = &u
	}
}

// AddedAvailable returns the value that was added to the "available" field in this mutation.
func (m *AlgorithmMutation) AddedAvailable() (r int, exists bool) {
	v := m.addavailable
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailable resets all changes to the "available" field.
func (m *AlgorithmMutation) ResetAvailable() {
	m.available = nil
	m.addavailable = nil
}

// SetImage sets the "image" field.
func (m *AlgorithmMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *AlgorithmMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *AlgorithmMutation) ResetImage() {
	m.image = nil
}

// SetLabelMap sets the "label_map" field.
func (m *AlgorithmMutation) SetLabelMap(s string) {
	m.label_map = &s
}

// LabelMap returns the value of the "label_map" field in the mutation.
func (m *AlgorithmMutation) LabelMap() (r string, exists bool) {
	v := m.label_map
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelMap returns the old "label_map" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldLabelMap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelMap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelMap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelMap: %w", err)
	}
	return oldValue.LabelMap, nil
}

// ClearLabelMap clears the value of the "label_map" field.
func (m *AlgorithmMutation) ClearLabelMap() {
	m.label_map = nil
	m.clearedFields[algorithm.FieldLabelMap] = struct{}{}
}

// LabelMapCleared returns if the "label_map" field was cleared in this mutation.
func (m *AlgorithmMutation) LabelMapCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldLabelMap]
	return ok
}

// ResetLabelMap resets all changes to the "label_map" field.
func (m *AlgorithmMutation) ResetLabelMap() {
	m.label_map = nil
	delete(m.clearedFields, algorithm.FieldLabelMap)
}

// SetTarget sets the "target" field.
func (m *AlgorithmMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the value of the "target" field in the mutation.
func (m *AlgorithmMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old "target" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ClearTarget clears the value of the "target" field.
func (m *AlgorithmMutation) ClearTarget() {
	m.target = nil
	m.clearedFields[algorithm.FieldTarget] = struct{}{}
}

// TargetCleared returns if the "target" field was cleared in this mutation.
func (m *AlgorithmMutation) TargetCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldTarget]
	return ok
}

// ResetTarget resets all changes to the "target" field.
func (m *AlgorithmMutation) ResetTarget() {
	m.target = nil
	delete(m.clearedFields, algorithm.FieldTarget)
}

// SetAlgoNameEn sets the "algo_name_en" field.
func (m *AlgorithmMutation) SetAlgoNameEn(s string) {
	m.algo_name_en = &s
}

// AlgoNameEn returns the value of the "algo_name_en" field in the mutation.
func (m *AlgorithmMutation) AlgoNameEn() (r string, exists bool) {
	v := m.algo_name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoNameEn returns the old "algo_name_en" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlgoNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoNameEn: %w", err)
	}
	return oldValue.AlgoNameEn, nil
}

// ClearAlgoNameEn clears the value of the "algo_name_en" field.
func (m *AlgorithmMutation) ClearAlgoNameEn() {
	m.algo_name_en = nil
	m.clearedFields[algorithm.FieldAlgoNameEn] = struct{}{}
}

// AlgoNameEnCleared returns if the "algo_name_en" field was cleared in this mutation.
func (m *AlgorithmMutation) AlgoNameEnCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldAlgoNameEn]
	return ok
}

// ResetAlgoNameEn resets all changes to the "algo_name_en" field.
func (m *AlgorithmMutation) ResetAlgoNameEn() {
	m.algo_name_en = nil
	delete(m.clearedFields, algorithm.FieldAlgoNameEn)
}

// SetAlgoGroupID sets the "algo_group_id" field.
func (m *AlgorithmMutation) SetAlgoGroupID(u uint) {
	m.algo_group_id = &u
	m.addalgo_group_id = nil
}

// AlgoGroupID returns the value of the "algo_group_id" field in the mutation.
func (m *AlgorithmMutation) AlgoGroupID() (r uint, exists bool) {
	v := m.algo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupID returns the old "algo_group_id" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlgoGroupID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupID: %w", err)
	}
	return oldValue.AlgoGroupID, nil
}

// AddAlgoGroupID adds u to the "algo_group_id" field.
func (m *AlgorithmMutation) AddAlgoGroupID(u int) {
	if m.addalgo_group_id != nil {
		*m.addalgo_group_id += u
	} else {
		m.addalgo_group_id = &u
	}
}

// AddedAlgoGroupID returns the value that was added to the "algo_group_id" field in this mutation.
func (m *AlgorithmMutation) AddedAlgoGroupID() (r int, exists bool) {
	v := m.addalgo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAlgoGroupID clears the value of the "algo_group_id" field.
func (m *AlgorithmMutation) ClearAlgoGroupID() {
	m.algo_group_id = nil
	m.addalgo_group_id = nil
	m.clearedFields[algorithm.FieldAlgoGroupID] = struct{}{}
}

// AlgoGroupIDCleared returns if the "algo_group_id" field was cleared in this mutation.
func (m *AlgorithmMutation) AlgoGroupIDCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldAlgoGroupID]
	return ok
}

// ResetAlgoGroupID resets all changes to the "algo_group_id" field.
func (m *AlgorithmMutation) ResetAlgoGroupID() {
	m.algo_group_id = nil
	m.addalgo_group_id = nil
	delete(m.clearedFields, algorithm.FieldAlgoGroupID)
}

// SetAlgoGroupName sets the "algo_group_name" field.
func (m *AlgorithmMutation) SetAlgoGroupName(s string) {
	m.algo_group_name = &s
}

// AlgoGroupName returns the value of the "algo_group_name" field in the mutation.
func (m *AlgorithmMutation) AlgoGroupName() (r string, exists bool) {
	v := m.algo_group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupName returns the old "algo_group_name" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlgoGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupName: %w", err)
	}
	return oldValue.AlgoGroupName, nil
}

// ClearAlgoGroupName clears the value of the "algo_group_name" field.
func (m *AlgorithmMutation) ClearAlgoGroupName() {
	m.algo_group_name = nil
	m.clearedFields[algorithm.FieldAlgoGroupName] = struct{}{}
}

// AlgoGroupNameCleared returns if the "algo_group_name" field was cleared in this mutation.
func (m *AlgorithmMutation) AlgoGroupNameCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldAlgoGroupName]
	return ok
}

// ResetAlgoGroupName resets all changes to the "algo_group_name" field.
func (m *AlgorithmMutation) ResetAlgoGroupName() {
	m.algo_group_name = nil
	delete(m.clearedFields, algorithm.FieldAlgoGroupName)
}

// SetAlgoGroupVersion sets the "algo_group_version" field.
func (m *AlgorithmMutation) SetAlgoGroupVersion(s string) {
	m.algo_group_version = &s
}

// AlgoGroupVersion returns the value of the "algo_group_version" field in the mutation.
func (m *AlgorithmMutation) AlgoGroupVersion() (r string, exists bool) {
	v := m.algo_group_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupVersion returns the old "algo_group_version" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlgoGroupVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupVersion: %w", err)
	}
	return oldValue.AlgoGroupVersion, nil
}

// ClearAlgoGroupVersion clears the value of the "algo_group_version" field.
func (m *AlgorithmMutation) ClearAlgoGroupVersion() {
	m.algo_group_version = nil
	m.clearedFields[algorithm.FieldAlgoGroupVersion] = struct{}{}
}

// AlgoGroupVersionCleared returns if the "algo_group_version" field was cleared in this mutation.
func (m *AlgorithmMutation) AlgoGroupVersionCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldAlgoGroupVersion]
	return ok
}

// ResetAlgoGroupVersion resets all changes to the "algo_group_version" field.
func (m *AlgorithmMutation) ResetAlgoGroupVersion() {
	m.algo_group_version = nil
	delete(m.clearedFields, algorithm.FieldAlgoGroupVersion)
}

// SetConfig sets the "config" field.
func (m *AlgorithmMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *AlgorithmMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *AlgorithmMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[algorithm.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *AlgorithmMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *AlgorithmMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, algorithm.FieldConfig)
}

// SetProvider sets the "provider" field.
func (m *AlgorithmMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *AlgorithmMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *AlgorithmMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[algorithm.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *AlgorithmMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *AlgorithmMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, algorithm.FieldProvider)
}

// SetAlgoID sets the "algo_id" field.
func (m *AlgorithmMutation) SetAlgoID(s string) {
	m.algo_id = &s
}

// AlgoID returns the value of the "algo_id" field in the mutation.
func (m *AlgorithmMutation) AlgoID() (r string, exists bool) {
	v := m.algo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoID returns the old "algo_id" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldAlgoID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoID: %w", err)
	}
	return oldValue.AlgoID, nil
}

// ClearAlgoID clears the value of the "algo_id" field.
func (m *AlgorithmMutation) ClearAlgoID() {
	m.algo_id = nil
	m.clearedFields[algorithm.FieldAlgoID] = struct{}{}
}

// AlgoIDCleared returns if the "algo_id" field was cleared in this mutation.
func (m *AlgorithmMutation) AlgoIDCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldAlgoID]
	return ok
}

// ResetAlgoID resets all changes to the "algo_id" field.
func (m *AlgorithmMutation) ResetAlgoID() {
	m.algo_id = nil
	delete(m.clearedFields, algorithm.FieldAlgoID)
}

// SetPlatform sets the "platform" field.
func (m *AlgorithmMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AlgorithmMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *AlgorithmMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[algorithm.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *AlgorithmMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AlgorithmMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, algorithm.FieldPlatform)
}

// SetDeviceModel sets the "device_model" field.
func (m *AlgorithmMutation) SetDeviceModel(s string) {
	m.device_model = &s
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *AlgorithmMutation) DeviceModel() (r string, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldDeviceModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// ClearDeviceModel clears the value of the "device_model" field.
func (m *AlgorithmMutation) ClearDeviceModel() {
	m.device_model = nil
	m.clearedFields[algorithm.FieldDeviceModel] = struct{}{}
}

// DeviceModelCleared returns if the "device_model" field was cleared in this mutation.
func (m *AlgorithmMutation) DeviceModelCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldDeviceModel]
	return ok
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *AlgorithmMutation) ResetDeviceModel() {
	m.device_model = nil
	delete(m.clearedFields, algorithm.FieldDeviceModel)
}

// SetIsGroupType sets the "is_group_type" field.
func (m *AlgorithmMutation) SetIsGroupType(u uint) {
	m.is_group_type = &u
	m.addis_group_type = nil
}

// IsGroupType returns the value of the "is_group_type" field in the mutation.
func (m *AlgorithmMutation) IsGroupType() (r uint, exists bool) {
	v := m.is_group_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGroupType returns the old "is_group_type" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldIsGroupType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGroupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGroupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGroupType: %w", err)
	}
	return oldValue.IsGroupType, nil
}

// AddIsGroupType adds u to the "is_group_type" field.
func (m *AlgorithmMutation) AddIsGroupType(u int) {
	if m.addis_group_type != nil {
		*m.addis_group_type += u
	} else {
		m.addis_group_type = &u
	}
}

// AddedIsGroupType returns the value that was added to the "is_group_type" field in this mutation.
func (m *AlgorithmMutation) AddedIsGroupType() (r int, exists bool) {
	v := m.addis_group_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsGroupType clears the value of the "is_group_type" field.
func (m *AlgorithmMutation) ClearIsGroupType() {
	m.is_group_type = nil
	m.addis_group_type = nil
	m.clearedFields[algorithm.FieldIsGroupType] = struct{}{}
}

// IsGroupTypeCleared returns if the "is_group_type" field was cleared in this mutation.
func (m *AlgorithmMutation) IsGroupTypeCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldIsGroupType]
	return ok
}

// ResetIsGroupType resets all changes to the "is_group_type" field.
func (m *AlgorithmMutation) ResetIsGroupType() {
	m.is_group_type = nil
	m.addis_group_type = nil
	delete(m.clearedFields, algorithm.FieldIsGroupType)
}

// SetPrefix sets the "prefix" field.
func (m *AlgorithmMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *AlgorithmMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the Algorithm entity.
// If the Algorithm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ClearPrefix clears the value of the "prefix" field.
func (m *AlgorithmMutation) ClearPrefix() {
	m.prefix = nil
	m.clearedFields[algorithm.FieldPrefix] = struct{}{}
}

// PrefixCleared returns if the "prefix" field was cleared in this mutation.
func (m *AlgorithmMutation) PrefixCleared() bool {
	_, ok := m.clearedFields[algorithm.FieldPrefix]
	return ok
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *AlgorithmMutation) ResetPrefix() {
	m.prefix = nil
	delete(m.clearedFields, algorithm.FieldPrefix)
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *AlgorithmMutation) AddTaskIDs(ids ...uint64) {
	if m.tasks == nil {
		m.tasks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *AlgorithmMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *AlgorithmMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *AlgorithmMutation) RemoveTaskIDs(ids ...uint64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *AlgorithmMutation) RemovedTasksIDs() (ids []uint64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *AlgorithmMutation) TasksIDs() (ids []uint64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *AlgorithmMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the AlgorithmMutation builder.
func (m *AlgorithmMutation) Where(ps ...predicate.Algorithm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlgorithmMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlgorithmMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Algorithm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlgorithmMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlgorithmMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Algorithm).
func (m *AlgorithmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlgorithmMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, algorithm.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, algorithm.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, algorithm.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, algorithm.FieldName)
	}
	if m._type != nil {
		fields = append(fields, algorithm.FieldType)
	}
	if m.description != nil {
		fields = append(fields, algorithm.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, algorithm.FieldVersion)
	}
	if m.app_name != nil {
		fields = append(fields, algorithm.FieldAppName)
	}
	if m.alarm_type != nil {
		fields = append(fields, algorithm.FieldAlarmType)
	}
	if m.alarm_name != nil {
		fields = append(fields, algorithm.FieldAlarmName)
	}
	if m.notify != nil {
		fields = append(fields, algorithm.FieldNotify)
	}
	if m.extend != nil {
		fields = append(fields, algorithm.FieldExtend)
	}
	if m.draw_type != nil {
		fields = append(fields, algorithm.FieldDrawType)
	}
	if m.base_type != nil {
		fields = append(fields, algorithm.FieldBaseType)
	}
	if m.available != nil {
		fields = append(fields, algorithm.FieldAvailable)
	}
	if m.image != nil {
		fields = append(fields, algorithm.FieldImage)
	}
	if m.label_map != nil {
		fields = append(fields, algorithm.FieldLabelMap)
	}
	if m.target != nil {
		fields = append(fields, algorithm.FieldTarget)
	}
	if m.algo_name_en != nil {
		fields = append(fields, algorithm.FieldAlgoNameEn)
	}
	if m.algo_group_id != nil {
		fields = append(fields, algorithm.FieldAlgoGroupID)
	}
	if m.algo_group_name != nil {
		fields = append(fields, algorithm.FieldAlgoGroupName)
	}
	if m.algo_group_version != nil {
		fields = append(fields, algorithm.FieldAlgoGroupVersion)
	}
	if m._config != nil {
		fields = append(fields, algorithm.FieldConfig)
	}
	if m.provider != nil {
		fields = append(fields, algorithm.FieldProvider)
	}
	if m.algo_id != nil {
		fields = append(fields, algorithm.FieldAlgoID)
	}
	if m.platform != nil {
		fields = append(fields, algorithm.FieldPlatform)
	}
	if m.device_model != nil {
		fields = append(fields, algorithm.FieldDeviceModel)
	}
	if m.is_group_type != nil {
		fields = append(fields, algorithm.FieldIsGroupType)
	}
	if m.prefix != nil {
		fields = append(fields, algorithm.FieldPrefix)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlgorithmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case algorithm.FieldCreatedAt:
		return m.CreatedAt()
	case algorithm.FieldUpdatedAt:
		return m.UpdatedAt()
	case algorithm.FieldDeletedAt:
		return m.DeletedAt()
	case algorithm.FieldName:
		return m.Name()
	case algorithm.FieldType:
		return m.GetType()
	case algorithm.FieldDescription:
		return m.Description()
	case algorithm.FieldVersion:
		return m.Version()
	case algorithm.FieldAppName:
		return m.AppName()
	case algorithm.FieldAlarmType:
		return m.AlarmType()
	case algorithm.FieldAlarmName:
		return m.AlarmName()
	case algorithm.FieldNotify:
		return m.Notify()
	case algorithm.FieldExtend:
		return m.Extend()
	case algorithm.FieldDrawType:
		return m.DrawType()
	case algorithm.FieldBaseType:
		return m.BaseType()
	case algorithm.FieldAvailable:
		return m.Available()
	case algorithm.FieldImage:
		return m.Image()
	case algorithm.FieldLabelMap:
		return m.LabelMap()
	case algorithm.FieldTarget:
		return m.Target()
	case algorithm.FieldAlgoNameEn:
		return m.AlgoNameEn()
	case algorithm.FieldAlgoGroupID:
		return m.AlgoGroupID()
	case algorithm.FieldAlgoGroupName:
		return m.AlgoGroupName()
	case algorithm.FieldAlgoGroupVersion:
		return m.AlgoGroupVersion()
	case algorithm.FieldConfig:
		return m.Config()
	case algorithm.FieldProvider:
		return m.Provider()
	case algorithm.FieldAlgoID:
		return m.AlgoID()
	case algorithm.FieldPlatform:
		return m.Platform()
	case algorithm.FieldDeviceModel:
		return m.DeviceModel()
	case algorithm.FieldIsGroupType:
		return m.IsGroupType()
	case algorithm.FieldPrefix:
		return m.Prefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlgorithmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case algorithm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case algorithm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case algorithm.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case algorithm.FieldName:
		return m.OldName(ctx)
	case algorithm.FieldType:
		return m.OldType(ctx)
	case algorithm.FieldDescription:
		return m.OldDescription(ctx)
	case algorithm.FieldVersion:
		return m.OldVersion(ctx)
	case algorithm.FieldAppName:
		return m.OldAppName(ctx)
	case algorithm.FieldAlarmType:
		return m.OldAlarmType(ctx)
	case algorithm.FieldAlarmName:
		return m.OldAlarmName(ctx)
	case algorithm.FieldNotify:
		return m.OldNotify(ctx)
	case algorithm.FieldExtend:
		return m.OldExtend(ctx)
	case algorithm.FieldDrawType:
		return m.OldDrawType(ctx)
	case algorithm.FieldBaseType:
		return m.OldBaseType(ctx)
	case algorithm.FieldAvailable:
		return m.OldAvailable(ctx)
	case algorithm.FieldImage:
		return m.OldImage(ctx)
	case algorithm.FieldLabelMap:
		return m.OldLabelMap(ctx)
	case algorithm.FieldTarget:
		return m.OldTarget(ctx)
	case algorithm.FieldAlgoNameEn:
		return m.OldAlgoNameEn(ctx)
	case algorithm.FieldAlgoGroupID:
		return m.OldAlgoGroupID(ctx)
	case algorithm.FieldAlgoGroupName:
		return m.OldAlgoGroupName(ctx)
	case algorithm.FieldAlgoGroupVersion:
		return m.OldAlgoGroupVersion(ctx)
	case algorithm.FieldConfig:
		return m.OldConfig(ctx)
	case algorithm.FieldProvider:
		return m.OldProvider(ctx)
	case algorithm.FieldAlgoID:
		return m.OldAlgoID(ctx)
	case algorithm.FieldPlatform:
		return m.OldPlatform(ctx)
	case algorithm.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case algorithm.FieldIsGroupType:
		return m.OldIsGroupType(ctx)
	case algorithm.FieldPrefix:
		return m.OldPrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Algorithm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlgorithmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case algorithm.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case algorithm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case algorithm.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case algorithm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case algorithm.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case algorithm.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case algorithm.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case algorithm.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case algorithm.FieldAlarmType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmType(v)
		return nil
	case algorithm.FieldAlarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmName(v)
		return nil
	case algorithm.FieldNotify:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotify(v)
		return nil
	case algorithm.FieldExtend:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	case algorithm.FieldDrawType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrawType(v)
		return nil
	case algorithm.FieldBaseType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseType(v)
		return nil
	case algorithm.FieldAvailable:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailable(v)
		return nil
	case algorithm.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case algorithm.FieldLabelMap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelMap(v)
		return nil
	case algorithm.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case algorithm.FieldAlgoNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoNameEn(v)
		return nil
	case algorithm.FieldAlgoGroupID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupID(v)
		return nil
	case algorithm.FieldAlgoGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupName(v)
		return nil
	case algorithm.FieldAlgoGroupVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupVersion(v)
		return nil
	case algorithm.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case algorithm.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case algorithm.FieldAlgoID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoID(v)
		return nil
	case algorithm.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case algorithm.FieldDeviceModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case algorithm.FieldIsGroupType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGroupType(v)
		return nil
	case algorithm.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Algorithm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlgorithmMutation) AddedFields() []string {
	var fields []string
	if m.addnotify != nil {
		fields = append(fields, algorithm.FieldNotify)
	}
	if m.adddraw_type != nil {
		fields = append(fields, algorithm.FieldDrawType)
	}
	if m.addbase_type != nil {
		fields = append(fields, algorithm.FieldBaseType)
	}
	if m.addavailable != nil {
		fields = append(fields, algorithm.FieldAvailable)
	}
	if m.addalgo_group_id != nil {
		fields = append(fields, algorithm.FieldAlgoGroupID)
	}
	if m.addis_group_type != nil {
		fields = append(fields, algorithm.FieldIsGroupType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlgorithmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case algorithm.FieldNotify:
		return m.AddedNotify()
	case algorithm.FieldDrawType:
		return m.AddedDrawType()
	case algorithm.FieldBaseType:
		return m.AddedBaseType()
	case algorithm.FieldAvailable:
		return m.AddedAvailable()
	case algorithm.FieldAlgoGroupID:
		return m.AddedAlgoGroupID()
	case algorithm.FieldIsGroupType:
		return m.AddedIsGroupType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlgorithmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case algorithm.FieldNotify:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotify(v)
		return nil
	case algorithm.FieldDrawType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDrawType(v)
		return nil
	case algorithm.FieldBaseType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseType(v)
		return nil
	case algorithm.FieldAvailable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailable(v)
		return nil
	case algorithm.FieldAlgoGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlgoGroupID(v)
		return nil
	case algorithm.FieldIsGroupType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGroupType(v)
		return nil
	}
	return fmt.Errorf("unknown Algorithm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlgorithmMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(algorithm.FieldDeletedAt) {
		fields = append(fields, algorithm.FieldDeletedAt)
	}
	if m.FieldCleared(algorithm.FieldLabelMap) {
		fields = append(fields, algorithm.FieldLabelMap)
	}
	if m.FieldCleared(algorithm.FieldTarget) {
		fields = append(fields, algorithm.FieldTarget)
	}
	if m.FieldCleared(algorithm.FieldAlgoNameEn) {
		fields = append(fields, algorithm.FieldAlgoNameEn)
	}
	if m.FieldCleared(algorithm.FieldAlgoGroupID) {
		fields = append(fields, algorithm.FieldAlgoGroupID)
	}
	if m.FieldCleared(algorithm.FieldAlgoGroupName) {
		fields = append(fields, algorithm.FieldAlgoGroupName)
	}
	if m.FieldCleared(algorithm.FieldAlgoGroupVersion) {
		fields = append(fields, algorithm.FieldAlgoGroupVersion)
	}
	if m.FieldCleared(algorithm.FieldConfig) {
		fields = append(fields, algorithm.FieldConfig)
	}
	if m.FieldCleared(algorithm.FieldProvider) {
		fields = append(fields, algorithm.FieldProvider)
	}
	if m.FieldCleared(algorithm.FieldAlgoID) {
		fields = append(fields, algorithm.FieldAlgoID)
	}
	if m.FieldCleared(algorithm.FieldPlatform) {
		fields = append(fields, algorithm.FieldPlatform)
	}
	if m.FieldCleared(algorithm.FieldDeviceModel) {
		fields = append(fields, algorithm.FieldDeviceModel)
	}
	if m.FieldCleared(algorithm.FieldIsGroupType) {
		fields = append(fields, algorithm.FieldIsGroupType)
	}
	if m.FieldCleared(algorithm.FieldPrefix) {
		fields = append(fields, algorithm.FieldPrefix)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlgorithmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlgorithmMutation) ClearField(name string) error {
	switch name {
	case algorithm.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case algorithm.FieldLabelMap:
		m.ClearLabelMap()
		return nil
	case algorithm.FieldTarget:
		m.ClearTarget()
		return nil
	case algorithm.FieldAlgoNameEn:
		m.ClearAlgoNameEn()
		return nil
	case algorithm.FieldAlgoGroupID:
		m.ClearAlgoGroupID()
		return nil
	case algorithm.FieldAlgoGroupName:
		m.ClearAlgoGroupName()
		return nil
	case algorithm.FieldAlgoGroupVersion:
		m.ClearAlgoGroupVersion()
		return nil
	case algorithm.FieldConfig:
		m.ClearConfig()
		return nil
	case algorithm.FieldProvider:
		m.ClearProvider()
		return nil
	case algorithm.FieldAlgoID:
		m.ClearAlgoID()
		return nil
	case algorithm.FieldPlatform:
		m.ClearPlatform()
		return nil
	case algorithm.FieldDeviceModel:
		m.ClearDeviceModel()
		return nil
	case algorithm.FieldIsGroupType:
		m.ClearIsGroupType()
		return nil
	case algorithm.FieldPrefix:
		m.ClearPrefix()
		return nil
	}
	return fmt.Errorf("unknown Algorithm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlgorithmMutation) ResetField(name string) error {
	switch name {
	case algorithm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case algorithm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case algorithm.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case algorithm.FieldName:
		m.ResetName()
		return nil
	case algorithm.FieldType:
		m.ResetType()
		return nil
	case algorithm.FieldDescription:
		m.ResetDescription()
		return nil
	case algorithm.FieldVersion:
		m.ResetVersion()
		return nil
	case algorithm.FieldAppName:
		m.ResetAppName()
		return nil
	case algorithm.FieldAlarmType:
		m.ResetAlarmType()
		return nil
	case algorithm.FieldAlarmName:
		m.ResetAlarmName()
		return nil
	case algorithm.FieldNotify:
		m.ResetNotify()
		return nil
	case algorithm.FieldExtend:
		m.ResetExtend()
		return nil
	case algorithm.FieldDrawType:
		m.ResetDrawType()
		return nil
	case algorithm.FieldBaseType:
		m.ResetBaseType()
		return nil
	case algorithm.FieldAvailable:
		m.ResetAvailable()
		return nil
	case algorithm.FieldImage:
		m.ResetImage()
		return nil
	case algorithm.FieldLabelMap:
		m.ResetLabelMap()
		return nil
	case algorithm.FieldTarget:
		m.ResetTarget()
		return nil
	case algorithm.FieldAlgoNameEn:
		m.ResetAlgoNameEn()
		return nil
	case algorithm.FieldAlgoGroupID:
		m.ResetAlgoGroupID()
		return nil
	case algorithm.FieldAlgoGroupName:
		m.ResetAlgoGroupName()
		return nil
	case algorithm.FieldAlgoGroupVersion:
		m.ResetAlgoGroupVersion()
		return nil
	case algorithm.FieldConfig:
		m.ResetConfig()
		return nil
	case algorithm.FieldProvider:
		m.ResetProvider()
		return nil
	case algorithm.FieldAlgoID:
		m.ResetAlgoID()
		return nil
	case algorithm.FieldPlatform:
		m.ResetPlatform()
		return nil
	case algorithm.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case algorithm.FieldIsGroupType:
		m.ResetIsGroupType()
		return nil
	case algorithm.FieldPrefix:
		m.ResetPrefix()
		return nil
	}
	return fmt.Errorf("unknown Algorithm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlgorithmMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tasks != nil {
		edges = append(edges, algorithm.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlgorithmMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case algorithm.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlgorithmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtasks != nil {
		edges = append(edges, algorithm.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlgorithmMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case algorithm.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlgorithmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtasks {
		edges = append(edges, algorithm.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlgorithmMutation) EdgeCleared(name string) bool {
	switch name {
	case algorithm.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlgorithmMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Algorithm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlgorithmMutation) ResetEdge(name string) error {
	switch name {
	case algorithm.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Algorithm edge %s", name)
}

// AlgorithmAlarmTypeMutation represents an operation that mutates the AlgorithmAlarmType nodes in the graph.
type AlgorithmAlarmTypeMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	type_name     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AlgorithmAlarmType, error)
	predicates    []predicate.AlgorithmAlarmType
}

var _ ent.Mutation = (*AlgorithmAlarmTypeMutation)(nil)

// algorithmalarmtypeOption allows management of the mutation configuration using functional options.
type algorithmalarmtypeOption func(*AlgorithmAlarmTypeMutation)

// newAlgorithmAlarmTypeMutation creates new mutation for the AlgorithmAlarmType entity.
func newAlgorithmAlarmTypeMutation(c config, op Op, opts ...algorithmalarmtypeOption) *AlgorithmAlarmTypeMutation {
	m := &AlgorithmAlarmTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAlgorithmAlarmType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlgorithmAlarmTypeID sets the ID field of the mutation.
func withAlgorithmAlarmTypeID(id uint64) algorithmalarmtypeOption {
	return func(m *AlgorithmAlarmTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AlgorithmAlarmType
		)
		m.oldValue = func(ctx context.Context) (*AlgorithmAlarmType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlgorithmAlarmType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlgorithmAlarmType sets the old AlgorithmAlarmType of the mutation.
func withAlgorithmAlarmType(node *AlgorithmAlarmType) algorithmalarmtypeOption {
	return func(m *AlgorithmAlarmTypeMutation) {
		m.oldValue = func(context.Context) (*AlgorithmAlarmType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlgorithmAlarmTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlgorithmAlarmTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlgorithmAlarmType entities.
func (m *AlgorithmAlarmTypeMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlgorithmAlarmTypeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlgorithmAlarmTypeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlgorithmAlarmType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlgorithmAlarmTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlgorithmAlarmTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlgorithmAlarmType entity.
// If the AlgorithmAlarmType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmAlarmTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlgorithmAlarmTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlgorithmAlarmTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlgorithmAlarmTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlgorithmAlarmType entity.
// If the AlgorithmAlarmType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmAlarmTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlgorithmAlarmTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlgorithmAlarmTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlgorithmAlarmTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AlgorithmAlarmType entity.
// If the AlgorithmAlarmType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmAlarmTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlgorithmAlarmTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[algorithmalarmtype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlgorithmAlarmTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[algorithmalarmtype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlgorithmAlarmTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, algorithmalarmtype.FieldDeletedAt)
}

// SetTypeName sets the "type_name" field.
func (m *AlgorithmAlarmTypeMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *AlgorithmAlarmTypeMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the AlgorithmAlarmType entity.
// If the AlgorithmAlarmType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlgorithmAlarmTypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *AlgorithmAlarmTypeMutation) ResetTypeName() {
	m.type_name = nil
}

// Where appends a list predicates to the AlgorithmAlarmTypeMutation builder.
func (m *AlgorithmAlarmTypeMutation) Where(ps ...predicate.AlgorithmAlarmType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlgorithmAlarmTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlgorithmAlarmTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlgorithmAlarmType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlgorithmAlarmTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlgorithmAlarmTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlgorithmAlarmType).
func (m *AlgorithmAlarmTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlgorithmAlarmTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, algorithmalarmtype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, algorithmalarmtype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, algorithmalarmtype.FieldDeletedAt)
	}
	if m.type_name != nil {
		fields = append(fields, algorithmalarmtype.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlgorithmAlarmTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case algorithmalarmtype.FieldCreatedAt:
		return m.CreatedAt()
	case algorithmalarmtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case algorithmalarmtype.FieldDeletedAt:
		return m.DeletedAt()
	case algorithmalarmtype.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlgorithmAlarmTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case algorithmalarmtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case algorithmalarmtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case algorithmalarmtype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case algorithmalarmtype.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown AlgorithmAlarmType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlgorithmAlarmTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case algorithmalarmtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case algorithmalarmtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case algorithmalarmtype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case algorithmalarmtype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown AlgorithmAlarmType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlgorithmAlarmTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlgorithmAlarmTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlgorithmAlarmTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlgorithmAlarmType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlgorithmAlarmTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(algorithmalarmtype.FieldDeletedAt) {
		fields = append(fields, algorithmalarmtype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlgorithmAlarmTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlgorithmAlarmTypeMutation) ClearField(name string) error {
	switch name {
	case algorithmalarmtype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AlgorithmAlarmType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlgorithmAlarmTypeMutation) ResetField(name string) error {
	switch name {
	case algorithmalarmtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case algorithmalarmtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case algorithmalarmtype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case algorithmalarmtype.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown AlgorithmAlarmType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlgorithmAlarmTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlgorithmAlarmTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlgorithmAlarmTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlgorithmAlarmTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlgorithmAlarmTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlgorithmAlarmTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlgorithmAlarmTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlgorithmAlarmType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlgorithmAlarmTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlgorithmAlarmType edge %s", name)
}

// AreaMutation represents an operation that mutates the Area nodes in the graph.
type AreaMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	name          *string
	level         *uint64
	addlevel      *int64
	pid           *int64
	addpid        *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Area, error)
	predicates    []predicate.Area
}

var _ ent.Mutation = (*AreaMutation)(nil)

// areaOption allows management of the mutation configuration using functional options.
type areaOption func(*AreaMutation)

// newAreaMutation creates new mutation for the Area entity.
func newAreaMutation(c config, op Op, opts ...areaOption) *AreaMutation {
	m := &AreaMutation{
		config:        c,
		op:            op,
		typ:           TypeArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreaID sets the ID field of the mutation.
func withAreaID(id uint64) areaOption {
	return func(m *AreaMutation) {
		var (
			err   error
			once  sync.Once
			value *Area
		)
		m.oldValue = func(ctx context.Context) (*Area, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Area.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArea sets the old Area of the mutation.
func withArea(node *Area) areaOption {
	return func(m *AreaMutation) {
		m.oldValue = func(context.Context) (*Area, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Area entities.
func (m *AreaMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AreaMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AreaMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Area.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AreaMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *AreaMutation) SetLevel(u uint64) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *AreaMutation) Level() (r uint64, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldLevel(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *AreaMutation) AddLevel(u int64) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *AreaMutation) AddedLevel() (r int64, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *AreaMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetPid sets the "pid" field.
func (m *AreaMutation) SetPid(i int64) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *AreaMutation) Pid() (r int64, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldPid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *AreaMutation) AddPid(i int64) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *AreaMutation) AddedPid() (r int64, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *AreaMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// Where appends a list predicates to the AreaMutation builder.
func (m *AreaMutation) Where(ps ...predicate.Area) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Area, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Area).
func (m *AreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreaMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, area.FieldName)
	}
	if m.level != nil {
		fields = append(fields, area.FieldLevel)
	}
	if m.pid != nil {
		fields = append(fields, area.FieldPid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case area.FieldName:
		return m.Name()
	case area.FieldLevel:
		return m.Level()
	case area.FieldPid:
		return m.Pid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case area.FieldName:
		return m.OldName(ctx)
	case area.FieldLevel:
		return m.OldLevel(ctx)
	case area.FieldPid:
		return m.OldPid(ctx)
	}
	return nil, fmt.Errorf("unknown Area field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case area.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case area.FieldLevel:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case area.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreaMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, area.FieldLevel)
	}
	if m.addpid != nil {
		fields = append(fields, area.FieldPid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case area.FieldLevel:
		return m.AddedLevel()
	case area.FieldPid:
		return m.AddedPid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case area.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case area.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	}
	return fmt.Errorf("unknown Area numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Area nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreaMutation) ResetField(name string) error {
	switch name {
	case area.FieldName:
		m.ResetName()
		return nil
	case area.FieldLevel:
		m.ResetLevel()
		return nil
	case area.FieldPid:
		m.ResetPid()
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Area unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Area edge %s", name)
}

// CameraMutation represents an operation that mutates the Camera nodes in the graph.
type CameraMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	tenant_id            *string
	access_org_list      *string
	name                 *string
	position             *string
	region               *string
	region_str           *string
	longitude            *float64
	addlongitude         *float64
	latitude             *float64
	addlatitude          *float64
	custom_number        *int
	addcustom_number     *int
	channel_id           *string
	serial_number        *string
	pole_number          *string
	device_description   *string
	scene                *string
	place                *string
	status               *biz.CameraStatus
	sp_type              *streaming.ProtocolType
	sp_source            *string
	sp_codec_name        *string
	sp_width             *int32
	addsp_width          *int32
	sp_height            *int32
	addsp_height         *int32
	trans_type           *string
	device_ip            *string
	device_port          *int32
	adddevice_port       *int32
	gb_id                *string
	sip_user             *string
	sip_password         *string
	gb_channel_id        *string
	up_gb_channel_id     *string
	gb_device_type       *string
	_type                *biz.MediaType
	clearedFields        map[string]struct{}
	task                 map[uint64]struct{}
	removedtask          map[uint64]struct{}
	clearedtask          bool
	device               map[uint64]struct{}
	removeddevice        map[uint64]struct{}
	cleareddevice        bool
	task_camera          map[uint64]struct{}
	removedtask_camera   map[uint64]struct{}
	clearedtask_camera   bool
	device_camera        map[uint64]struct{}
	removeddevice_camera map[uint64]struct{}
	cleareddevice_camera bool
	done                 bool
	oldValue             func(context.Context) (*Camera, error)
	predicates           []predicate.Camera
}

var _ ent.Mutation = (*CameraMutation)(nil)

// cameraOption allows management of the mutation configuration using functional options.
type cameraOption func(*CameraMutation)

// newCameraMutation creates new mutation for the Camera entity.
func newCameraMutation(c config, op Op, opts ...cameraOption) *CameraMutation {
	m := &CameraMutation{
		config:        c,
		op:            op,
		typ:           TypeCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCameraID sets the ID field of the mutation.
func withCameraID(id uint64) cameraOption {
	return func(m *CameraMutation) {
		var (
			err   error
			once  sync.Once
			value *Camera
		)
		m.oldValue = func(ctx context.Context) (*Camera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Camera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCamera sets the old Camera of the mutation.
func withCamera(node *Camera) cameraOption {
	return func(m *CameraMutation) {
		m.oldValue = func(context.Context) (*Camera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Camera entities.
func (m *CameraMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CameraMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CameraMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Camera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CameraMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CameraMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CameraMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[camera.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CameraMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[camera.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CameraMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, camera.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *CameraMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CameraMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *CameraMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[camera.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *CameraMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[camera.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CameraMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, camera.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *CameraMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *CameraMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *CameraMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[camera.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *CameraMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[camera.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *CameraMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, camera.FieldAccessOrgList)
}

// SetName sets the "name" field.
func (m *CameraMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CameraMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CameraMutation) ResetName() {
	m.name = nil
}

// SetPosition sets the "position" field.
func (m *CameraMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *CameraMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *CameraMutation) ResetPosition() {
	m.position = nil
}

// SetRegion sets the "region" field.
func (m *CameraMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *CameraMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *CameraMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[camera.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *CameraMutation) RegionCleared() bool {
	_, ok := m.clearedFields[camera.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *CameraMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, camera.FieldRegion)
}

// SetRegionStr sets the "region_str" field.
func (m *CameraMutation) SetRegionStr(s string) {
	m.region_str = &s
}

// RegionStr returns the value of the "region_str" field in the mutation.
func (m *CameraMutation) RegionStr() (r string, exists bool) {
	v := m.region_str
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionStr returns the old "region_str" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldRegionStr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionStr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionStr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionStr: %w", err)
	}
	return oldValue.RegionStr, nil
}

// ClearRegionStr clears the value of the "region_str" field.
func (m *CameraMutation) ClearRegionStr() {
	m.region_str = nil
	m.clearedFields[camera.FieldRegionStr] = struct{}{}
}

// RegionStrCleared returns if the "region_str" field was cleared in this mutation.
func (m *CameraMutation) RegionStrCleared() bool {
	_, ok := m.clearedFields[camera.FieldRegionStr]
	return ok
}

// ResetRegionStr resets all changes to the "region_str" field.
func (m *CameraMutation) ResetRegionStr() {
	m.region_str = nil
	delete(m.clearedFields, camera.FieldRegionStr)
}

// SetLongitude sets the "longitude" field.
func (m *CameraMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *CameraMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *CameraMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *CameraMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *CameraMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *CameraMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *CameraMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *CameraMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *CameraMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *CameraMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetCustomNumber sets the "custom_number" field.
func (m *CameraMutation) SetCustomNumber(i int) {
	m.custom_number = &i
	m.addcustom_number = nil
}

// CustomNumber returns the value of the "custom_number" field in the mutation.
func (m *CameraMutation) CustomNumber() (r int, exists bool) {
	v := m.custom_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomNumber returns the old "custom_number" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldCustomNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomNumber: %w", err)
	}
	return oldValue.CustomNumber, nil
}

// AddCustomNumber adds i to the "custom_number" field.
func (m *CameraMutation) AddCustomNumber(i int) {
	if m.addcustom_number != nil {
		*m.addcustom_number += i
	} else {
		m.addcustom_number = &i
	}
}

// AddedCustomNumber returns the value that was added to the "custom_number" field in this mutation.
func (m *CameraMutation) AddedCustomNumber() (r int, exists bool) {
	v := m.addcustom_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetCustomNumber resets all changes to the "custom_number" field.
func (m *CameraMutation) ResetCustomNumber() {
	m.custom_number = nil
	m.addcustom_number = nil
}

// SetChannelID sets the "channel_id" field.
func (m *CameraMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *CameraMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *CameraMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *CameraMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *CameraMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *CameraMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetPoleNumber sets the "pole_number" field.
func (m *CameraMutation) SetPoleNumber(s string) {
	m.pole_number = &s
}

// PoleNumber returns the value of the "pole_number" field in the mutation.
func (m *CameraMutation) PoleNumber() (r string, exists bool) {
	v := m.pole_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPoleNumber returns the old "pole_number" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldPoleNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoleNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoleNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoleNumber: %w", err)
	}
	return oldValue.PoleNumber, nil
}

// ResetPoleNumber resets all changes to the "pole_number" field.
func (m *CameraMutation) ResetPoleNumber() {
	m.pole_number = nil
}

// SetDeviceDescription sets the "device_description" field.
func (m *CameraMutation) SetDeviceDescription(s string) {
	m.device_description = &s
}

// DeviceDescription returns the value of the "device_description" field in the mutation.
func (m *CameraMutation) DeviceDescription() (r string, exists bool) {
	v := m.device_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceDescription returns the old "device_description" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldDeviceDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceDescription: %w", err)
	}
	return oldValue.DeviceDescription, nil
}

// ResetDeviceDescription resets all changes to the "device_description" field.
func (m *CameraMutation) ResetDeviceDescription() {
	m.device_description = nil
}

// SetScene sets the "scene" field.
func (m *CameraMutation) SetScene(s string) {
	m.scene = &s
}

// Scene returns the value of the "scene" field in the mutation.
func (m *CameraMutation) Scene() (r string, exists bool) {
	v := m.scene
	if v == nil {
		return
	}
	return *v, true
}

// OldScene returns the old "scene" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldScene(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScene is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScene requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScene: %w", err)
	}
	return oldValue.Scene, nil
}

// ResetScene resets all changes to the "scene" field.
func (m *CameraMutation) ResetScene() {
	m.scene = nil
}

// SetPlace sets the "place" field.
func (m *CameraMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *CameraMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *CameraMutation) ResetPlace() {
	m.place = nil
}

// SetStatus sets the "status" field.
func (m *CameraMutation) SetStatus(bs biz.CameraStatus) {
	m.status = &bs
}

// Status returns the value of the "status" field in the mutation.
func (m *CameraMutation) Status() (r biz.CameraStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldStatus(ctx context.Context) (v biz.CameraStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CameraMutation) ResetStatus() {
	m.status = nil
}

// SetSpType sets the "sp_type" field.
func (m *CameraMutation) SetSpType(st streaming.ProtocolType) {
	m.sp_type = &st
}

// SpType returns the value of the "sp_type" field in the mutation.
func (m *CameraMutation) SpType() (r streaming.ProtocolType, exists bool) {
	v := m.sp_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSpType returns the old "sp_type" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSpType(ctx context.Context) (v streaming.ProtocolType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpType: %w", err)
	}
	return oldValue.SpType, nil
}

// ResetSpType resets all changes to the "sp_type" field.
func (m *CameraMutation) ResetSpType() {
	m.sp_type = nil
}

// SetSpSource sets the "sp_source" field.
func (m *CameraMutation) SetSpSource(s string) {
	m.sp_source = &s
}

// SpSource returns the value of the "sp_source" field in the mutation.
func (m *CameraMutation) SpSource() (r string, exists bool) {
	v := m.sp_source
	if v == nil {
		return
	}
	return *v, true
}

// OldSpSource returns the old "sp_source" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSpSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpSource: %w", err)
	}
	return oldValue.SpSource, nil
}

// ResetSpSource resets all changes to the "sp_source" field.
func (m *CameraMutation) ResetSpSource() {
	m.sp_source = nil
}

// SetSpCodecName sets the "sp_codec_name" field.
func (m *CameraMutation) SetSpCodecName(s string) {
	m.sp_codec_name = &s
}

// SpCodecName returns the value of the "sp_codec_name" field in the mutation.
func (m *CameraMutation) SpCodecName() (r string, exists bool) {
	v := m.sp_codec_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpCodecName returns the old "sp_codec_name" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSpCodecName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpCodecName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpCodecName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpCodecName: %w", err)
	}
	return oldValue.SpCodecName, nil
}

// ResetSpCodecName resets all changes to the "sp_codec_name" field.
func (m *CameraMutation) ResetSpCodecName() {
	m.sp_codec_name = nil
}

// SetSpWidth sets the "sp_width" field.
func (m *CameraMutation) SetSpWidth(i int32) {
	m.sp_width = &i
	m.addsp_width = nil
}

// SpWidth returns the value of the "sp_width" field in the mutation.
func (m *CameraMutation) SpWidth() (r int32, exists bool) {
	v := m.sp_width
	if v == nil {
		return
	}
	return *v, true
}

// OldSpWidth returns the old "sp_width" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSpWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpWidth: %w", err)
	}
	return oldValue.SpWidth, nil
}

// AddSpWidth adds i to the "sp_width" field.
func (m *CameraMutation) AddSpWidth(i int32) {
	if m.addsp_width != nil {
		*m.addsp_width += i
	} else {
		m.addsp_width = &i
	}
}

// AddedSpWidth returns the value that was added to the "sp_width" field in this mutation.
func (m *CameraMutation) AddedSpWidth() (r int32, exists bool) {
	v := m.addsp_width
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpWidth resets all changes to the "sp_width" field.
func (m *CameraMutation) ResetSpWidth() {
	m.sp_width = nil
	m.addsp_width = nil
}

// SetSpHeight sets the "sp_height" field.
func (m *CameraMutation) SetSpHeight(i int32) {
	m.sp_height = &i
	m.addsp_height = nil
}

// SpHeight returns the value of the "sp_height" field in the mutation.
func (m *CameraMutation) SpHeight() (r int32, exists bool) {
	v := m.sp_height
	if v == nil {
		return
	}
	return *v, true
}

// OldSpHeight returns the old "sp_height" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSpHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpHeight: %w", err)
	}
	return oldValue.SpHeight, nil
}

// AddSpHeight adds i to the "sp_height" field.
func (m *CameraMutation) AddSpHeight(i int32) {
	if m.addsp_height != nil {
		*m.addsp_height += i
	} else {
		m.addsp_height = &i
	}
}

// AddedSpHeight returns the value that was added to the "sp_height" field in this mutation.
func (m *CameraMutation) AddedSpHeight() (r int32, exists bool) {
	v := m.addsp_height
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpHeight resets all changes to the "sp_height" field.
func (m *CameraMutation) ResetSpHeight() {
	m.sp_height = nil
	m.addsp_height = nil
}

// SetTransType sets the "trans_type" field.
func (m *CameraMutation) SetTransType(s string) {
	m.trans_type = &s
}

// TransType returns the value of the "trans_type" field in the mutation.
func (m *CameraMutation) TransType() (r string, exists bool) {
	v := m.trans_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransType returns the old "trans_type" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldTransType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransType: %w", err)
	}
	return oldValue.TransType, nil
}

// ResetTransType resets all changes to the "trans_type" field.
func (m *CameraMutation) ResetTransType() {
	m.trans_type = nil
}

// SetDeviceIP sets the "device_ip" field.
func (m *CameraMutation) SetDeviceIP(s string) {
	m.device_ip = &s
}

// DeviceIP returns the value of the "device_ip" field in the mutation.
func (m *CameraMutation) DeviceIP() (r string, exists bool) {
	v := m.device_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIP returns the old "device_ip" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldDeviceIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIP: %w", err)
	}
	return oldValue.DeviceIP, nil
}

// ResetDeviceIP resets all changes to the "device_ip" field.
func (m *CameraMutation) ResetDeviceIP() {
	m.device_ip = nil
}

// SetDevicePort sets the "device_port" field.
func (m *CameraMutation) SetDevicePort(i int32) {
	m.device_port = &i
	m.adddevice_port = nil
}

// DevicePort returns the value of the "device_port" field in the mutation.
func (m *CameraMutation) DevicePort() (r int32, exists bool) {
	v := m.device_port
	if v == nil {
		return
	}
	return *v, true
}

// OldDevicePort returns the old "device_port" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldDevicePort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevicePort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevicePort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevicePort: %w", err)
	}
	return oldValue.DevicePort, nil
}

// AddDevicePort adds i to the "device_port" field.
func (m *CameraMutation) AddDevicePort(i int32) {
	if m.adddevice_port != nil {
		*m.adddevice_port += i
	} else {
		m.adddevice_port = &i
	}
}

// AddedDevicePort returns the value that was added to the "device_port" field in this mutation.
func (m *CameraMutation) AddedDevicePort() (r int32, exists bool) {
	v := m.adddevice_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetDevicePort resets all changes to the "device_port" field.
func (m *CameraMutation) ResetDevicePort() {
	m.device_port = nil
	m.adddevice_port = nil
}

// SetGBID sets the "gb_id" field.
func (m *CameraMutation) SetGBID(s string) {
	m.gb_id = &s
}

// GBID returns the value of the "gb_id" field in the mutation.
func (m *CameraMutation) GBID() (r string, exists bool) {
	v := m.gb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGBID returns the old "gb_id" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldGBID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGBID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGBID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGBID: %w", err)
	}
	return oldValue.GBID, nil
}

// ResetGBID resets all changes to the "gb_id" field.
func (m *CameraMutation) ResetGBID() {
	m.gb_id = nil
}

// SetSipUser sets the "sip_user" field.
func (m *CameraMutation) SetSipUser(s string) {
	m.sip_user = &s
}

// SipUser returns the value of the "sip_user" field in the mutation.
func (m *CameraMutation) SipUser() (r string, exists bool) {
	v := m.sip_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSipUser returns the old "sip_user" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSipUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipUser: %w", err)
	}
	return oldValue.SipUser, nil
}

// ResetSipUser resets all changes to the "sip_user" field.
func (m *CameraMutation) ResetSipUser() {
	m.sip_user = nil
}

// SetSipPassword sets the "sip_password" field.
func (m *CameraMutation) SetSipPassword(s string) {
	m.sip_password = &s
}

// SipPassword returns the value of the "sip_password" field in the mutation.
func (m *CameraMutation) SipPassword() (r string, exists bool) {
	v := m.sip_password
	if v == nil {
		return
	}
	return *v, true
}

// OldSipPassword returns the old "sip_password" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldSipPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipPassword: %w", err)
	}
	return oldValue.SipPassword, nil
}

// ResetSipPassword resets all changes to the "sip_password" field.
func (m *CameraMutation) ResetSipPassword() {
	m.sip_password = nil
}

// SetGBChannelID sets the "gb_channel_id" field.
func (m *CameraMutation) SetGBChannelID(s string) {
	m.gb_channel_id = &s
}

// GBChannelID returns the value of the "gb_channel_id" field in the mutation.
func (m *CameraMutation) GBChannelID() (r string, exists bool) {
	v := m.gb_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGBChannelID returns the old "gb_channel_id" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldGBChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGBChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGBChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGBChannelID: %w", err)
	}
	return oldValue.GBChannelID, nil
}

// ResetGBChannelID resets all changes to the "gb_channel_id" field.
func (m *CameraMutation) ResetGBChannelID() {
	m.gb_channel_id = nil
}

// SetUpGBChannelID sets the "up_gb_channel_id" field.
func (m *CameraMutation) SetUpGBChannelID(s string) {
	m.up_gb_channel_id = &s
}

// UpGBChannelID returns the value of the "up_gb_channel_id" field in the mutation.
func (m *CameraMutation) UpGBChannelID() (r string, exists bool) {
	v := m.up_gb_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpGBChannelID returns the old "up_gb_channel_id" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUpGBChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpGBChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpGBChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpGBChannelID: %w", err)
	}
	return oldValue.UpGBChannelID, nil
}

// ResetUpGBChannelID resets all changes to the "up_gb_channel_id" field.
func (m *CameraMutation) ResetUpGBChannelID() {
	m.up_gb_channel_id = nil
}

// SetGBDeviceType sets the "gb_device_type" field.
func (m *CameraMutation) SetGBDeviceType(s string) {
	m.gb_device_type = &s
}

// GBDeviceType returns the value of the "gb_device_type" field in the mutation.
func (m *CameraMutation) GBDeviceType() (r string, exists bool) {
	v := m.gb_device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGBDeviceType returns the old "gb_device_type" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldGBDeviceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGBDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGBDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGBDeviceType: %w", err)
	}
	return oldValue.GBDeviceType, nil
}

// ResetGBDeviceType resets all changes to the "gb_device_type" field.
func (m *CameraMutation) ResetGBDeviceType() {
	m.gb_device_type = nil
}

// SetType sets the "type" field.
func (m *CameraMutation) SetType(bt biz.MediaType) {
	m._type = &bt
}

// GetType returns the value of the "type" field in the mutation.
func (m *CameraMutation) GetType() (r biz.MediaType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldType(ctx context.Context) (v biz.MediaType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CameraMutation) ResetType() {
	m._type = nil
}

// AddTaskIDs adds the "task" edge to the Task entity by ids.
func (m *CameraMutation) AddTaskIDs(ids ...uint64) {
	if m.task == nil {
		m.task = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "task" edge to the Task entity.
func (m *CameraMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *CameraMutation) TaskCleared() bool {
	return m.clearedtask
}

// RemoveTaskIDs removes the "task" edge to the Task entity by IDs.
func (m *CameraMutation) RemoveTaskIDs(ids ...uint64) {
	if m.removedtask == nil {
		m.removedtask = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task, ids[i])
		m.removedtask[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "task" edge to the Task entity.
func (m *CameraMutation) RemovedTaskIDs() (ids []uint64) {
	for id := range m.removedtask {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
func (m *CameraMutation) TaskIDs() (ids []uint64) {
	for id := range m.task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *CameraMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
	m.removedtask = nil
}

// AddDeviceIDs adds the "device" edge to the Device entity by ids.
func (m *CameraMutation) AddDeviceIDs(ids ...uint64) {
	if m.device == nil {
		m.device = make(map[uint64]struct{})
	}
	for i := range ids {
		m.device[ids[i]] = struct{}{}
	}
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *CameraMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *CameraMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// RemoveDeviceIDs removes the "device" edge to the Device entity by IDs.
func (m *CameraMutation) RemoveDeviceIDs(ids ...uint64) {
	if m.removeddevice == nil {
		m.removeddevice = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.device, ids[i])
		m.removeddevice[ids[i]] = struct{}{}
	}
}

// RemovedDevice returns the removed IDs of the "device" edge to the Device entity.
func (m *CameraMutation) RemovedDeviceIDs() (ids []uint64) {
	for id := range m.removeddevice {
		ids = append(ids, id)
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
func (m *CameraMutation) DeviceIDs() (ids []uint64) {
	for id := range m.device {
		ids = append(ids, id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *CameraMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
	m.removeddevice = nil
}

// AddTaskCameraIDs adds the "task_camera" edge to the TaskCamera entity by ids.
func (m *CameraMutation) AddTaskCameraIDs(ids ...uint64) {
	if m.task_camera == nil {
		m.task_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_camera[ids[i]] = struct{}{}
	}
}

// ClearTaskCamera clears the "task_camera" edge to the TaskCamera entity.
func (m *CameraMutation) ClearTaskCamera() {
	m.clearedtask_camera = true
}

// TaskCameraCleared reports if the "task_camera" edge to the TaskCamera entity was cleared.
func (m *CameraMutation) TaskCameraCleared() bool {
	return m.clearedtask_camera
}

// RemoveTaskCameraIDs removes the "task_camera" edge to the TaskCamera entity by IDs.
func (m *CameraMutation) RemoveTaskCameraIDs(ids ...uint64) {
	if m.removedtask_camera == nil {
		m.removedtask_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_camera, ids[i])
		m.removedtask_camera[ids[i]] = struct{}{}
	}
}

// RemovedTaskCamera returns the removed IDs of the "task_camera" edge to the TaskCamera entity.
func (m *CameraMutation) RemovedTaskCameraIDs() (ids []uint64) {
	for id := range m.removedtask_camera {
		ids = append(ids, id)
	}
	return
}

// TaskCameraIDs returns the "task_camera" edge IDs in the mutation.
func (m *CameraMutation) TaskCameraIDs() (ids []uint64) {
	for id := range m.task_camera {
		ids = append(ids, id)
	}
	return
}

// ResetTaskCamera resets all changes to the "task_camera" edge.
func (m *CameraMutation) ResetTaskCamera() {
	m.task_camera = nil
	m.clearedtask_camera = false
	m.removedtask_camera = nil
}

// AddDeviceCameraIDs adds the "device_camera" edge to the DeviceCamera entity by ids.
func (m *CameraMutation) AddDeviceCameraIDs(ids ...uint64) {
	if m.device_camera == nil {
		m.device_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		m.device_camera[ids[i]] = struct{}{}
	}
}

// ClearDeviceCamera clears the "device_camera" edge to the DeviceCamera entity.
func (m *CameraMutation) ClearDeviceCamera() {
	m.cleareddevice_camera = true
}

// DeviceCameraCleared reports if the "device_camera" edge to the DeviceCamera entity was cleared.
func (m *CameraMutation) DeviceCameraCleared() bool {
	return m.cleareddevice_camera
}

// RemoveDeviceCameraIDs removes the "device_camera" edge to the DeviceCamera entity by IDs.
func (m *CameraMutation) RemoveDeviceCameraIDs(ids ...uint64) {
	if m.removeddevice_camera == nil {
		m.removeddevice_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.device_camera, ids[i])
		m.removeddevice_camera[ids[i]] = struct{}{}
	}
}

// RemovedDeviceCamera returns the removed IDs of the "device_camera" edge to the DeviceCamera entity.
func (m *CameraMutation) RemovedDeviceCameraIDs() (ids []uint64) {
	for id := range m.removeddevice_camera {
		ids = append(ids, id)
	}
	return
}

// DeviceCameraIDs returns the "device_camera" edge IDs in the mutation.
func (m *CameraMutation) DeviceCameraIDs() (ids []uint64) {
	for id := range m.device_camera {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceCamera resets all changes to the "device_camera" edge.
func (m *CameraMutation) ResetDeviceCamera() {
	m.device_camera = nil
	m.cleareddevice_camera = false
	m.removeddevice_camera = nil
}

// Where appends a list predicates to the CameraMutation builder.
func (m *CameraMutation) Where(ps ...predicate.Camera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Camera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Camera).
func (m *CameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CameraMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.created_at != nil {
		fields = append(fields, camera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, camera.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, camera.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, camera.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, camera.FieldAccessOrgList)
	}
	if m.name != nil {
		fields = append(fields, camera.FieldName)
	}
	if m.position != nil {
		fields = append(fields, camera.FieldPosition)
	}
	if m.region != nil {
		fields = append(fields, camera.FieldRegion)
	}
	if m.region_str != nil {
		fields = append(fields, camera.FieldRegionStr)
	}
	if m.longitude != nil {
		fields = append(fields, camera.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, camera.FieldLatitude)
	}
	if m.custom_number != nil {
		fields = append(fields, camera.FieldCustomNumber)
	}
	if m.channel_id != nil {
		fields = append(fields, camera.FieldChannelID)
	}
	if m.serial_number != nil {
		fields = append(fields, camera.FieldSerialNumber)
	}
	if m.pole_number != nil {
		fields = append(fields, camera.FieldPoleNumber)
	}
	if m.device_description != nil {
		fields = append(fields, camera.FieldDeviceDescription)
	}
	if m.scene != nil {
		fields = append(fields, camera.FieldScene)
	}
	if m.place != nil {
		fields = append(fields, camera.FieldPlace)
	}
	if m.status != nil {
		fields = append(fields, camera.FieldStatus)
	}
	if m.sp_type != nil {
		fields = append(fields, camera.FieldSpType)
	}
	if m.sp_source != nil {
		fields = append(fields, camera.FieldSpSource)
	}
	if m.sp_codec_name != nil {
		fields = append(fields, camera.FieldSpCodecName)
	}
	if m.sp_width != nil {
		fields = append(fields, camera.FieldSpWidth)
	}
	if m.sp_height != nil {
		fields = append(fields, camera.FieldSpHeight)
	}
	if m.trans_type != nil {
		fields = append(fields, camera.FieldTransType)
	}
	if m.device_ip != nil {
		fields = append(fields, camera.FieldDeviceIP)
	}
	if m.device_port != nil {
		fields = append(fields, camera.FieldDevicePort)
	}
	if m.gb_id != nil {
		fields = append(fields, camera.FieldGBID)
	}
	if m.sip_user != nil {
		fields = append(fields, camera.FieldSipUser)
	}
	if m.sip_password != nil {
		fields = append(fields, camera.FieldSipPassword)
	}
	if m.gb_channel_id != nil {
		fields = append(fields, camera.FieldGBChannelID)
	}
	if m.up_gb_channel_id != nil {
		fields = append(fields, camera.FieldUpGBChannelID)
	}
	if m.gb_device_type != nil {
		fields = append(fields, camera.FieldGBDeviceType)
	}
	if m._type != nil {
		fields = append(fields, camera.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldCreatedAt:
		return m.CreatedAt()
	case camera.FieldUpdatedAt:
		return m.UpdatedAt()
	case camera.FieldDeletedAt:
		return m.DeletedAt()
	case camera.FieldTenantID:
		return m.TenantID()
	case camera.FieldAccessOrgList:
		return m.AccessOrgList()
	case camera.FieldName:
		return m.Name()
	case camera.FieldPosition:
		return m.Position()
	case camera.FieldRegion:
		return m.Region()
	case camera.FieldRegionStr:
		return m.RegionStr()
	case camera.FieldLongitude:
		return m.Longitude()
	case camera.FieldLatitude:
		return m.Latitude()
	case camera.FieldCustomNumber:
		return m.CustomNumber()
	case camera.FieldChannelID:
		return m.ChannelID()
	case camera.FieldSerialNumber:
		return m.SerialNumber()
	case camera.FieldPoleNumber:
		return m.PoleNumber()
	case camera.FieldDeviceDescription:
		return m.DeviceDescription()
	case camera.FieldScene:
		return m.Scene()
	case camera.FieldPlace:
		return m.Place()
	case camera.FieldStatus:
		return m.Status()
	case camera.FieldSpType:
		return m.SpType()
	case camera.FieldSpSource:
		return m.SpSource()
	case camera.FieldSpCodecName:
		return m.SpCodecName()
	case camera.FieldSpWidth:
		return m.SpWidth()
	case camera.FieldSpHeight:
		return m.SpHeight()
	case camera.FieldTransType:
		return m.TransType()
	case camera.FieldDeviceIP:
		return m.DeviceIP()
	case camera.FieldDevicePort:
		return m.DevicePort()
	case camera.FieldGBID:
		return m.GBID()
	case camera.FieldSipUser:
		return m.SipUser()
	case camera.FieldSipPassword:
		return m.SipPassword()
	case camera.FieldGBChannelID:
		return m.GBChannelID()
	case camera.FieldUpGBChannelID:
		return m.UpGBChannelID()
	case camera.FieldGBDeviceType:
		return m.GBDeviceType()
	case camera.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case camera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case camera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case camera.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case camera.FieldTenantID:
		return m.OldTenantID(ctx)
	case camera.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case camera.FieldName:
		return m.OldName(ctx)
	case camera.FieldPosition:
		return m.OldPosition(ctx)
	case camera.FieldRegion:
		return m.OldRegion(ctx)
	case camera.FieldRegionStr:
		return m.OldRegionStr(ctx)
	case camera.FieldLongitude:
		return m.OldLongitude(ctx)
	case camera.FieldLatitude:
		return m.OldLatitude(ctx)
	case camera.FieldCustomNumber:
		return m.OldCustomNumber(ctx)
	case camera.FieldChannelID:
		return m.OldChannelID(ctx)
	case camera.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case camera.FieldPoleNumber:
		return m.OldPoleNumber(ctx)
	case camera.FieldDeviceDescription:
		return m.OldDeviceDescription(ctx)
	case camera.FieldScene:
		return m.OldScene(ctx)
	case camera.FieldPlace:
		return m.OldPlace(ctx)
	case camera.FieldStatus:
		return m.OldStatus(ctx)
	case camera.FieldSpType:
		return m.OldSpType(ctx)
	case camera.FieldSpSource:
		return m.OldSpSource(ctx)
	case camera.FieldSpCodecName:
		return m.OldSpCodecName(ctx)
	case camera.FieldSpWidth:
		return m.OldSpWidth(ctx)
	case camera.FieldSpHeight:
		return m.OldSpHeight(ctx)
	case camera.FieldTransType:
		return m.OldTransType(ctx)
	case camera.FieldDeviceIP:
		return m.OldDeviceIP(ctx)
	case camera.FieldDevicePort:
		return m.OldDevicePort(ctx)
	case camera.FieldGBID:
		return m.OldGBID(ctx)
	case camera.FieldSipUser:
		return m.OldSipUser(ctx)
	case camera.FieldSipPassword:
		return m.OldSipPassword(ctx)
	case camera.FieldGBChannelID:
		return m.OldGBChannelID(ctx)
	case camera.FieldUpGBChannelID:
		return m.OldUpGBChannelID(ctx)
	case camera.FieldGBDeviceType:
		return m.OldGBDeviceType(ctx)
	case camera.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Camera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case camera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case camera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case camera.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case camera.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case camera.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case camera.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case camera.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case camera.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case camera.FieldRegionStr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionStr(v)
		return nil
	case camera.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case camera.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case camera.FieldCustomNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomNumber(v)
		return nil
	case camera.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case camera.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case camera.FieldPoleNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoleNumber(v)
		return nil
	case camera.FieldDeviceDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceDescription(v)
		return nil
	case camera.FieldScene:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScene(v)
		return nil
	case camera.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case camera.FieldStatus:
		v, ok := value.(biz.CameraStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case camera.FieldSpType:
		v, ok := value.(streaming.ProtocolType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpType(v)
		return nil
	case camera.FieldSpSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpSource(v)
		return nil
	case camera.FieldSpCodecName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpCodecName(v)
		return nil
	case camera.FieldSpWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpWidth(v)
		return nil
	case camera.FieldSpHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpHeight(v)
		return nil
	case camera.FieldTransType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransType(v)
		return nil
	case camera.FieldDeviceIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIP(v)
		return nil
	case camera.FieldDevicePort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevicePort(v)
		return nil
	case camera.FieldGBID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGBID(v)
		return nil
	case camera.FieldSipUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipUser(v)
		return nil
	case camera.FieldSipPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipPassword(v)
		return nil
	case camera.FieldGBChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGBChannelID(v)
		return nil
	case camera.FieldUpGBChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpGBChannelID(v)
		return nil
	case camera.FieldGBDeviceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGBDeviceType(v)
		return nil
	case camera.FieldType:
		v, ok := value.(biz.MediaType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CameraMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, camera.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, camera.FieldLatitude)
	}
	if m.addcustom_number != nil {
		fields = append(fields, camera.FieldCustomNumber)
	}
	if m.addsp_width != nil {
		fields = append(fields, camera.FieldSpWidth)
	}
	if m.addsp_height != nil {
		fields = append(fields, camera.FieldSpHeight)
	}
	if m.adddevice_port != nil {
		fields = append(fields, camera.FieldDevicePort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CameraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldLongitude:
		return m.AddedLongitude()
	case camera.FieldLatitude:
		return m.AddedLatitude()
	case camera.FieldCustomNumber:
		return m.AddedCustomNumber()
	case camera.FieldSpWidth:
		return m.AddedSpWidth()
	case camera.FieldSpHeight:
		return m.AddedSpHeight()
	case camera.FieldDevicePort:
		return m.AddedDevicePort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case camera.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case camera.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case camera.FieldCustomNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomNumber(v)
		return nil
	case camera.FieldSpWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpWidth(v)
		return nil
	case camera.FieldSpHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpHeight(v)
		return nil
	case camera.FieldDevicePort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDevicePort(v)
		return nil
	}
	return fmt.Errorf("unknown Camera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CameraMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(camera.FieldDeletedAt) {
		fields = append(fields, camera.FieldDeletedAt)
	}
	if m.FieldCleared(camera.FieldTenantID) {
		fields = append(fields, camera.FieldTenantID)
	}
	if m.FieldCleared(camera.FieldAccessOrgList) {
		fields = append(fields, camera.FieldAccessOrgList)
	}
	if m.FieldCleared(camera.FieldRegion) {
		fields = append(fields, camera.FieldRegion)
	}
	if m.FieldCleared(camera.FieldRegionStr) {
		fields = append(fields, camera.FieldRegionStr)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CameraMutation) ClearField(name string) error {
	switch name {
	case camera.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case camera.FieldTenantID:
		m.ClearTenantID()
		return nil
	case camera.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	case camera.FieldRegion:
		m.ClearRegion()
		return nil
	case camera.FieldRegionStr:
		m.ClearRegionStr()
		return nil
	}
	return fmt.Errorf("unknown Camera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CameraMutation) ResetField(name string) error {
	switch name {
	case camera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case camera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case camera.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case camera.FieldTenantID:
		m.ResetTenantID()
		return nil
	case camera.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case camera.FieldName:
		m.ResetName()
		return nil
	case camera.FieldPosition:
		m.ResetPosition()
		return nil
	case camera.FieldRegion:
		m.ResetRegion()
		return nil
	case camera.FieldRegionStr:
		m.ResetRegionStr()
		return nil
	case camera.FieldLongitude:
		m.ResetLongitude()
		return nil
	case camera.FieldLatitude:
		m.ResetLatitude()
		return nil
	case camera.FieldCustomNumber:
		m.ResetCustomNumber()
		return nil
	case camera.FieldChannelID:
		m.ResetChannelID()
		return nil
	case camera.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case camera.FieldPoleNumber:
		m.ResetPoleNumber()
		return nil
	case camera.FieldDeviceDescription:
		m.ResetDeviceDescription()
		return nil
	case camera.FieldScene:
		m.ResetScene()
		return nil
	case camera.FieldPlace:
		m.ResetPlace()
		return nil
	case camera.FieldStatus:
		m.ResetStatus()
		return nil
	case camera.FieldSpType:
		m.ResetSpType()
		return nil
	case camera.FieldSpSource:
		m.ResetSpSource()
		return nil
	case camera.FieldSpCodecName:
		m.ResetSpCodecName()
		return nil
	case camera.FieldSpWidth:
		m.ResetSpWidth()
		return nil
	case camera.FieldSpHeight:
		m.ResetSpHeight()
		return nil
	case camera.FieldTransType:
		m.ResetTransType()
		return nil
	case camera.FieldDeviceIP:
		m.ResetDeviceIP()
		return nil
	case camera.FieldDevicePort:
		m.ResetDevicePort()
		return nil
	case camera.FieldGBID:
		m.ResetGBID()
		return nil
	case camera.FieldSipUser:
		m.ResetSipUser()
		return nil
	case camera.FieldSipPassword:
		m.ResetSipPassword()
		return nil
	case camera.FieldGBChannelID:
		m.ResetGBChannelID()
		return nil
	case camera.FieldUpGBChannelID:
		m.ResetUpGBChannelID()
		return nil
	case camera.FieldGBDeviceType:
		m.ResetGBDeviceType()
		return nil
	case camera.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.task != nil {
		edges = append(edges, camera.EdgeTask)
	}
	if m.device != nil {
		edges = append(edges, camera.EdgeDevice)
	}
	if m.task_camera != nil {
		edges = append(edges, camera.EdgeTaskCamera)
	}
	if m.device_camera != nil {
		edges = append(edges, camera.EdgeDeviceCamera)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTask:
		ids := make([]ent.Value, 0, len(m.task))
		for id := range m.task {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDevice:
		ids := make([]ent.Value, 0, len(m.device))
		for id := range m.device {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeTaskCamera:
		ids := make([]ent.Value, 0, len(m.task_camera))
		for id := range m.task_camera {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDeviceCamera:
		ids := make([]ent.Value, 0, len(m.device_camera))
		for id := range m.device_camera {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtask != nil {
		edges = append(edges, camera.EdgeTask)
	}
	if m.removeddevice != nil {
		edges = append(edges, camera.EdgeDevice)
	}
	if m.removedtask_camera != nil {
		edges = append(edges, camera.EdgeTaskCamera)
	}
	if m.removeddevice_camera != nil {
		edges = append(edges, camera.EdgeDeviceCamera)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CameraMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removedtask))
		for id := range m.removedtask {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDevice:
		ids := make([]ent.Value, 0, len(m.removeddevice))
		for id := range m.removeddevice {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeTaskCamera:
		ids := make([]ent.Value, 0, len(m.removedtask_camera))
		for id := range m.removedtask_camera {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDeviceCamera:
		ids := make([]ent.Value, 0, len(m.removeddevice_camera))
		for id := range m.removeddevice_camera {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtask {
		edges = append(edges, camera.EdgeTask)
	}
	if m.cleareddevice {
		edges = append(edges, camera.EdgeDevice)
	}
	if m.clearedtask_camera {
		edges = append(edges, camera.EdgeTaskCamera)
	}
	if m.cleareddevice_camera {
		edges = append(edges, camera.EdgeDeviceCamera)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CameraMutation) EdgeCleared(name string) bool {
	switch name {
	case camera.EdgeTask:
		return m.clearedtask
	case camera.EdgeDevice:
		return m.cleareddevice
	case camera.EdgeTaskCamera:
		return m.clearedtask_camera
	case camera.EdgeDeviceCamera:
		return m.cleareddevice_camera
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CameraMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Camera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CameraMutation) ResetEdge(name string) error {
	switch name {
	case camera.EdgeTask:
		m.ResetTask()
		return nil
	case camera.EdgeDevice:
		m.ResetDevice()
		return nil
	case camera.EdgeTaskCamera:
		m.ResetTaskCamera()
		return nil
	case camera.EdgeDeviceCamera:
		m.ResetDeviceCamera()
		return nil
	}
	return fmt.Errorf("unknown Camera edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	tenant_id            *string
	access_org_list      *string
	name                 *string
	display_name         *string
	_type                *biz.EdgeDeviceType
	ext_id               *string
	serial_no            *string
	state                *biz.DeviceState
	mac                  *string
	zone_name            *string
	zone_id              *string
	workspace_id         *string
	equip_id             *string
	equip_password       *string
	device_info          *string
	model                *string
	auth_deadline        *int64
	addauth_deadline     *int64
	activated_at         *time.Time
	clearedFields        map[string]struct{}
	camera               map[uint64]struct{}
	removedcamera        map[uint64]struct{}
	clearedcamera        bool
	task_device          map[uint64]struct{}
	removedtask_device   map[uint64]struct{}
	clearedtask_device   bool
	device_camera        map[uint64]struct{}
	removeddevice_camera map[uint64]struct{}
	cleareddevice_camera bool
	done                 bool
	oldValue             func(context.Context) (*Device, error)
	predicates           []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id uint64) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[device.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[device.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, device.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *DeviceMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeviceMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *DeviceMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[device.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *DeviceMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[device.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeviceMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, device.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *DeviceMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *DeviceMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *DeviceMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[device.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *DeviceMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[device.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *DeviceMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, device.FieldAccessOrgList)
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *DeviceMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DeviceMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DeviceMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetType sets the "type" field.
func (m *DeviceMutation) SetType(bdt biz.EdgeDeviceType) {
	m._type = &bdt
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceMutation) GetType() (r biz.EdgeDeviceType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldType(ctx context.Context) (v biz.EdgeDeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DeviceMutation) ResetType() {
	m._type = nil
}

// SetExtID sets the "ext_id" field.
func (m *DeviceMutation) SetExtID(s string) {
	m.ext_id = &s
}

// ExtID returns the value of the "ext_id" field in the mutation.
func (m *DeviceMutation) ExtID() (r string, exists bool) {
	v := m.ext_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtID returns the old "ext_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldExtID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtID: %w", err)
	}
	return oldValue.ExtID, nil
}

// ResetExtID resets all changes to the "ext_id" field.
func (m *DeviceMutation) ResetExtID() {
	m.ext_id = nil
}

// SetSerialNo sets the "serial_no" field.
func (m *DeviceMutation) SetSerialNo(s string) {
	m.serial_no = &s
}

// SerialNo returns the value of the "serial_no" field in the mutation.
func (m *DeviceMutation) SerialNo() (r string, exists bool) {
	v := m.serial_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNo returns the old "serial_no" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSerialNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNo: %w", err)
	}
	return oldValue.SerialNo, nil
}

// ResetSerialNo resets all changes to the "serial_no" field.
func (m *DeviceMutation) ResetSerialNo() {
	m.serial_no = nil
}

// SetState sets the "state" field.
func (m *DeviceMutation) SetState(bs biz.DeviceState) {
	m.state = &bs
}

// State returns the value of the "state" field in the mutation.
func (m *DeviceMutation) State() (r biz.DeviceState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldState(ctx context.Context) (v biz.DeviceState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *DeviceMutation) ResetState() {
	m.state = nil
}

// SetMAC sets the "mac" field.
func (m *DeviceMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *DeviceMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ResetMAC resets all changes to the "mac" field.
func (m *DeviceMutation) ResetMAC() {
	m.mac = nil
}

// SetZoneName sets the "zone_name" field.
func (m *DeviceMutation) SetZoneName(s string) {
	m.zone_name = &s
}

// ZoneName returns the value of the "zone_name" field in the mutation.
func (m *DeviceMutation) ZoneName() (r string, exists bool) {
	v := m.zone_name
	if v == nil {
		return
	}
	return *v, true
}

// OldZoneName returns the old "zone_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldZoneName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZoneName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZoneName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZoneName: %w", err)
	}
	return oldValue.ZoneName, nil
}

// ResetZoneName resets all changes to the "zone_name" field.
func (m *DeviceMutation) ResetZoneName() {
	m.zone_name = nil
}

// SetZoneID sets the "zone_id" field.
func (m *DeviceMutation) SetZoneID(s string) {
	m.zone_id = &s
}

// ZoneID returns the value of the "zone_id" field in the mutation.
func (m *DeviceMutation) ZoneID() (r string, exists bool) {
	v := m.zone_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZoneID returns the old "zone_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldZoneID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZoneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZoneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZoneID: %w", err)
	}
	return oldValue.ZoneID, nil
}

// ResetZoneID resets all changes to the "zone_id" field.
func (m *DeviceMutation) ResetZoneID() {
	m.zone_id = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *DeviceMutation) SetWorkspaceID(s string) {
	m.workspace_id = &s
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *DeviceMutation) WorkspaceID() (r string, exists bool) {
	v := m.workspace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldWorkspaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *DeviceMutation) ResetWorkspaceID() {
	m.workspace_id = nil
}

// SetEquipID sets the "equip_id" field.
func (m *DeviceMutation) SetEquipID(s string) {
	m.equip_id = &s
}

// EquipID returns the value of the "equip_id" field in the mutation.
func (m *DeviceMutation) EquipID() (r string, exists bool) {
	v := m.equip_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipID returns the old "equip_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldEquipID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipID: %w", err)
	}
	return oldValue.EquipID, nil
}

// ResetEquipID resets all changes to the "equip_id" field.
func (m *DeviceMutation) ResetEquipID() {
	m.equip_id = nil
}

// SetEquipPassword sets the "equip_password" field.
func (m *DeviceMutation) SetEquipPassword(s string) {
	m.equip_password = &s
}

// EquipPassword returns the value of the "equip_password" field in the mutation.
func (m *DeviceMutation) EquipPassword() (r string, exists bool) {
	v := m.equip_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipPassword returns the old "equip_password" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldEquipPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipPassword: %w", err)
	}
	return oldValue.EquipPassword, nil
}

// ResetEquipPassword resets all changes to the "equip_password" field.
func (m *DeviceMutation) ResetEquipPassword() {
	m.equip_password = nil
}

// SetDeviceInfo sets the "device_info" field.
func (m *DeviceMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *DeviceMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *DeviceMutation) ResetDeviceInfo() {
	m.device_info = nil
}

// SetModel sets the "model" field.
func (m *DeviceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *DeviceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *DeviceMutation) ClearModel() {
	m.model = nil
	m.clearedFields[device.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *DeviceMutation) ModelCleared() bool {
	_, ok := m.clearedFields[device.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *DeviceMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, device.FieldModel)
}

// SetAuthDeadline sets the "auth_deadline" field.
func (m *DeviceMutation) SetAuthDeadline(i int64) {
	m.auth_deadline = &i
	m.addauth_deadline = nil
}

// AuthDeadline returns the value of the "auth_deadline" field in the mutation.
func (m *DeviceMutation) AuthDeadline() (r int64, exists bool) {
	v := m.auth_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthDeadline returns the old "auth_deadline" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldAuthDeadline(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthDeadline: %w", err)
	}
	return oldValue.AuthDeadline, nil
}

// AddAuthDeadline adds i to the "auth_deadline" field.
func (m *DeviceMutation) AddAuthDeadline(i int64) {
	if m.addauth_deadline != nil {
		*m.addauth_deadline += i
	} else {
		m.addauth_deadline = &i
	}
}

// AddedAuthDeadline returns the value that was added to the "auth_deadline" field in this mutation.
func (m *DeviceMutation) AddedAuthDeadline() (r int64, exists bool) {
	v := m.addauth_deadline
	if v == nil {
		return
	}
	return *v, true
}

// ClearAuthDeadline clears the value of the "auth_deadline" field.
func (m *DeviceMutation) ClearAuthDeadline() {
	m.auth_deadline = nil
	m.addauth_deadline = nil
	m.clearedFields[device.FieldAuthDeadline] = struct{}{}
}

// AuthDeadlineCleared returns if the "auth_deadline" field was cleared in this mutation.
func (m *DeviceMutation) AuthDeadlineCleared() bool {
	_, ok := m.clearedFields[device.FieldAuthDeadline]
	return ok
}

// ResetAuthDeadline resets all changes to the "auth_deadline" field.
func (m *DeviceMutation) ResetAuthDeadline() {
	m.auth_deadline = nil
	m.addauth_deadline = nil
	delete(m.clearedFields, device.FieldAuthDeadline)
}

// SetActivatedAt sets the "activated_at" field.
func (m *DeviceMutation) SetActivatedAt(t time.Time) {
	m.activated_at = &t
}

// ActivatedAt returns the value of the "activated_at" field in the mutation.
func (m *DeviceMutation) ActivatedAt() (r time.Time, exists bool) {
	v := m.activated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldActivatedAt returns the old "activated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldActivatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivatedAt: %w", err)
	}
	return oldValue.ActivatedAt, nil
}

// ResetActivatedAt resets all changes to the "activated_at" field.
func (m *DeviceMutation) ResetActivatedAt() {
	m.activated_at = nil
}

// AddCameraIDs adds the "camera" edge to the Camera entity by ids.
func (m *DeviceMutation) AddCameraIDs(ids ...uint64) {
	if m.camera == nil {
		m.camera = make(map[uint64]struct{})
	}
	for i := range ids {
		m.camera[ids[i]] = struct{}{}
	}
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *DeviceMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *DeviceMutation) CameraCleared() bool {
	return m.clearedcamera
}

// RemoveCameraIDs removes the "camera" edge to the Camera entity by IDs.
func (m *DeviceMutation) RemoveCameraIDs(ids ...uint64) {
	if m.removedcamera == nil {
		m.removedcamera = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.camera, ids[i])
		m.removedcamera[ids[i]] = struct{}{}
	}
}

// RemovedCamera returns the removed IDs of the "camera" edge to the Camera entity.
func (m *DeviceMutation) RemovedCameraIDs() (ids []uint64) {
	for id := range m.removedcamera {
		ids = append(ids, id)
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
func (m *DeviceMutation) CameraIDs() (ids []uint64) {
	for id := range m.camera {
		ids = append(ids, id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *DeviceMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
	m.removedcamera = nil
}

// AddTaskDeviceIDs adds the "task_device" edge to the Task entity by ids.
func (m *DeviceMutation) AddTaskDeviceIDs(ids ...uint64) {
	if m.task_device == nil {
		m.task_device = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_device[ids[i]] = struct{}{}
	}
}

// ClearTaskDevice clears the "task_device" edge to the Task entity.
func (m *DeviceMutation) ClearTaskDevice() {
	m.clearedtask_device = true
}

// TaskDeviceCleared reports if the "task_device" edge to the Task entity was cleared.
func (m *DeviceMutation) TaskDeviceCleared() bool {
	return m.clearedtask_device
}

// RemoveTaskDeviceIDs removes the "task_device" edge to the Task entity by IDs.
func (m *DeviceMutation) RemoveTaskDeviceIDs(ids ...uint64) {
	if m.removedtask_device == nil {
		m.removedtask_device = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_device, ids[i])
		m.removedtask_device[ids[i]] = struct{}{}
	}
}

// RemovedTaskDevice returns the removed IDs of the "task_device" edge to the Task entity.
func (m *DeviceMutation) RemovedTaskDeviceIDs() (ids []uint64) {
	for id := range m.removedtask_device {
		ids = append(ids, id)
	}
	return
}

// TaskDeviceIDs returns the "task_device" edge IDs in the mutation.
func (m *DeviceMutation) TaskDeviceIDs() (ids []uint64) {
	for id := range m.task_device {
		ids = append(ids, id)
	}
	return
}

// ResetTaskDevice resets all changes to the "task_device" edge.
func (m *DeviceMutation) ResetTaskDevice() {
	m.task_device = nil
	m.clearedtask_device = false
	m.removedtask_device = nil
}

// AddDeviceCameraIDs adds the "device_camera" edge to the DeviceCamera entity by ids.
func (m *DeviceMutation) AddDeviceCameraIDs(ids ...uint64) {
	if m.device_camera == nil {
		m.device_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		m.device_camera[ids[i]] = struct{}{}
	}
}

// ClearDeviceCamera clears the "device_camera" edge to the DeviceCamera entity.
func (m *DeviceMutation) ClearDeviceCamera() {
	m.cleareddevice_camera = true
}

// DeviceCameraCleared reports if the "device_camera" edge to the DeviceCamera entity was cleared.
func (m *DeviceMutation) DeviceCameraCleared() bool {
	return m.cleareddevice_camera
}

// RemoveDeviceCameraIDs removes the "device_camera" edge to the DeviceCamera entity by IDs.
func (m *DeviceMutation) RemoveDeviceCameraIDs(ids ...uint64) {
	if m.removeddevice_camera == nil {
		m.removeddevice_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.device_camera, ids[i])
		m.removeddevice_camera[ids[i]] = struct{}{}
	}
}

// RemovedDeviceCamera returns the removed IDs of the "device_camera" edge to the DeviceCamera entity.
func (m *DeviceMutation) RemovedDeviceCameraIDs() (ids []uint64) {
	for id := range m.removeddevice_camera {
		ids = append(ids, id)
	}
	return
}

// DeviceCameraIDs returns the "device_camera" edge IDs in the mutation.
func (m *DeviceMutation) DeviceCameraIDs() (ids []uint64) {
	for id := range m.device_camera {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceCamera resets all changes to the "device_camera" edge.
func (m *DeviceMutation) ResetDeviceCamera() {
	m.device_camera = nil
	m.cleareddevice_camera = false
	m.removeddevice_camera = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, device.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, device.FieldAccessOrgList)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, device.FieldDisplayName)
	}
	if m._type != nil {
		fields = append(fields, device.FieldType)
	}
	if m.ext_id != nil {
		fields = append(fields, device.FieldExtID)
	}
	if m.serial_no != nil {
		fields = append(fields, device.FieldSerialNo)
	}
	if m.state != nil {
		fields = append(fields, device.FieldState)
	}
	if m.mac != nil {
		fields = append(fields, device.FieldMAC)
	}
	if m.zone_name != nil {
		fields = append(fields, device.FieldZoneName)
	}
	if m.zone_id != nil {
		fields = append(fields, device.FieldZoneID)
	}
	if m.workspace_id != nil {
		fields = append(fields, device.FieldWorkspaceID)
	}
	if m.equip_id != nil {
		fields = append(fields, device.FieldEquipID)
	}
	if m.equip_password != nil {
		fields = append(fields, device.FieldEquipPassword)
	}
	if m.device_info != nil {
		fields = append(fields, device.FieldDeviceInfo)
	}
	if m.model != nil {
		fields = append(fields, device.FieldModel)
	}
	if m.auth_deadline != nil {
		fields = append(fields, device.FieldAuthDeadline)
	}
	if m.activated_at != nil {
		fields = append(fields, device.FieldActivatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldTenantID:
		return m.TenantID()
	case device.FieldAccessOrgList:
		return m.AccessOrgList()
	case device.FieldName:
		return m.Name()
	case device.FieldDisplayName:
		return m.DisplayName()
	case device.FieldType:
		return m.GetType()
	case device.FieldExtID:
		return m.ExtID()
	case device.FieldSerialNo:
		return m.SerialNo()
	case device.FieldState:
		return m.State()
	case device.FieldMAC:
		return m.MAC()
	case device.FieldZoneName:
		return m.ZoneName()
	case device.FieldZoneID:
		return m.ZoneID()
	case device.FieldWorkspaceID:
		return m.WorkspaceID()
	case device.FieldEquipID:
		return m.EquipID()
	case device.FieldEquipPassword:
		return m.EquipPassword()
	case device.FieldDeviceInfo:
		return m.DeviceInfo()
	case device.FieldModel:
		return m.Model()
	case device.FieldAuthDeadline:
		return m.AuthDeadline()
	case device.FieldActivatedAt:
		return m.ActivatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldTenantID:
		return m.OldTenantID(ctx)
	case device.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case device.FieldType:
		return m.OldType(ctx)
	case device.FieldExtID:
		return m.OldExtID(ctx)
	case device.FieldSerialNo:
		return m.OldSerialNo(ctx)
	case device.FieldState:
		return m.OldState(ctx)
	case device.FieldMAC:
		return m.OldMAC(ctx)
	case device.FieldZoneName:
		return m.OldZoneName(ctx)
	case device.FieldZoneID:
		return m.OldZoneID(ctx)
	case device.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case device.FieldEquipID:
		return m.OldEquipID(ctx)
	case device.FieldEquipPassword:
		return m.OldEquipPassword(ctx)
	case device.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case device.FieldModel:
		return m.OldModel(ctx)
	case device.FieldAuthDeadline:
		return m.OldAuthDeadline(ctx)
	case device.FieldActivatedAt:
		return m.OldActivatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case device.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case device.FieldType:
		v, ok := value.(biz.EdgeDeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case device.FieldExtID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtID(v)
		return nil
	case device.FieldSerialNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNo(v)
		return nil
	case device.FieldState:
		v, ok := value.(biz.DeviceState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case device.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case device.FieldZoneName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZoneName(v)
		return nil
	case device.FieldZoneID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZoneID(v)
		return nil
	case device.FieldWorkspaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case device.FieldEquipID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipID(v)
		return nil
	case device.FieldEquipPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipPassword(v)
		return nil
	case device.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case device.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case device.FieldAuthDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthDeadline(v)
		return nil
	case device.FieldActivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addauth_deadline != nil {
		fields = append(fields, device.FieldAuthDeadline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldAuthDeadline:
		return m.AddedAuthDeadline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldAuthDeadline:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeletedAt) {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.FieldCleared(device.FieldTenantID) {
		fields = append(fields, device.FieldTenantID)
	}
	if m.FieldCleared(device.FieldAccessOrgList) {
		fields = append(fields, device.FieldAccessOrgList)
	}
	if m.FieldCleared(device.FieldModel) {
		fields = append(fields, device.FieldModel)
	}
	if m.FieldCleared(device.FieldAuthDeadline) {
		fields = append(fields, device.FieldAuthDeadline)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case device.FieldTenantID:
		m.ClearTenantID()
		return nil
	case device.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	case device.FieldModel:
		m.ClearModel()
		return nil
	case device.FieldAuthDeadline:
		m.ClearAuthDeadline()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldTenantID:
		m.ResetTenantID()
		return nil
	case device.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case device.FieldType:
		m.ResetType()
		return nil
	case device.FieldExtID:
		m.ResetExtID()
		return nil
	case device.FieldSerialNo:
		m.ResetSerialNo()
		return nil
	case device.FieldState:
		m.ResetState()
		return nil
	case device.FieldMAC:
		m.ResetMAC()
		return nil
	case device.FieldZoneName:
		m.ResetZoneName()
		return nil
	case device.FieldZoneID:
		m.ResetZoneID()
		return nil
	case device.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case device.FieldEquipID:
		m.ResetEquipID()
		return nil
	case device.FieldEquipPassword:
		m.ResetEquipPassword()
		return nil
	case device.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case device.FieldModel:
		m.ResetModel()
		return nil
	case device.FieldAuthDeadline:
		m.ResetAuthDeadline()
		return nil
	case device.FieldActivatedAt:
		m.ResetActivatedAt()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.camera != nil {
		edges = append(edges, device.EdgeCamera)
	}
	if m.task_device != nil {
		edges = append(edges, device.EdgeTaskDevice)
	}
	if m.device_camera != nil {
		edges = append(edges, device.EdgeDeviceCamera)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeCamera:
		ids := make([]ent.Value, 0, len(m.camera))
		for id := range m.camera {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeTaskDevice:
		ids := make([]ent.Value, 0, len(m.task_device))
		for id := range m.task_device {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceCamera:
		ids := make([]ent.Value, 0, len(m.device_camera))
		for id := range m.device_camera {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcamera != nil {
		edges = append(edges, device.EdgeCamera)
	}
	if m.removedtask_device != nil {
		edges = append(edges, device.EdgeTaskDevice)
	}
	if m.removeddevice_camera != nil {
		edges = append(edges, device.EdgeDeviceCamera)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeCamera:
		ids := make([]ent.Value, 0, len(m.removedcamera))
		for id := range m.removedcamera {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeTaskDevice:
		ids := make([]ent.Value, 0, len(m.removedtask_device))
		for id := range m.removedtask_device {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceCamera:
		ids := make([]ent.Value, 0, len(m.removeddevice_camera))
		for id := range m.removeddevice_camera {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcamera {
		edges = append(edges, device.EdgeCamera)
	}
	if m.clearedtask_device {
		edges = append(edges, device.EdgeTaskDevice)
	}
	if m.cleareddevice_camera {
		edges = append(edges, device.EdgeDeviceCamera)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeCamera:
		return m.clearedcamera
	case device.EdgeTaskDevice:
		return m.clearedtask_device
	case device.EdgeDeviceCamera:
		return m.cleareddevice_camera
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeCamera:
		m.ResetCamera()
		return nil
	case device.EdgeTaskDevice:
		m.ResetTaskDevice()
		return nil
	case device.EdgeDeviceCamera:
		m.ResetDeviceCamera()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceAlgoMutation represents an operation that mutates the DeviceAlgo nodes in the graph.
type DeviceAlgoMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	device_id          *uint64
	adddevice_id       *int64
	algo_group_id      *uint
	addalgo_group_id   *int
	algo_group_name    *string
	algo_group_version *string
	name               *string
	version            *string
	install_time       *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*DeviceAlgo, error)
	predicates         []predicate.DeviceAlgo
}

var _ ent.Mutation = (*DeviceAlgoMutation)(nil)

// devicealgoOption allows management of the mutation configuration using functional options.
type devicealgoOption func(*DeviceAlgoMutation)

// newDeviceAlgoMutation creates new mutation for the DeviceAlgo entity.
func newDeviceAlgoMutation(c config, op Op, opts ...devicealgoOption) *DeviceAlgoMutation {
	m := &DeviceAlgoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceAlgo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceAlgoID sets the ID field of the mutation.
func withDeviceAlgoID(id uint64) devicealgoOption {
	return func(m *DeviceAlgoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceAlgo
		)
		m.oldValue = func(ctx context.Context) (*DeviceAlgo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceAlgo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceAlgo sets the old DeviceAlgo of the mutation.
func withDeviceAlgo(node *DeviceAlgo) devicealgoOption {
	return func(m *DeviceAlgoMutation) {
		m.oldValue = func(context.Context) (*DeviceAlgo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceAlgoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceAlgoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceAlgo entities.
func (m *DeviceAlgoMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceAlgoMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceAlgoMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceAlgo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceAlgoMutation) SetDeviceID(u uint64) {
	m.device_id = &u
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceAlgoMutation) DeviceID() (r uint64, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldDeviceID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds u to the "device_id" field.
func (m *DeviceAlgoMutation) AddDeviceID(u int64) {
	if m.adddevice_id != nil {
		*m.adddevice_id += u
	} else {
		m.adddevice_id = &u
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *DeviceAlgoMutation) AddedDeviceID() (r int64, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceAlgoMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetAlgoGroupID sets the "algo_group_id" field.
func (m *DeviceAlgoMutation) SetAlgoGroupID(u uint) {
	m.algo_group_id = &u
	m.addalgo_group_id = nil
}

// AlgoGroupID returns the value of the "algo_group_id" field in the mutation.
func (m *DeviceAlgoMutation) AlgoGroupID() (r uint, exists bool) {
	v := m.algo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupID returns the old "algo_group_id" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldAlgoGroupID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupID: %w", err)
	}
	return oldValue.AlgoGroupID, nil
}

// AddAlgoGroupID adds u to the "algo_group_id" field.
func (m *DeviceAlgoMutation) AddAlgoGroupID(u int) {
	if m.addalgo_group_id != nil {
		*m.addalgo_group_id += u
	} else {
		m.addalgo_group_id = &u
	}
}

// AddedAlgoGroupID returns the value that was added to the "algo_group_id" field in this mutation.
func (m *DeviceAlgoMutation) AddedAlgoGroupID() (r int, exists bool) {
	v := m.addalgo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAlgoGroupID clears the value of the "algo_group_id" field.
func (m *DeviceAlgoMutation) ClearAlgoGroupID() {
	m.algo_group_id = nil
	m.addalgo_group_id = nil
	m.clearedFields[devicealgo.FieldAlgoGroupID] = struct{}{}
}

// AlgoGroupIDCleared returns if the "algo_group_id" field was cleared in this mutation.
func (m *DeviceAlgoMutation) AlgoGroupIDCleared() bool {
	_, ok := m.clearedFields[devicealgo.FieldAlgoGroupID]
	return ok
}

// ResetAlgoGroupID resets all changes to the "algo_group_id" field.
func (m *DeviceAlgoMutation) ResetAlgoGroupID() {
	m.algo_group_id = nil
	m.addalgo_group_id = nil
	delete(m.clearedFields, devicealgo.FieldAlgoGroupID)
}

// SetAlgoGroupName sets the "algo_group_name" field.
func (m *DeviceAlgoMutation) SetAlgoGroupName(s string) {
	m.algo_group_name = &s
}

// AlgoGroupName returns the value of the "algo_group_name" field in the mutation.
func (m *DeviceAlgoMutation) AlgoGroupName() (r string, exists bool) {
	v := m.algo_group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupName returns the old "algo_group_name" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldAlgoGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupName: %w", err)
	}
	return oldValue.AlgoGroupName, nil
}

// ClearAlgoGroupName clears the value of the "algo_group_name" field.
func (m *DeviceAlgoMutation) ClearAlgoGroupName() {
	m.algo_group_name = nil
	m.clearedFields[devicealgo.FieldAlgoGroupName] = struct{}{}
}

// AlgoGroupNameCleared returns if the "algo_group_name" field was cleared in this mutation.
func (m *DeviceAlgoMutation) AlgoGroupNameCleared() bool {
	_, ok := m.clearedFields[devicealgo.FieldAlgoGroupName]
	return ok
}

// ResetAlgoGroupName resets all changes to the "algo_group_name" field.
func (m *DeviceAlgoMutation) ResetAlgoGroupName() {
	m.algo_group_name = nil
	delete(m.clearedFields, devicealgo.FieldAlgoGroupName)
}

// SetAlgoGroupVersion sets the "algo_group_version" field.
func (m *DeviceAlgoMutation) SetAlgoGroupVersion(s string) {
	m.algo_group_version = &s
}

// AlgoGroupVersion returns the value of the "algo_group_version" field in the mutation.
func (m *DeviceAlgoMutation) AlgoGroupVersion() (r string, exists bool) {
	v := m.algo_group_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupVersion returns the old "algo_group_version" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldAlgoGroupVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupVersion: %w", err)
	}
	return oldValue.AlgoGroupVersion, nil
}

// ClearAlgoGroupVersion clears the value of the "algo_group_version" field.
func (m *DeviceAlgoMutation) ClearAlgoGroupVersion() {
	m.algo_group_version = nil
	m.clearedFields[devicealgo.FieldAlgoGroupVersion] = struct{}{}
}

// AlgoGroupVersionCleared returns if the "algo_group_version" field was cleared in this mutation.
func (m *DeviceAlgoMutation) AlgoGroupVersionCleared() bool {
	_, ok := m.clearedFields[devicealgo.FieldAlgoGroupVersion]
	return ok
}

// ResetAlgoGroupVersion resets all changes to the "algo_group_version" field.
func (m *DeviceAlgoMutation) ResetAlgoGroupVersion() {
	m.algo_group_version = nil
	delete(m.clearedFields, devicealgo.FieldAlgoGroupVersion)
}

// SetName sets the "name" field.
func (m *DeviceAlgoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceAlgoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeviceAlgoMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *DeviceAlgoMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DeviceAlgoMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *DeviceAlgoMutation) ResetVersion() {
	m.version = nil
}

// SetInstallTime sets the "install_time" field.
func (m *DeviceAlgoMutation) SetInstallTime(t time.Time) {
	m.install_time = &t
}

// InstallTime returns the value of the "install_time" field in the mutation.
func (m *DeviceAlgoMutation) InstallTime() (r time.Time, exists bool) {
	v := m.install_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallTime returns the old "install_time" field's value of the DeviceAlgo entity.
// If the DeviceAlgo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceAlgoMutation) OldInstallTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallTime: %w", err)
	}
	return oldValue.InstallTime, nil
}

// ResetInstallTime resets all changes to the "install_time" field.
func (m *DeviceAlgoMutation) ResetInstallTime() {
	m.install_time = nil
}

// Where appends a list predicates to the DeviceAlgoMutation builder.
func (m *DeviceAlgoMutation) Where(ps ...predicate.DeviceAlgo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceAlgoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceAlgoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceAlgo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceAlgoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceAlgoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceAlgo).
func (m *DeviceAlgoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceAlgoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.device_id != nil {
		fields = append(fields, devicealgo.FieldDeviceID)
	}
	if m.algo_group_id != nil {
		fields = append(fields, devicealgo.FieldAlgoGroupID)
	}
	if m.algo_group_name != nil {
		fields = append(fields, devicealgo.FieldAlgoGroupName)
	}
	if m.algo_group_version != nil {
		fields = append(fields, devicealgo.FieldAlgoGroupVersion)
	}
	if m.name != nil {
		fields = append(fields, devicealgo.FieldName)
	}
	if m.version != nil {
		fields = append(fields, devicealgo.FieldVersion)
	}
	if m.install_time != nil {
		fields = append(fields, devicealgo.FieldInstallTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceAlgoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicealgo.FieldDeviceID:
		return m.DeviceID()
	case devicealgo.FieldAlgoGroupID:
		return m.AlgoGroupID()
	case devicealgo.FieldAlgoGroupName:
		return m.AlgoGroupName()
	case devicealgo.FieldAlgoGroupVersion:
		return m.AlgoGroupVersion()
	case devicealgo.FieldName:
		return m.Name()
	case devicealgo.FieldVersion:
		return m.Version()
	case devicealgo.FieldInstallTime:
		return m.InstallTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceAlgoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicealgo.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicealgo.FieldAlgoGroupID:
		return m.OldAlgoGroupID(ctx)
	case devicealgo.FieldAlgoGroupName:
		return m.OldAlgoGroupName(ctx)
	case devicealgo.FieldAlgoGroupVersion:
		return m.OldAlgoGroupVersion(ctx)
	case devicealgo.FieldName:
		return m.OldName(ctx)
	case devicealgo.FieldVersion:
		return m.OldVersion(ctx)
	case devicealgo.FieldInstallTime:
		return m.OldInstallTime(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceAlgo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceAlgoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicealgo.FieldDeviceID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicealgo.FieldAlgoGroupID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupID(v)
		return nil
	case devicealgo.FieldAlgoGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupName(v)
		return nil
	case devicealgo.FieldAlgoGroupVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupVersion(v)
		return nil
	case devicealgo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case devicealgo.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case devicealgo.FieldInstallTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallTime(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceAlgo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceAlgoMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_id != nil {
		fields = append(fields, devicealgo.FieldDeviceID)
	}
	if m.addalgo_group_id != nil {
		fields = append(fields, devicealgo.FieldAlgoGroupID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceAlgoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicealgo.FieldDeviceID:
		return m.AddedDeviceID()
	case devicealgo.FieldAlgoGroupID:
		return m.AddedAlgoGroupID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceAlgoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicealgo.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	case devicealgo.FieldAlgoGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlgoGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceAlgo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceAlgoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicealgo.FieldAlgoGroupID) {
		fields = append(fields, devicealgo.FieldAlgoGroupID)
	}
	if m.FieldCleared(devicealgo.FieldAlgoGroupName) {
		fields = append(fields, devicealgo.FieldAlgoGroupName)
	}
	if m.FieldCleared(devicealgo.FieldAlgoGroupVersion) {
		fields = append(fields, devicealgo.FieldAlgoGroupVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceAlgoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceAlgoMutation) ClearField(name string) error {
	switch name {
	case devicealgo.FieldAlgoGroupID:
		m.ClearAlgoGroupID()
		return nil
	case devicealgo.FieldAlgoGroupName:
		m.ClearAlgoGroupName()
		return nil
	case devicealgo.FieldAlgoGroupVersion:
		m.ClearAlgoGroupVersion()
		return nil
	}
	return fmt.Errorf("unknown DeviceAlgo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceAlgoMutation) ResetField(name string) error {
	switch name {
	case devicealgo.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicealgo.FieldAlgoGroupID:
		m.ResetAlgoGroupID()
		return nil
	case devicealgo.FieldAlgoGroupName:
		m.ResetAlgoGroupName()
		return nil
	case devicealgo.FieldAlgoGroupVersion:
		m.ResetAlgoGroupVersion()
		return nil
	case devicealgo.FieldName:
		m.ResetName()
		return nil
	case devicealgo.FieldVersion:
		m.ResetVersion()
		return nil
	case devicealgo.FieldInstallTime:
		m.ResetInstallTime()
		return nil
	}
	return fmt.Errorf("unknown DeviceAlgo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceAlgoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceAlgoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceAlgoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceAlgoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceAlgoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceAlgoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceAlgoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceAlgo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceAlgoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceAlgo edge %s", name)
}

// DeviceCameraMutation represents an operation that mutates the DeviceCamera nodes in the graph.
type DeviceCameraMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	camera        *uint64
	clearedcamera bool
	device        *uint64
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*DeviceCamera, error)
	predicates    []predicate.DeviceCamera
}

var _ ent.Mutation = (*DeviceCameraMutation)(nil)

// devicecameraOption allows management of the mutation configuration using functional options.
type devicecameraOption func(*DeviceCameraMutation)

// newDeviceCameraMutation creates new mutation for the DeviceCamera entity.
func newDeviceCameraMutation(c config, op Op, opts ...devicecameraOption) *DeviceCameraMutation {
	m := &DeviceCameraMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceCameraID sets the ID field of the mutation.
func withDeviceCameraID(id uint64) devicecameraOption {
	return func(m *DeviceCameraMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceCamera
		)
		m.oldValue = func(ctx context.Context) (*DeviceCamera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceCamera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceCamera sets the old DeviceCamera of the mutation.
func withDeviceCamera(node *DeviceCamera) devicecameraOption {
	return func(m *DeviceCameraMutation) {
		m.oldValue = func(context.Context) (*DeviceCamera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceCameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceCameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceCamera entities.
func (m *DeviceCameraMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceCameraMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceCameraMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceCamera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceCameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceCameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceCamera entity.
// If the DeviceCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceCameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceCameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceCameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceCameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceCamera entity.
// If the DeviceCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceCameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceCameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceCameraMutation) SetDeviceID(u uint64) {
	m.device = &u
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceCameraMutation) DeviceID() (r uint64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceCamera entity.
// If the DeviceCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceCameraMutation) OldDeviceID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceCameraMutation) ResetDeviceID() {
	m.device = nil
}

// SetCameraID sets the "camera_id" field.
func (m *DeviceCameraMutation) SetCameraID(u uint64) {
	m.camera = &u
}

// CameraID returns the value of the "camera_id" field in the mutation.
func (m *DeviceCameraMutation) CameraID() (r uint64, exists bool) {
	v := m.camera
	if v == nil {
		return
	}
	return *v, true
}

// OldCameraID returns the old "camera_id" field's value of the DeviceCamera entity.
// If the DeviceCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceCameraMutation) OldCameraID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCameraID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCameraID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCameraID: %w", err)
	}
	return oldValue.CameraID, nil
}

// ResetCameraID resets all changes to the "camera_id" field.
func (m *DeviceCameraMutation) ResetCameraID() {
	m.camera = nil
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *DeviceCameraMutation) ClearCamera() {
	m.clearedcamera = true
	m.clearedFields[devicecamera.FieldCameraID] = struct{}{}
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *DeviceCameraMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *DeviceCameraMutation) CameraIDs() (ids []uint64) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *DeviceCameraMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// ClearDevice clears the "device" edge to the Task entity.
func (m *DeviceCameraMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[devicecamera.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Task entity was cleared.
func (m *DeviceCameraMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceCameraMutation) DeviceIDs() (ids []uint64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceCameraMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceCameraMutation builder.
func (m *DeviceCameraMutation) Where(ps ...predicate.DeviceCamera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceCameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceCameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceCamera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceCameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceCameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceCamera).
func (m *DeviceCameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceCameraMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, devicecamera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicecamera.FieldUpdatedAt)
	}
	if m.device != nil {
		fields = append(fields, devicecamera.FieldDeviceID)
	}
	if m.camera != nil {
		fields = append(fields, devicecamera.FieldCameraID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceCameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicecamera.FieldCreatedAt:
		return m.CreatedAt()
	case devicecamera.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicecamera.FieldDeviceID:
		return m.DeviceID()
	case devicecamera.FieldCameraID:
		return m.CameraID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceCameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicecamera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicecamera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicecamera.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case devicecamera.FieldCameraID:
		return m.OldCameraID(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceCamera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceCameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicecamera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicecamera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicecamera.FieldDeviceID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case devicecamera.FieldCameraID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCameraID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceCamera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceCameraMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceCameraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceCameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceCamera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceCameraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceCameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceCameraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceCamera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceCameraMutation) ResetField(name string) error {
	switch name {
	case devicecamera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicecamera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicecamera.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case devicecamera.FieldCameraID:
		m.ResetCameraID()
		return nil
	}
	return fmt.Errorf("unknown DeviceCamera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceCameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.camera != nil {
		edges = append(edges, devicecamera.EdgeCamera)
	}
	if m.device != nil {
		edges = append(edges, devicecamera.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceCameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicecamera.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case devicecamera.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceCameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceCameraMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceCameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcamera {
		edges = append(edges, devicecamera.EdgeCamera)
	}
	if m.cleareddevice {
		edges = append(edges, devicecamera.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceCameraMutation) EdgeCleared(name string) bool {
	switch name {
	case devicecamera.EdgeCamera:
		return m.clearedcamera
	case devicecamera.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceCameraMutation) ClearEdge(name string) error {
	switch name {
	case devicecamera.EdgeCamera:
		m.ClearCamera()
		return nil
	case devicecamera.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceCamera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceCameraMutation) ResetEdge(name string) error {
	switch name {
	case devicecamera.EdgeCamera:
		m.ResetCamera()
		return nil
	case devicecamera.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceCamera edge %s", name)
}

// DeviceTokenMutation represents an operation that mutates the DeviceToken nodes in the graph.
type DeviceTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token         *string
	device_ext_id *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DeviceToken, error)
	predicates    []predicate.DeviceToken
}

var _ ent.Mutation = (*DeviceTokenMutation)(nil)

// devicetokenOption allows management of the mutation configuration using functional options.
type devicetokenOption func(*DeviceTokenMutation)

// newDeviceTokenMutation creates new mutation for the DeviceToken entity.
func newDeviceTokenMutation(c config, op Op, opts ...devicetokenOption) *DeviceTokenMutation {
	m := &DeviceTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceTokenID sets the ID field of the mutation.
func withDeviceTokenID(id uint64) devicetokenOption {
	return func(m *DeviceTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceToken
		)
		m.oldValue = func(ctx context.Context) (*DeviceToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceToken sets the old DeviceToken of the mutation.
func withDeviceToken(node *DeviceToken) devicetokenOption {
	return func(m *DeviceTokenMutation) {
		m.oldValue = func(context.Context) (*DeviceToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceToken entities.
func (m *DeviceTokenMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceTokenMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceTokenMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[devicetoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[devicetoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, devicetoken.FieldDeletedAt)
}

// SetToken sets the "token" field.
func (m *DeviceTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *DeviceTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *DeviceTokenMutation) ResetToken() {
	m.token = nil
}

// SetDeviceExtID sets the "device_ext_id" field.
func (m *DeviceTokenMutation) SetDeviceExtID(s string) {
	m.device_ext_id = &s
}

// DeviceExtID returns the value of the "device_ext_id" field in the mutation.
func (m *DeviceTokenMutation) DeviceExtID() (r string, exists bool) {
	v := m.device_ext_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceExtID returns the old "device_ext_id" field's value of the DeviceToken entity.
// If the DeviceToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTokenMutation) OldDeviceExtID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceExtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceExtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceExtID: %w", err)
	}
	return oldValue.DeviceExtID, nil
}

// ResetDeviceExtID resets all changes to the "device_ext_id" field.
func (m *DeviceTokenMutation) ResetDeviceExtID() {
	m.device_ext_id = nil
}

// Where appends a list predicates to the DeviceTokenMutation builder.
func (m *DeviceTokenMutation) Where(ps ...predicate.DeviceToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceToken).
func (m *DeviceTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceTokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, devicetoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicetoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicetoken.FieldDeletedAt)
	}
	if m.token != nil {
		fields = append(fields, devicetoken.FieldToken)
	}
	if m.device_ext_id != nil {
		fields = append(fields, devicetoken.FieldDeviceExtID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicetoken.FieldCreatedAt:
		return m.CreatedAt()
	case devicetoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicetoken.FieldDeletedAt:
		return m.DeletedAt()
	case devicetoken.FieldToken:
		return m.Token()
	case devicetoken.FieldDeviceExtID:
		return m.DeviceExtID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicetoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicetoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicetoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicetoken.FieldToken:
		return m.OldToken(ctx)
	case devicetoken.FieldDeviceExtID:
		return m.OldDeviceExtID(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicetoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicetoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicetoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicetoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case devicetoken.FieldDeviceExtID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceExtID(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicetoken.FieldDeletedAt) {
		fields = append(fields, devicetoken.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceTokenMutation) ClearField(name string) error {
	switch name {
	case devicetoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceTokenMutation) ResetField(name string) error {
	switch name {
	case devicetoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicetoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicetoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicetoken.FieldToken:
		m.ResetToken()
		return nil
	case devicetoken.FieldDeviceExtID:
		m.ResetDeviceExtID()
		return nil
	}
	return fmt.Errorf("unknown DeviceToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceToken edge %s", name)
}

// EquipAttrMutation represents an operation that mutates the EquipAttr nodes in the graph.
type EquipAttrMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	attr_key      *string
	attr_value    *string
	extend        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EquipAttr, error)
	predicates    []predicate.EquipAttr
}

var _ ent.Mutation = (*EquipAttrMutation)(nil)

// equipattrOption allows management of the mutation configuration using functional options.
type equipattrOption func(*EquipAttrMutation)

// newEquipAttrMutation creates new mutation for the EquipAttr entity.
func newEquipAttrMutation(c config, op Op, opts ...equipattrOption) *EquipAttrMutation {
	m := &EquipAttrMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipAttr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipAttrID sets the ID field of the mutation.
func withEquipAttrID(id uint64) equipattrOption {
	return func(m *EquipAttrMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipAttr
		)
		m.oldValue = func(ctx context.Context) (*EquipAttr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipAttr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipAttr sets the old EquipAttr of the mutation.
func withEquipAttr(node *EquipAttr) equipattrOption {
	return func(m *EquipAttrMutation) {
		m.oldValue = func(context.Context) (*EquipAttr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipAttrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipAttrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipAttr entities.
func (m *EquipAttrMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipAttrMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipAttrMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipAttr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipAttrMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipAttrMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipAttr entity.
// If the EquipAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipAttrMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipAttrMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipAttrMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipAttrMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipAttr entity.
// If the EquipAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipAttrMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipAttrMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EquipAttrMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EquipAttrMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EquipAttr entity.
// If the EquipAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipAttrMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EquipAttrMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[equipattr.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EquipAttrMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[equipattr.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EquipAttrMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, equipattr.FieldDeletedAt)
}

// SetAttrKey sets the "attr_key" field.
func (m *EquipAttrMutation) SetAttrKey(s string) {
	m.attr_key = &s
}

// AttrKey returns the value of the "attr_key" field in the mutation.
func (m *EquipAttrMutation) AttrKey() (r string, exists bool) {
	v := m.attr_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrKey returns the old "attr_key" field's value of the EquipAttr entity.
// If the EquipAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipAttrMutation) OldAttrKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrKey: %w", err)
	}
	return oldValue.AttrKey, nil
}

// ResetAttrKey resets all changes to the "attr_key" field.
func (m *EquipAttrMutation) ResetAttrKey() {
	m.attr_key = nil
}

// SetAttrValue sets the "attr_value" field.
func (m *EquipAttrMutation) SetAttrValue(s string) {
	m.attr_value = &s
}

// AttrValue returns the value of the "attr_value" field in the mutation.
func (m *EquipAttrMutation) AttrValue() (r string, exists bool) {
	v := m.attr_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrValue returns the old "attr_value" field's value of the EquipAttr entity.
// If the EquipAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipAttrMutation) OldAttrValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrValue: %w", err)
	}
	return oldValue.AttrValue, nil
}

// ResetAttrValue resets all changes to the "attr_value" field.
func (m *EquipAttrMutation) ResetAttrValue() {
	m.attr_value = nil
}

// SetExtend sets the "extend" field.
func (m *EquipAttrMutation) SetExtend(s string) {
	m.extend = &s
}

// Extend returns the value of the "extend" field in the mutation.
func (m *EquipAttrMutation) Extend() (r string, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the EquipAttr entity.
// If the EquipAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipAttrMutation) OldExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *EquipAttrMutation) ResetExtend() {
	m.extend = nil
}

// Where appends a list predicates to the EquipAttrMutation builder.
func (m *EquipAttrMutation) Where(ps ...predicate.EquipAttr) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipAttrMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipAttrMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipAttr, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipAttrMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipAttrMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipAttr).
func (m *EquipAttrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipAttrMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, equipattr.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, equipattr.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, equipattr.FieldDeletedAt)
	}
	if m.attr_key != nil {
		fields = append(fields, equipattr.FieldAttrKey)
	}
	if m.attr_value != nil {
		fields = append(fields, equipattr.FieldAttrValue)
	}
	if m.extend != nil {
		fields = append(fields, equipattr.FieldExtend)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipAttrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipattr.FieldCreatedAt:
		return m.CreatedAt()
	case equipattr.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipattr.FieldDeletedAt:
		return m.DeletedAt()
	case equipattr.FieldAttrKey:
		return m.AttrKey()
	case equipattr.FieldAttrValue:
		return m.AttrValue()
	case equipattr.FieldExtend:
		return m.Extend()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipAttrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipattr.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipattr.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipattr.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case equipattr.FieldAttrKey:
		return m.OldAttrKey(ctx)
	case equipattr.FieldAttrValue:
		return m.OldAttrValue(ctx)
	case equipattr.FieldExtend:
		return m.OldExtend(ctx)
	}
	return nil, fmt.Errorf("unknown EquipAttr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipAttrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipattr.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipattr.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipattr.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case equipattr.FieldAttrKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrKey(v)
		return nil
	case equipattr.FieldAttrValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrValue(v)
		return nil
	case equipattr.FieldExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	}
	return fmt.Errorf("unknown EquipAttr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipAttrMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipAttrMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipAttrMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipAttr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipAttrMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipattr.FieldDeletedAt) {
		fields = append(fields, equipattr.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipAttrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipAttrMutation) ClearField(name string) error {
	switch name {
	case equipattr.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown EquipAttr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipAttrMutation) ResetField(name string) error {
	switch name {
	case equipattr.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipattr.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipattr.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case equipattr.FieldAttrKey:
		m.ResetAttrKey()
		return nil
	case equipattr.FieldAttrValue:
		m.ResetAttrValue()
		return nil
	case equipattr.FieldExtend:
		m.ResetExtend()
		return nil
	}
	return fmt.Errorf("unknown EquipAttr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipAttrMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipAttrMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipAttrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipAttrMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipAttrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipAttrMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipAttrMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EquipAttr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipAttrMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EquipAttr edge %s", name)
}

// EventSubscriptionMutation represents an operation that mutates the EventSubscription nodes in the graph.
type EventSubscriptionMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	box_id        *string
	channel_id    *string
	callback      *string
	template_id   *string
	status        *biz.EventSubStatus
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EventSubscription, error)
	predicates    []predicate.EventSubscription
}

var _ ent.Mutation = (*EventSubscriptionMutation)(nil)

// eventsubscriptionOption allows management of the mutation configuration using functional options.
type eventsubscriptionOption func(*EventSubscriptionMutation)

// newEventSubscriptionMutation creates new mutation for the EventSubscription entity.
func newEventSubscriptionMutation(c config, op Op, opts ...eventsubscriptionOption) *EventSubscriptionMutation {
	m := &EventSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeEventSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventSubscriptionID sets the ID field of the mutation.
func withEventSubscriptionID(id uint64) eventsubscriptionOption {
	return func(m *EventSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *EventSubscription
		)
		m.oldValue = func(ctx context.Context) (*EventSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventSubscription sets the old EventSubscription of the mutation.
func withEventSubscription(node *EventSubscription) eventsubscriptionOption {
	return func(m *EventSubscriptionMutation) {
		m.oldValue = func(context.Context) (*EventSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventSubscription entities.
func (m *EventSubscriptionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventSubscriptionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventSubscriptionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventSubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventSubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventSubscriptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[eventsubscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventSubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[eventsubscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventSubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, eventsubscription.FieldDeletedAt)
}

// SetBoxID sets the "box_id" field.
func (m *EventSubscriptionMutation) SetBoxID(s string) {
	m.box_id = &s
}

// BoxID returns the value of the "box_id" field in the mutation.
func (m *EventSubscriptionMutation) BoxID() (r string, exists bool) {
	v := m.box_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBoxID returns the old "box_id" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldBoxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoxID: %w", err)
	}
	return oldValue.BoxID, nil
}

// ResetBoxID resets all changes to the "box_id" field.
func (m *EventSubscriptionMutation) ResetBoxID() {
	m.box_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *EventSubscriptionMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *EventSubscriptionMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *EventSubscriptionMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetCallback sets the "callback" field.
func (m *EventSubscriptionMutation) SetCallback(s string) {
	m.callback = &s
}

// Callback returns the value of the "callback" field in the mutation.
func (m *EventSubscriptionMutation) Callback() (r string, exists bool) {
	v := m.callback
	if v == nil {
		return
	}
	return *v, true
}

// OldCallback returns the old "callback" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldCallback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallback: %w", err)
	}
	return oldValue.Callback, nil
}

// ResetCallback resets all changes to the "callback" field.
func (m *EventSubscriptionMutation) ResetCallback() {
	m.callback = nil
}

// SetTemplateID sets the "template_id" field.
func (m *EventSubscriptionMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *EventSubscriptionMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *EventSubscriptionMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetStatus sets the "status" field.
func (m *EventSubscriptionMutation) SetStatus(bss biz.EventSubStatus) {
	m.status = &bss
}

// Status returns the value of the "status" field in the mutation.
func (m *EventSubscriptionMutation) Status() (r biz.EventSubStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EventSubscription entity.
// If the EventSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventSubscriptionMutation) OldStatus(ctx context.Context) (v biz.EventSubStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventSubscriptionMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the EventSubscriptionMutation builder.
func (m *EventSubscriptionMutation) Where(ps ...predicate.EventSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventSubscription).
func (m *EventSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, eventsubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, eventsubscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, eventsubscription.FieldDeletedAt)
	}
	if m.box_id != nil {
		fields = append(fields, eventsubscription.FieldBoxID)
	}
	if m.channel_id != nil {
		fields = append(fields, eventsubscription.FieldChannelID)
	}
	if m.callback != nil {
		fields = append(fields, eventsubscription.FieldCallback)
	}
	if m.template_id != nil {
		fields = append(fields, eventsubscription.FieldTemplateID)
	}
	if m.status != nil {
		fields = append(fields, eventsubscription.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventsubscription.FieldCreatedAt:
		return m.CreatedAt()
	case eventsubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case eventsubscription.FieldDeletedAt:
		return m.DeletedAt()
	case eventsubscription.FieldBoxID:
		return m.BoxID()
	case eventsubscription.FieldChannelID:
		return m.ChannelID()
	case eventsubscription.FieldCallback:
		return m.Callback()
	case eventsubscription.FieldTemplateID:
		return m.TemplateID()
	case eventsubscription.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventsubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventsubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case eventsubscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case eventsubscription.FieldBoxID:
		return m.OldBoxID(ctx)
	case eventsubscription.FieldChannelID:
		return m.OldChannelID(ctx)
	case eventsubscription.FieldCallback:
		return m.OldCallback(ctx)
	case eventsubscription.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case eventsubscription.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EventSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventsubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventsubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case eventsubscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case eventsubscription.FieldBoxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoxID(v)
		return nil
	case eventsubscription.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case eventsubscription.FieldCallback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallback(v)
		return nil
	case eventsubscription.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case eventsubscription.FieldStatus:
		v, ok := value.(biz.EventSubStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EventSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventSubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventsubscription.FieldDeletedAt) {
		fields = append(fields, eventsubscription.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventSubscriptionMutation) ClearField(name string) error {
	switch name {
	case eventsubscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown EventSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventSubscriptionMutation) ResetField(name string) error {
	switch name {
	case eventsubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventsubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case eventsubscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case eventsubscription.FieldBoxID:
		m.ResetBoxID()
		return nil
	case eventsubscription.FieldChannelID:
		m.ResetChannelID()
		return nil
	case eventsubscription.FieldCallback:
		m.ResetCallback()
		return nil
	case eventsubscription.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case eventsubscription.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown EventSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventSubscriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventSubscriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventSubscriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EventSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventSubscriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EventSubscription edge %s", name)
}

// FileUploadMutation represents an operation that mutates the FileUpload nodes in the graph.
type FileUploadMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	provider         *string
	file_name        *string
	md5              *string
	total_bytes      *uint64
	addtotal_bytes   *int64
	etag             *string
	key              *string
	upload_id        *string
	status           *string
	_type            *string
	algo_group_id    *uint64
	addalgo_group_id *int64
	meta             *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*FileUpload, error)
	predicates       []predicate.FileUpload
}

var _ ent.Mutation = (*FileUploadMutation)(nil)

// fileuploadOption allows management of the mutation configuration using functional options.
type fileuploadOption func(*FileUploadMutation)

// newFileUploadMutation creates new mutation for the FileUpload entity.
func newFileUploadMutation(c config, op Op, opts ...fileuploadOption) *FileUploadMutation {
	m := &FileUploadMutation{
		config:        c,
		op:            op,
		typ:           TypeFileUpload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileUploadID sets the ID field of the mutation.
func withFileUploadID(id uint64) fileuploadOption {
	return func(m *FileUploadMutation) {
		var (
			err   error
			once  sync.Once
			value *FileUpload
		)
		m.oldValue = func(ctx context.Context) (*FileUpload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileUpload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileUpload sets the old FileUpload of the mutation.
func withFileUpload(node *FileUpload) fileuploadOption {
	return func(m *FileUploadMutation) {
		m.oldValue = func(context.Context) (*FileUpload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileUploadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileUploadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileUpload entities.
func (m *FileUploadMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileUploadMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileUploadMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileUpload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileUploadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileUploadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileUploadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileUploadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileUploadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileUploadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileUploadMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileUploadMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileUploadMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[fileupload.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileUploadMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[fileupload.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileUploadMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, fileupload.FieldDeletedAt)
}

// SetProvider sets the "provider" field.
func (m *FileUploadMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *FileUploadMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *FileUploadMutation) ResetProvider() {
	m.provider = nil
}

// SetFileName sets the "file_name" field.
func (m *FileUploadMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *FileUploadMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *FileUploadMutation) ResetFileName() {
	m.file_name = nil
}

// SetMd5 sets the "md5" field.
func (m *FileUploadMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileUploadMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileUploadMutation) ResetMd5() {
	m.md5 = nil
}

// SetTotalBytes sets the "total_bytes" field.
func (m *FileUploadMutation) SetTotalBytes(u uint64) {
	m.total_bytes = &u
	m.addtotal_bytes = nil
}

// TotalBytes returns the value of the "total_bytes" field in the mutation.
func (m *FileUploadMutation) TotalBytes() (r uint64, exists bool) {
	v := m.total_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBytes returns the old "total_bytes" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldTotalBytes(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBytes: %w", err)
	}
	return oldValue.TotalBytes, nil
}

// AddTotalBytes adds u to the "total_bytes" field.
func (m *FileUploadMutation) AddTotalBytes(u int64) {
	if m.addtotal_bytes != nil {
		*m.addtotal_bytes += u
	} else {
		m.addtotal_bytes = &u
	}
}

// AddedTotalBytes returns the value that was added to the "total_bytes" field in this mutation.
func (m *FileUploadMutation) AddedTotalBytes() (r int64, exists bool) {
	v := m.addtotal_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalBytes resets all changes to the "total_bytes" field.
func (m *FileUploadMutation) ResetTotalBytes() {
	m.total_bytes = nil
	m.addtotal_bytes = nil
}

// SetEtag sets the "etag" field.
func (m *FileUploadMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *FileUploadMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ClearEtag clears the value of the "etag" field.
func (m *FileUploadMutation) ClearEtag() {
	m.etag = nil
	m.clearedFields[fileupload.FieldEtag] = struct{}{}
}

// EtagCleared returns if the "etag" field was cleared in this mutation.
func (m *FileUploadMutation) EtagCleared() bool {
	_, ok := m.clearedFields[fileupload.FieldEtag]
	return ok
}

// ResetEtag resets all changes to the "etag" field.
func (m *FileUploadMutation) ResetEtag() {
	m.etag = nil
	delete(m.clearedFields, fileupload.FieldEtag)
}

// SetKey sets the "key" field.
func (m *FileUploadMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FileUploadMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FileUploadMutation) ResetKey() {
	m.key = nil
}

// SetUploadID sets the "upload_id" field.
func (m *FileUploadMutation) SetUploadID(s string) {
	m.upload_id = &s
}

// UploadID returns the value of the "upload_id" field in the mutation.
func (m *FileUploadMutation) UploadID() (r string, exists bool) {
	v := m.upload_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadID returns the old "upload_id" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldUploadID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadID: %w", err)
	}
	return oldValue.UploadID, nil
}

// ClearUploadID clears the value of the "upload_id" field.
func (m *FileUploadMutation) ClearUploadID() {
	m.upload_id = nil
	m.clearedFields[fileupload.FieldUploadID] = struct{}{}
}

// UploadIDCleared returns if the "upload_id" field was cleared in this mutation.
func (m *FileUploadMutation) UploadIDCleared() bool {
	_, ok := m.clearedFields[fileupload.FieldUploadID]
	return ok
}

// ResetUploadID resets all changes to the "upload_id" field.
func (m *FileUploadMutation) ResetUploadID() {
	m.upload_id = nil
	delete(m.clearedFields, fileupload.FieldUploadID)
}

// SetStatus sets the "status" field.
func (m *FileUploadMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FileUploadMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FileUploadMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *FileUploadMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileUploadMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileUploadMutation) ResetType() {
	m._type = nil
}

// SetAlgoGroupID sets the "algo_group_id" field.
func (m *FileUploadMutation) SetAlgoGroupID(u uint64) {
	m.algo_group_id = &u
	m.addalgo_group_id = nil
}

// AlgoGroupID returns the value of the "algo_group_id" field in the mutation.
func (m *FileUploadMutation) AlgoGroupID() (r uint64, exists bool) {
	v := m.algo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupID returns the old "algo_group_id" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldAlgoGroupID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupID: %w", err)
	}
	return oldValue.AlgoGroupID, nil
}

// AddAlgoGroupID adds u to the "algo_group_id" field.
func (m *FileUploadMutation) AddAlgoGroupID(u int64) {
	if m.addalgo_group_id != nil {
		*m.addalgo_group_id += u
	} else {
		m.addalgo_group_id = &u
	}
}

// AddedAlgoGroupID returns the value that was added to the "algo_group_id" field in this mutation.
func (m *FileUploadMutation) AddedAlgoGroupID() (r int64, exists bool) {
	v := m.addalgo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlgoGroupID resets all changes to the "algo_group_id" field.
func (m *FileUploadMutation) ResetAlgoGroupID() {
	m.algo_group_id = nil
	m.addalgo_group_id = nil
}

// SetMeta sets the "meta" field.
func (m *FileUploadMutation) SetMeta(s string) {
	m.meta = &s
}

// Meta returns the value of the "meta" field in the mutation.
func (m *FileUploadMutation) Meta() (r string, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the FileUpload entity.
// If the FileUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileUploadMutation) OldMeta(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ResetMeta resets all changes to the "meta" field.
func (m *FileUploadMutation) ResetMeta() {
	m.meta = nil
}

// Where appends a list predicates to the FileUploadMutation builder.
func (m *FileUploadMutation) Where(ps ...predicate.FileUpload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileUploadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileUploadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileUpload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileUploadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileUploadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileUpload).
func (m *FileUploadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileUploadMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, fileupload.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fileupload.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, fileupload.FieldDeletedAt)
	}
	if m.provider != nil {
		fields = append(fields, fileupload.FieldProvider)
	}
	if m.file_name != nil {
		fields = append(fields, fileupload.FieldFileName)
	}
	if m.md5 != nil {
		fields = append(fields, fileupload.FieldMd5)
	}
	if m.total_bytes != nil {
		fields = append(fields, fileupload.FieldTotalBytes)
	}
	if m.etag != nil {
		fields = append(fields, fileupload.FieldEtag)
	}
	if m.key != nil {
		fields = append(fields, fileupload.FieldKey)
	}
	if m.upload_id != nil {
		fields = append(fields, fileupload.FieldUploadID)
	}
	if m.status != nil {
		fields = append(fields, fileupload.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, fileupload.FieldType)
	}
	if m.algo_group_id != nil {
		fields = append(fields, fileupload.FieldAlgoGroupID)
	}
	if m.meta != nil {
		fields = append(fields, fileupload.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileUploadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileupload.FieldCreatedAt:
		return m.CreatedAt()
	case fileupload.FieldUpdatedAt:
		return m.UpdatedAt()
	case fileupload.FieldDeletedAt:
		return m.DeletedAt()
	case fileupload.FieldProvider:
		return m.Provider()
	case fileupload.FieldFileName:
		return m.FileName()
	case fileupload.FieldMd5:
		return m.Md5()
	case fileupload.FieldTotalBytes:
		return m.TotalBytes()
	case fileupload.FieldEtag:
		return m.Etag()
	case fileupload.FieldKey:
		return m.Key()
	case fileupload.FieldUploadID:
		return m.UploadID()
	case fileupload.FieldStatus:
		return m.Status()
	case fileupload.FieldType:
		return m.GetType()
	case fileupload.FieldAlgoGroupID:
		return m.AlgoGroupID()
	case fileupload.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileUploadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileupload.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fileupload.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fileupload.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case fileupload.FieldProvider:
		return m.OldProvider(ctx)
	case fileupload.FieldFileName:
		return m.OldFileName(ctx)
	case fileupload.FieldMd5:
		return m.OldMd5(ctx)
	case fileupload.FieldTotalBytes:
		return m.OldTotalBytes(ctx)
	case fileupload.FieldEtag:
		return m.OldEtag(ctx)
	case fileupload.FieldKey:
		return m.OldKey(ctx)
	case fileupload.FieldUploadID:
		return m.OldUploadID(ctx)
	case fileupload.FieldStatus:
		return m.OldStatus(ctx)
	case fileupload.FieldType:
		return m.OldType(ctx)
	case fileupload.FieldAlgoGroupID:
		return m.OldAlgoGroupID(ctx)
	case fileupload.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown FileUpload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileUploadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileupload.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fileupload.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fileupload.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case fileupload.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case fileupload.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case fileupload.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case fileupload.FieldTotalBytes:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBytes(v)
		return nil
	case fileupload.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case fileupload.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case fileupload.FieldUploadID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadID(v)
		return nil
	case fileupload.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case fileupload.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case fileupload.FieldAlgoGroupID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupID(v)
		return nil
	case fileupload.FieldMeta:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown FileUpload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileUploadMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_bytes != nil {
		fields = append(fields, fileupload.FieldTotalBytes)
	}
	if m.addalgo_group_id != nil {
		fields = append(fields, fileupload.FieldAlgoGroupID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileUploadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fileupload.FieldTotalBytes:
		return m.AddedTotalBytes()
	case fileupload.FieldAlgoGroupID:
		return m.AddedAlgoGroupID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileUploadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fileupload.FieldTotalBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalBytes(v)
		return nil
	case fileupload.FieldAlgoGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlgoGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown FileUpload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileUploadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fileupload.FieldDeletedAt) {
		fields = append(fields, fileupload.FieldDeletedAt)
	}
	if m.FieldCleared(fileupload.FieldEtag) {
		fields = append(fields, fileupload.FieldEtag)
	}
	if m.FieldCleared(fileupload.FieldUploadID) {
		fields = append(fields, fileupload.FieldUploadID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileUploadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileUploadMutation) ClearField(name string) error {
	switch name {
	case fileupload.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case fileupload.FieldEtag:
		m.ClearEtag()
		return nil
	case fileupload.FieldUploadID:
		m.ClearUploadID()
		return nil
	}
	return fmt.Errorf("unknown FileUpload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileUploadMutation) ResetField(name string) error {
	switch name {
	case fileupload.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fileupload.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fileupload.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case fileupload.FieldProvider:
		m.ResetProvider()
		return nil
	case fileupload.FieldFileName:
		m.ResetFileName()
		return nil
	case fileupload.FieldMd5:
		m.ResetMd5()
		return nil
	case fileupload.FieldTotalBytes:
		m.ResetTotalBytes()
		return nil
	case fileupload.FieldEtag:
		m.ResetEtag()
		return nil
	case fileupload.FieldKey:
		m.ResetKey()
		return nil
	case fileupload.FieldUploadID:
		m.ResetUploadID()
		return nil
	case fileupload.FieldStatus:
		m.ResetStatus()
		return nil
	case fileupload.FieldType:
		m.ResetType()
		return nil
	case fileupload.FieldAlgoGroupID:
		m.ResetAlgoGroupID()
		return nil
	case fileupload.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown FileUpload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileUploadMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileUploadMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileUploadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileUploadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileUploadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileUploadMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileUploadMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FileUpload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileUploadMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FileUpload edge %s", name)
}

// InformMutation represents an operation that mutates the Inform nodes in the graph.
type InformMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	tenant_id       *string
	access_org_list *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	alarm_name      *string
	alarm_type      *string
	sign_name       *string
	notify_template *string
	template_code   *string
	phone_numbers   *string
	notify_switch   *string
	task_name       *string
	task_id         *uint64
	addtask_id      *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Inform, error)
	predicates      []predicate.Inform
}

var _ ent.Mutation = (*InformMutation)(nil)

// informOption allows management of the mutation configuration using functional options.
type informOption func(*InformMutation)

// newInformMutation creates new mutation for the Inform entity.
func newInformMutation(c config, op Op, opts ...informOption) *InformMutation {
	m := &InformMutation{
		config:        c,
		op:            op,
		typ:           TypeInform,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInformID sets the ID field of the mutation.
func withInformID(id uint64) informOption {
	return func(m *InformMutation) {
		var (
			err   error
			once  sync.Once
			value *Inform
		)
		m.oldValue = func(ctx context.Context) (*Inform, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inform.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInform sets the old Inform of the mutation.
func withInform(node *Inform) informOption {
	return func(m *InformMutation) {
		m.oldValue = func(context.Context) (*Inform, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InformMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InformMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inform entities.
func (m *InformMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InformMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InformMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inform.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *InformMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *InformMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *InformMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[inform.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *InformMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[inform.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *InformMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, inform.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *InformMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *InformMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *InformMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[inform.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *InformMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[inform.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *InformMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, inform.FieldAccessOrgList)
}

// SetCreatedAt sets the "created_at" field.
func (m *InformMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InformMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InformMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[inform.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InformMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[inform.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InformMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, inform.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InformMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InformMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InformMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[inform.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InformMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[inform.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InformMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, inform.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InformMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InformMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InformMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inform.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InformMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inform.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InformMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inform.FieldDeletedAt)
}

// SetAlarmName sets the "alarm_name" field.
func (m *InformMutation) SetAlarmName(s string) {
	m.alarm_name = &s
}

// AlarmName returns the value of the "alarm_name" field in the mutation.
func (m *InformMutation) AlarmName() (r string, exists bool) {
	v := m.alarm_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmName returns the old "alarm_name" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldAlarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmName: %w", err)
	}
	return oldValue.AlarmName, nil
}

// ResetAlarmName resets all changes to the "alarm_name" field.
func (m *InformMutation) ResetAlarmName() {
	m.alarm_name = nil
}

// SetAlarmType sets the "alarm_type" field.
func (m *InformMutation) SetAlarmType(s string) {
	m.alarm_type = &s
}

// AlarmType returns the value of the "alarm_type" field in the mutation.
func (m *InformMutation) AlarmType() (r string, exists bool) {
	v := m.alarm_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmType returns the old "alarm_type" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldAlarmType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmType: %w", err)
	}
	return oldValue.AlarmType, nil
}

// ResetAlarmType resets all changes to the "alarm_type" field.
func (m *InformMutation) ResetAlarmType() {
	m.alarm_type = nil
}

// SetSignName sets the "sign_name" field.
func (m *InformMutation) SetSignName(s string) {
	m.sign_name = &s
}

// SignName returns the value of the "sign_name" field in the mutation.
func (m *InformMutation) SignName() (r string, exists bool) {
	v := m.sign_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSignName returns the old "sign_name" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldSignName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignName: %w", err)
	}
	return oldValue.SignName, nil
}

// ResetSignName resets all changes to the "sign_name" field.
func (m *InformMutation) ResetSignName() {
	m.sign_name = nil
}

// SetNotifyTemplate sets the "notify_template" field.
func (m *InformMutation) SetNotifyTemplate(s string) {
	m.notify_template = &s
}

// NotifyTemplate returns the value of the "notify_template" field in the mutation.
func (m *InformMutation) NotifyTemplate() (r string, exists bool) {
	v := m.notify_template
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTemplate returns the old "notify_template" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldNotifyTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTemplate: %w", err)
	}
	return oldValue.NotifyTemplate, nil
}

// ResetNotifyTemplate resets all changes to the "notify_template" field.
func (m *InformMutation) ResetNotifyTemplate() {
	m.notify_template = nil
}

// SetTemplateCode sets the "template_code" field.
func (m *InformMutation) SetTemplateCode(s string) {
	m.template_code = &s
}

// TemplateCode returns the value of the "template_code" field in the mutation.
func (m *InformMutation) TemplateCode() (r string, exists bool) {
	v := m.template_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateCode returns the old "template_code" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldTemplateCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateCode: %w", err)
	}
	return oldValue.TemplateCode, nil
}

// ResetTemplateCode resets all changes to the "template_code" field.
func (m *InformMutation) ResetTemplateCode() {
	m.template_code = nil
}

// SetPhoneNumbers sets the "phone_numbers" field.
func (m *InformMutation) SetPhoneNumbers(s string) {
	m.phone_numbers = &s
}

// PhoneNumbers returns the value of the "phone_numbers" field in the mutation.
func (m *InformMutation) PhoneNumbers() (r string, exists bool) {
	v := m.phone_numbers
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumbers returns the old "phone_numbers" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldPhoneNumbers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumbers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumbers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumbers: %w", err)
	}
	return oldValue.PhoneNumbers, nil
}

// ResetPhoneNumbers resets all changes to the "phone_numbers" field.
func (m *InformMutation) ResetPhoneNumbers() {
	m.phone_numbers = nil
}

// SetNotifySwitch sets the "notify_switch" field.
func (m *InformMutation) SetNotifySwitch(s string) {
	m.notify_switch = &s
}

// NotifySwitch returns the value of the "notify_switch" field in the mutation.
func (m *InformMutation) NotifySwitch() (r string, exists bool) {
	v := m.notify_switch
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifySwitch returns the old "notify_switch" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldNotifySwitch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifySwitch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifySwitch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifySwitch: %w", err)
	}
	return oldValue.NotifySwitch, nil
}

// ResetNotifySwitch resets all changes to the "notify_switch" field.
func (m *InformMutation) ResetNotifySwitch() {
	m.notify_switch = nil
}

// SetTaskName sets the "task_name" field.
func (m *InformMutation) SetTaskName(s string) {
	m.task_name = &s
}

// TaskName returns the value of the "task_name" field in the mutation.
func (m *InformMutation) TaskName() (r string, exists bool) {
	v := m.task_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskName returns the old "task_name" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldTaskName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskName: %w", err)
	}
	return oldValue.TaskName, nil
}

// ResetTaskName resets all changes to the "task_name" field.
func (m *InformMutation) ResetTaskName() {
	m.task_name = nil
}

// SetTaskID sets the "task_id" field.
func (m *InformMutation) SetTaskID(u uint64) {
	m.task_id = &u
	m.addtask_id = nil
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *InformMutation) TaskID() (r uint64, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the Inform entity.
// If the Inform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformMutation) OldTaskID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// AddTaskID adds u to the "task_id" field.
func (m *InformMutation) AddTaskID(u int64) {
	if m.addtask_id != nil {
		*m.addtask_id += u
	} else {
		m.addtask_id = &u
	}
}

// AddedTaskID returns the value that was added to the "task_id" field in this mutation.
func (m *InformMutation) AddedTaskID() (r int64, exists bool) {
	v := m.addtask_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *InformMutation) ResetTaskID() {
	m.task_id = nil
	m.addtask_id = nil
}

// Where appends a list predicates to the InformMutation builder.
func (m *InformMutation) Where(ps ...predicate.Inform) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InformMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InformMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inform, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InformMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InformMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inform).
func (m *InformMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InformMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.tenant_id != nil {
		fields = append(fields, inform.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, inform.FieldAccessOrgList)
	}
	if m.created_at != nil {
		fields = append(fields, inform.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inform.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inform.FieldDeletedAt)
	}
	if m.alarm_name != nil {
		fields = append(fields, inform.FieldAlarmName)
	}
	if m.alarm_type != nil {
		fields = append(fields, inform.FieldAlarmType)
	}
	if m.sign_name != nil {
		fields = append(fields, inform.FieldSignName)
	}
	if m.notify_template != nil {
		fields = append(fields, inform.FieldNotifyTemplate)
	}
	if m.template_code != nil {
		fields = append(fields, inform.FieldTemplateCode)
	}
	if m.phone_numbers != nil {
		fields = append(fields, inform.FieldPhoneNumbers)
	}
	if m.notify_switch != nil {
		fields = append(fields, inform.FieldNotifySwitch)
	}
	if m.task_name != nil {
		fields = append(fields, inform.FieldTaskName)
	}
	if m.task_id != nil {
		fields = append(fields, inform.FieldTaskID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InformMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inform.FieldTenantID:
		return m.TenantID()
	case inform.FieldAccessOrgList:
		return m.AccessOrgList()
	case inform.FieldCreatedAt:
		return m.CreatedAt()
	case inform.FieldUpdatedAt:
		return m.UpdatedAt()
	case inform.FieldDeletedAt:
		return m.DeletedAt()
	case inform.FieldAlarmName:
		return m.AlarmName()
	case inform.FieldAlarmType:
		return m.AlarmType()
	case inform.FieldSignName:
		return m.SignName()
	case inform.FieldNotifyTemplate:
		return m.NotifyTemplate()
	case inform.FieldTemplateCode:
		return m.TemplateCode()
	case inform.FieldPhoneNumbers:
		return m.PhoneNumbers()
	case inform.FieldNotifySwitch:
		return m.NotifySwitch()
	case inform.FieldTaskName:
		return m.TaskName()
	case inform.FieldTaskID:
		return m.TaskID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InformMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inform.FieldTenantID:
		return m.OldTenantID(ctx)
	case inform.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case inform.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inform.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inform.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inform.FieldAlarmName:
		return m.OldAlarmName(ctx)
	case inform.FieldAlarmType:
		return m.OldAlarmType(ctx)
	case inform.FieldSignName:
		return m.OldSignName(ctx)
	case inform.FieldNotifyTemplate:
		return m.OldNotifyTemplate(ctx)
	case inform.FieldTemplateCode:
		return m.OldTemplateCode(ctx)
	case inform.FieldPhoneNumbers:
		return m.OldPhoneNumbers(ctx)
	case inform.FieldNotifySwitch:
		return m.OldNotifySwitch(ctx)
	case inform.FieldTaskName:
		return m.OldTaskName(ctx)
	case inform.FieldTaskID:
		return m.OldTaskID(ctx)
	}
	return nil, fmt.Errorf("unknown Inform field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InformMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inform.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case inform.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case inform.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inform.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inform.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inform.FieldAlarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmName(v)
		return nil
	case inform.FieldAlarmType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmType(v)
		return nil
	case inform.FieldSignName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignName(v)
		return nil
	case inform.FieldNotifyTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTemplate(v)
		return nil
	case inform.FieldTemplateCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateCode(v)
		return nil
	case inform.FieldPhoneNumbers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumbers(v)
		return nil
	case inform.FieldNotifySwitch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifySwitch(v)
		return nil
	case inform.FieldTaskName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskName(v)
		return nil
	case inform.FieldTaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	}
	return fmt.Errorf("unknown Inform field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InformMutation) AddedFields() []string {
	var fields []string
	if m.addtask_id != nil {
		fields = append(fields, inform.FieldTaskID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InformMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inform.FieldTaskID:
		return m.AddedTaskID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InformMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inform.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskID(v)
		return nil
	}
	return fmt.Errorf("unknown Inform numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InformMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inform.FieldTenantID) {
		fields = append(fields, inform.FieldTenantID)
	}
	if m.FieldCleared(inform.FieldAccessOrgList) {
		fields = append(fields, inform.FieldAccessOrgList)
	}
	if m.FieldCleared(inform.FieldCreatedAt) {
		fields = append(fields, inform.FieldCreatedAt)
	}
	if m.FieldCleared(inform.FieldUpdatedAt) {
		fields = append(fields, inform.FieldUpdatedAt)
	}
	if m.FieldCleared(inform.FieldDeletedAt) {
		fields = append(fields, inform.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InformMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InformMutation) ClearField(name string) error {
	switch name {
	case inform.FieldTenantID:
		m.ClearTenantID()
		return nil
	case inform.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	case inform.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case inform.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case inform.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Inform nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InformMutation) ResetField(name string) error {
	switch name {
	case inform.FieldTenantID:
		m.ResetTenantID()
		return nil
	case inform.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case inform.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inform.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inform.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inform.FieldAlarmName:
		m.ResetAlarmName()
		return nil
	case inform.FieldAlarmType:
		m.ResetAlarmType()
		return nil
	case inform.FieldSignName:
		m.ResetSignName()
		return nil
	case inform.FieldNotifyTemplate:
		m.ResetNotifyTemplate()
		return nil
	case inform.FieldTemplateCode:
		m.ResetTemplateCode()
		return nil
	case inform.FieldPhoneNumbers:
		m.ResetPhoneNumbers()
		return nil
	case inform.FieldNotifySwitch:
		m.ResetNotifySwitch()
		return nil
	case inform.FieldTaskName:
		m.ResetTaskName()
		return nil
	case inform.FieldTaskID:
		m.ResetTaskID()
		return nil
	}
	return fmt.Errorf("unknown Inform field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InformMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InformMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InformMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InformMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InformMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InformMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InformMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Inform unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InformMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Inform edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	parent_id     *uint32
	addparent_id  *int32
	iam_role_id   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Organization, error)
	predicates    []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uint32) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organization.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetParentID sets the "parent_id" field.
func (m *OrganizationMutation) SetParentID(u uint32) {
	m.parent_id = &u
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrganizationMutation) ParentID() (r uint32, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldParentID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds u to the "parent_id" field.
func (m *OrganizationMutation) AddParentID(u int32) {
	if m.addparent_id != nil {
		*m.addparent_id += u
	} else {
		m.addparent_id = &u
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *OrganizationMutation) AddedParentID() (r int32, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrganizationMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetIamRoleID sets the "iam_role_id" field.
func (m *OrganizationMutation) SetIamRoleID(s string) {
	m.iam_role_id = &s
}

// IamRoleID returns the value of the "iam_role_id" field in the mutation.
func (m *OrganizationMutation) IamRoleID() (r string, exists bool) {
	v := m.iam_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIamRoleID returns the old "iam_role_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldIamRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIamRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIamRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIamRoleID: %w", err)
	}
	return oldValue.IamRoleID, nil
}

// ResetIamRoleID resets all changes to the "iam_role_id" field.
func (m *OrganizationMutation) ResetIamRoleID() {
	m.iam_role_id = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.parent_id != nil {
		fields = append(fields, organization.FieldParentID)
	}
	if m.iam_role_id != nil {
		fields = append(fields, organization.FieldIamRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldDeletedAt:
		return m.DeletedAt()
	case organization.FieldName:
		return m.Name()
	case organization.FieldParentID:
		return m.ParentID()
	case organization.FieldIamRoleID:
		return m.IamRoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldParentID:
		return m.OldParentID(ctx)
	case organization.FieldIamRoleID:
		return m.OldIamRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case organization.FieldIamRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIamRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addparent_id != nil {
		fields = append(fields, organization.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldParentID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldDeletedAt) {
		fields = append(fields, organization.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldParentID:
		m.ResetParentID()
		return nil
	case organization.FieldIamRoleID:
		m.ResetIamRoleID()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Organization edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	serial_number *string
	version       *string
	model         *string
	workspace_id  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *SettingMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *SettingMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *SettingMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetVersion sets the "version" field.
func (m *SettingMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *SettingMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *SettingMutation) ResetVersion() {
	m.version = nil
}

// SetModel sets the "model" field.
func (m *SettingMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *SettingMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *SettingMutation) ResetModel() {
	m.model = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *SettingMutation) SetWorkspaceID(s string) {
	m.workspace_id = &s
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *SettingMutation) WorkspaceID() (r string, exists bool) {
	v := m.workspace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldWorkspaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *SettingMutation) ResetWorkspaceID() {
	m.workspace_id = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.serial_number != nil {
		fields = append(fields, setting.FieldSerialNumber)
	}
	if m.version != nil {
		fields = append(fields, setting.FieldVersion)
	}
	if m.model != nil {
		fields = append(fields, setting.FieldModel)
	}
	if m.workspace_id != nil {
		fields = append(fields, setting.FieldWorkspaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldName:
		return m.Name()
	case setting.FieldSerialNumber:
		return m.SerialNumber()
	case setting.FieldVersion:
		return m.Version()
	case setting.FieldModel:
		return m.Model()
	case setting.FieldWorkspaceID:
		return m.WorkspaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case setting.FieldVersion:
		return m.OldVersion(ctx)
	case setting.FieldModel:
		return m.OldModel(ctx)
	case setting.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case setting.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case setting.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case setting.FieldWorkspaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case setting.FieldVersion:
		m.ResetVersion()
		return nil
	case setting.FieldModel:
		m.ResetModel()
		return nil
	case setting.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SignatureMutation represents an operation that mutates the Signature nodes in the graph.
type SignatureMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	box_id        *string
	app_id        *string
	app_secret    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Signature, error)
	predicates    []predicate.Signature
}

var _ ent.Mutation = (*SignatureMutation)(nil)

// signatureOption allows management of the mutation configuration using functional options.
type signatureOption func(*SignatureMutation)

// newSignatureMutation creates new mutation for the Signature entity.
func newSignatureMutation(c config, op Op, opts ...signatureOption) *SignatureMutation {
	m := &SignatureMutation{
		config:        c,
		op:            op,
		typ:           TypeSignature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignatureID sets the ID field of the mutation.
func withSignatureID(id uint64) signatureOption {
	return func(m *SignatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Signature
		)
		m.oldValue = func(ctx context.Context) (*Signature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Signature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignature sets the old Signature of the mutation.
func withSignature(node *Signature) signatureOption {
	return func(m *SignatureMutation) {
		m.oldValue = func(context.Context) (*Signature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Signature entities.
func (m *SignatureMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignatureMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignatureMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Signature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SignatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SignatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Signature entity.
// If the Signature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SignatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SignatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SignatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Signature entity.
// If the Signature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SignatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SignatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SignatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Signature entity.
// If the Signature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignatureMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SignatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[signature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SignatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[signature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SignatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, signature.FieldDeletedAt)
}

// SetBoxID sets the "box_id" field.
func (m *SignatureMutation) SetBoxID(s string) {
	m.box_id = &s
}

// BoxID returns the value of the "box_id" field in the mutation.
func (m *SignatureMutation) BoxID() (r string, exists bool) {
	v := m.box_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBoxID returns the old "box_id" field's value of the Signature entity.
// If the Signature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignatureMutation) OldBoxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoxID: %w", err)
	}
	return oldValue.BoxID, nil
}

// ResetBoxID resets all changes to the "box_id" field.
func (m *SignatureMutation) ResetBoxID() {
	m.box_id = nil
}

// SetAppID sets the "app_id" field.
func (m *SignatureMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SignatureMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Signature entity.
// If the Signature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignatureMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SignatureMutation) ResetAppID() {
	m.app_id = nil
}

// SetAppSecret sets the "app_secret" field.
func (m *SignatureMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *SignatureMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the Signature entity.
// If the Signature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignatureMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *SignatureMutation) ResetAppSecret() {
	m.app_secret = nil
}

// Where appends a list predicates to the SignatureMutation builder.
func (m *SignatureMutation) Where(ps ...predicate.Signature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Signature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Signature).
func (m *SignatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignatureMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, signature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, signature.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, signature.FieldDeletedAt)
	}
	if m.box_id != nil {
		fields = append(fields, signature.FieldBoxID)
	}
	if m.app_id != nil {
		fields = append(fields, signature.FieldAppID)
	}
	if m.app_secret != nil {
		fields = append(fields, signature.FieldAppSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signature.FieldCreatedAt:
		return m.CreatedAt()
	case signature.FieldUpdatedAt:
		return m.UpdatedAt()
	case signature.FieldDeletedAt:
		return m.DeletedAt()
	case signature.FieldBoxID:
		return m.BoxID()
	case signature.FieldAppID:
		return m.AppID()
	case signature.FieldAppSecret:
		return m.AppSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case signature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case signature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case signature.FieldBoxID:
		return m.OldBoxID(ctx)
	case signature.FieldAppID:
		return m.OldAppID(ctx)
	case signature.FieldAppSecret:
		return m.OldAppSecret(ctx)
	}
	return nil, fmt.Errorf("unknown Signature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case signature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case signature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case signature.FieldBoxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoxID(v)
		return nil
	case signature.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case signature.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Signature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Signature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(signature.FieldDeletedAt) {
		fields = append(fields, signature.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignatureMutation) ClearField(name string) error {
	switch name {
	case signature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Signature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignatureMutation) ResetField(name string) error {
	switch name {
	case signature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case signature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case signature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case signature.FieldBoxID:
		m.ResetBoxID()
		return nil
	case signature.FieldAppID:
		m.ResetAppID()
		return nil
	case signature.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	}
	return fmt.Errorf("unknown Signature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignatureMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignatureMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignatureMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Signature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignatureMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Signature edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	tenant_id          *string
	access_org_list    *string
	name               *string
	_type              *biz.TaskType
	algo_interval      *float64
	addalgo_interval   *float64
	algo_extra         *string
	extend             *string
	last_start_time    **sql.NullTime
	status             *biz.TaskStatus
	algo_group_id      *uint
	addalgo_group_id   *int
	parent_id          *string
	is_warn            *uint32
	addis_warn         *int32
	period             *uint32
	addperiod          *int32
	algo_config        *string
	reason             *string
	allow_time_type    *string
	clearedFields      map[string]struct{}
	camera             map[uint64]struct{}
	removedcamera      map[uint64]struct{}
	clearedcamera      bool
	algorithm          *uint64
	clearedalgorithm   bool
	device             *uint64
	cleareddevice      bool
	task_camera        map[uint64]struct{}
	removedtask_camera map[uint64]struct{}
	clearedtask_camera bool
	done               bool
	oldValue           func(context.Context) (*Task, error)
	predicates         []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uint64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[task.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, task.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *TaskMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TaskMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TaskMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[task.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TaskMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[task.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TaskMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, task.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *TaskMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *TaskMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *TaskMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[task.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *TaskMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[task.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *TaskMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, task.FieldAccessOrgList)
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(bt biz.TaskType) {
	m._type = &bt
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r biz.TaskType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v biz.TaskType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetAlgoID sets the "algo_id" field.
func (m *TaskMutation) SetAlgoID(u uint64) {
	m.algorithm = &u
}

// AlgoID returns the value of the "algo_id" field in the mutation.
func (m *TaskMutation) AlgoID() (r uint64, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoID returns the old "algo_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAlgoID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoID: %w", err)
	}
	return oldValue.AlgoID, nil
}

// ResetAlgoID resets all changes to the "algo_id" field.
func (m *TaskMutation) ResetAlgoID() {
	m.algorithm = nil
}

// SetAlgoInterval sets the "algo_interval" field.
func (m *TaskMutation) SetAlgoInterval(f float64) {
	m.algo_interval = &f
	m.addalgo_interval = nil
}

// AlgoInterval returns the value of the "algo_interval" field in the mutation.
func (m *TaskMutation) AlgoInterval() (r float64, exists bool) {
	v := m.algo_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoInterval returns the old "algo_interval" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAlgoInterval(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoInterval: %w", err)
	}
	return oldValue.AlgoInterval, nil
}

// AddAlgoInterval adds f to the "algo_interval" field.
func (m *TaskMutation) AddAlgoInterval(f float64) {
	if m.addalgo_interval != nil {
		*m.addalgo_interval += f
	} else {
		m.addalgo_interval = &f
	}
}

// AddedAlgoInterval returns the value that was added to the "algo_interval" field in this mutation.
func (m *TaskMutation) AddedAlgoInterval() (r float64, exists bool) {
	v := m.addalgo_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlgoInterval resets all changes to the "algo_interval" field.
func (m *TaskMutation) ResetAlgoInterval() {
	m.algo_interval = nil
	m.addalgo_interval = nil
}

// SetAlgoExtra sets the "algo_extra" field.
func (m *TaskMutation) SetAlgoExtra(s string) {
	m.algo_extra = &s
}

// AlgoExtra returns the value of the "algo_extra" field in the mutation.
func (m *TaskMutation) AlgoExtra() (r string, exists bool) {
	v := m.algo_extra
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoExtra returns the old "algo_extra" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAlgoExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoExtra: %w", err)
	}
	return oldValue.AlgoExtra, nil
}

// ResetAlgoExtra resets all changes to the "algo_extra" field.
func (m *TaskMutation) ResetAlgoExtra() {
	m.algo_extra = nil
}

// SetExtend sets the "extend" field.
func (m *TaskMutation) SetExtend(s string) {
	m.extend = &s
}

// Extend returns the value of the "extend" field in the mutation.
func (m *TaskMutation) Extend() (r string, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *TaskMutation) ResetExtend() {
	m.extend = nil
}

// SetDeviceID sets the "device_id" field.
func (m *TaskMutation) SetDeviceID(u uint64) {
	m.device = &u
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *TaskMutation) DeviceID() (r uint64, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeviceID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *TaskMutation) ResetDeviceID() {
	m.device = nil
}

// SetLastStartTime sets the "last_start_time" field.
func (m *TaskMutation) SetLastStartTime(st *sql.NullTime) {
	m.last_start_time = &st
}

// LastStartTime returns the value of the "last_start_time" field in the mutation.
func (m *TaskMutation) LastStartTime() (r *sql.NullTime, exists bool) {
	v := m.last_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStartTime returns the old "last_start_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLastStartTime(ctx context.Context) (v *sql.NullTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStartTime: %w", err)
	}
	return oldValue.LastStartTime, nil
}

// ClearLastStartTime clears the value of the "last_start_time" field.
func (m *TaskMutation) ClearLastStartTime() {
	m.last_start_time = nil
	m.clearedFields[task.FieldLastStartTime] = struct{}{}
}

// LastStartTimeCleared returns if the "last_start_time" field was cleared in this mutation.
func (m *TaskMutation) LastStartTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldLastStartTime]
	return ok
}

// ResetLastStartTime resets all changes to the "last_start_time" field.
func (m *TaskMutation) ResetLastStartTime() {
	m.last_start_time = nil
	delete(m.clearedFields, task.FieldLastStartTime)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(bs biz.TaskStatus) {
	m.status = &bs
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r biz.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v biz.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetAlgoGroupID sets the "algo_group_id" field.
func (m *TaskMutation) SetAlgoGroupID(u uint) {
	m.algo_group_id = &u
	m.addalgo_group_id = nil
}

// AlgoGroupID returns the value of the "algo_group_id" field in the mutation.
func (m *TaskMutation) AlgoGroupID() (r uint, exists bool) {
	v := m.algo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoGroupID returns the old "algo_group_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAlgoGroupID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoGroupID: %w", err)
	}
	return oldValue.AlgoGroupID, nil
}

// AddAlgoGroupID adds u to the "algo_group_id" field.
func (m *TaskMutation) AddAlgoGroupID(u int) {
	if m.addalgo_group_id != nil {
		*m.addalgo_group_id += u
	} else {
		m.addalgo_group_id = &u
	}
}

// AddedAlgoGroupID returns the value that was added to the "algo_group_id" field in this mutation.
func (m *TaskMutation) AddedAlgoGroupID() (r int, exists bool) {
	v := m.addalgo_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlgoGroupID resets all changes to the "algo_group_id" field.
func (m *TaskMutation) ResetAlgoGroupID() {
	m.algo_group_id = nil
	m.addalgo_group_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *TaskMutation) SetParentID(s string) {
	m.parent_id = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TaskMutation) ParentID() (r string, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *TaskMutation) ResetParentID() {
	m.parent_id = nil
}

// SetIsWarn sets the "is_warn" field.
func (m *TaskMutation) SetIsWarn(u uint32) {
	m.is_warn = &u
	m.addis_warn = nil
}

// IsWarn returns the value of the "is_warn" field in the mutation.
func (m *TaskMutation) IsWarn() (r uint32, exists bool) {
	v := m.is_warn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWarn returns the old "is_warn" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsWarn(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWarn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWarn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWarn: %w", err)
	}
	return oldValue.IsWarn, nil
}

// AddIsWarn adds u to the "is_warn" field.
func (m *TaskMutation) AddIsWarn(u int32) {
	if m.addis_warn != nil {
		*m.addis_warn += u
	} else {
		m.addis_warn = &u
	}
}

// AddedIsWarn returns the value that was added to the "is_warn" field in this mutation.
func (m *TaskMutation) AddedIsWarn() (r int32, exists bool) {
	v := m.addis_warn
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsWarn resets all changes to the "is_warn" field.
func (m *TaskMutation) ResetIsWarn() {
	m.is_warn = nil
	m.addis_warn = nil
}

// SetPeriod sets the "period" field.
func (m *TaskMutation) SetPeriod(u uint32) {
	m.period = &u
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *TaskMutation) Period() (r uint32, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPeriod(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds u to the "period" field.
func (m *TaskMutation) AddPeriod(u int32) {
	if m.addperiod != nil {
		*m.addperiod += u
	} else {
		m.addperiod = &u
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *TaskMutation) AddedPeriod() (r int32, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *TaskMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetAlgoConfig sets the "algo_config" field.
func (m *TaskMutation) SetAlgoConfig(s string) {
	m.algo_config = &s
}

// AlgoConfig returns the value of the "algo_config" field in the mutation.
func (m *TaskMutation) AlgoConfig() (r string, exists bool) {
	v := m.algo_config
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoConfig returns the old "algo_config" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAlgoConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoConfig: %w", err)
	}
	return oldValue.AlgoConfig, nil
}

// ClearAlgoConfig clears the value of the "algo_config" field.
func (m *TaskMutation) ClearAlgoConfig() {
	m.algo_config = nil
	m.clearedFields[task.FieldAlgoConfig] = struct{}{}
}

// AlgoConfigCleared returns if the "algo_config" field was cleared in this mutation.
func (m *TaskMutation) AlgoConfigCleared() bool {
	_, ok := m.clearedFields[task.FieldAlgoConfig]
	return ok
}

// ResetAlgoConfig resets all changes to the "algo_config" field.
func (m *TaskMutation) ResetAlgoConfig() {
	m.algo_config = nil
	delete(m.clearedFields, task.FieldAlgoConfig)
}

// SetReason sets the "reason" field.
func (m *TaskMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *TaskMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *TaskMutation) ResetReason() {
	m.reason = nil
}

// SetAllowTimeType sets the "allow_time_type" field.
func (m *TaskMutation) SetAllowTimeType(s string) {
	m.allow_time_type = &s
}

// AllowTimeType returns the value of the "allow_time_type" field in the mutation.
func (m *TaskMutation) AllowTimeType() (r string, exists bool) {
	v := m.allow_time_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowTimeType returns the old "allow_time_type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAllowTimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowTimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowTimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowTimeType: %w", err)
	}
	return oldValue.AllowTimeType, nil
}

// ClearAllowTimeType clears the value of the "allow_time_type" field.
func (m *TaskMutation) ClearAllowTimeType() {
	m.allow_time_type = nil
	m.clearedFields[task.FieldAllowTimeType] = struct{}{}
}

// AllowTimeTypeCleared returns if the "allow_time_type" field was cleared in this mutation.
func (m *TaskMutation) AllowTimeTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldAllowTimeType]
	return ok
}

// ResetAllowTimeType resets all changes to the "allow_time_type" field.
func (m *TaskMutation) ResetAllowTimeType() {
	m.allow_time_type = nil
	delete(m.clearedFields, task.FieldAllowTimeType)
}

// AddCameraIDs adds the "camera" edge to the Camera entity by ids.
func (m *TaskMutation) AddCameraIDs(ids ...uint64) {
	if m.camera == nil {
		m.camera = make(map[uint64]struct{})
	}
	for i := range ids {
		m.camera[ids[i]] = struct{}{}
	}
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *TaskMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *TaskMutation) CameraCleared() bool {
	return m.clearedcamera
}

// RemoveCameraIDs removes the "camera" edge to the Camera entity by IDs.
func (m *TaskMutation) RemoveCameraIDs(ids ...uint64) {
	if m.removedcamera == nil {
		m.removedcamera = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.camera, ids[i])
		m.removedcamera[ids[i]] = struct{}{}
	}
}

// RemovedCamera returns the removed IDs of the "camera" edge to the Camera entity.
func (m *TaskMutation) RemovedCameraIDs() (ids []uint64) {
	for id := range m.removedcamera {
		ids = append(ids, id)
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
func (m *TaskMutation) CameraIDs() (ids []uint64) {
	for id := range m.camera {
		ids = append(ids, id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *TaskMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
	m.removedcamera = nil
}

// SetAlgorithmID sets the "algorithm" edge to the Algorithm entity by id.
func (m *TaskMutation) SetAlgorithmID(id uint64) {
	m.algorithm = &id
}

// ClearAlgorithm clears the "algorithm" edge to the Algorithm entity.
func (m *TaskMutation) ClearAlgorithm() {
	m.clearedalgorithm = true
	m.clearedFields[task.FieldAlgoID] = struct{}{}
}

// AlgorithmCleared reports if the "algorithm" edge to the Algorithm entity was cleared.
func (m *TaskMutation) AlgorithmCleared() bool {
	return m.clearedalgorithm
}

// AlgorithmID returns the "algorithm" edge ID in the mutation.
func (m *TaskMutation) AlgorithmID() (id uint64, exists bool) {
	if m.algorithm != nil {
		return *m.algorithm, true
	}
	return
}

// AlgorithmIDs returns the "algorithm" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlgorithmID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AlgorithmIDs() (ids []uint64) {
	if id := m.algorithm; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlgorithm resets all changes to the "algorithm" edge.
func (m *TaskMutation) ResetAlgorithm() {
	m.algorithm = nil
	m.clearedalgorithm = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *TaskMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[task.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *TaskMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) DeviceIDs() (ids []uint64) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *TaskMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddTaskCameraIDs adds the "task_camera" edge to the TaskCamera entity by ids.
func (m *TaskMutation) AddTaskCameraIDs(ids ...uint64) {
	if m.task_camera == nil {
		m.task_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		m.task_camera[ids[i]] = struct{}{}
	}
}

// ClearTaskCamera clears the "task_camera" edge to the TaskCamera entity.
func (m *TaskMutation) ClearTaskCamera() {
	m.clearedtask_camera = true
}

// TaskCameraCleared reports if the "task_camera" edge to the TaskCamera entity was cleared.
func (m *TaskMutation) TaskCameraCleared() bool {
	return m.clearedtask_camera
}

// RemoveTaskCameraIDs removes the "task_camera" edge to the TaskCamera entity by IDs.
func (m *TaskMutation) RemoveTaskCameraIDs(ids ...uint64) {
	if m.removedtask_camera == nil {
		m.removedtask_camera = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.task_camera, ids[i])
		m.removedtask_camera[ids[i]] = struct{}{}
	}
}

// RemovedTaskCamera returns the removed IDs of the "task_camera" edge to the TaskCamera entity.
func (m *TaskMutation) RemovedTaskCameraIDs() (ids []uint64) {
	for id := range m.removedtask_camera {
		ids = append(ids, id)
	}
	return
}

// TaskCameraIDs returns the "task_camera" edge IDs in the mutation.
func (m *TaskMutation) TaskCameraIDs() (ids []uint64) {
	for id := range m.task_camera {
		ids = append(ids, id)
	}
	return
}

// ResetTaskCamera resets all changes to the "task_camera" edge.
func (m *TaskMutation) ResetTaskCamera() {
	m.task_camera = nil
	m.clearedtask_camera = false
	m.removedtask_camera = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, task.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, task.FieldAccessOrgList)
	}
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.algorithm != nil {
		fields = append(fields, task.FieldAlgoID)
	}
	if m.algo_interval != nil {
		fields = append(fields, task.FieldAlgoInterval)
	}
	if m.algo_extra != nil {
		fields = append(fields, task.FieldAlgoExtra)
	}
	if m.extend != nil {
		fields = append(fields, task.FieldExtend)
	}
	if m.device != nil {
		fields = append(fields, task.FieldDeviceID)
	}
	if m.last_start_time != nil {
		fields = append(fields, task.FieldLastStartTime)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.algo_group_id != nil {
		fields = append(fields, task.FieldAlgoGroupID)
	}
	if m.parent_id != nil {
		fields = append(fields, task.FieldParentID)
	}
	if m.is_warn != nil {
		fields = append(fields, task.FieldIsWarn)
	}
	if m.period != nil {
		fields = append(fields, task.FieldPeriod)
	}
	if m.algo_config != nil {
		fields = append(fields, task.FieldAlgoConfig)
	}
	if m.reason != nil {
		fields = append(fields, task.FieldReason)
	}
	if m.allow_time_type != nil {
		fields = append(fields, task.FieldAllowTimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldDeletedAt:
		return m.DeletedAt()
	case task.FieldTenantID:
		return m.TenantID()
	case task.FieldAccessOrgList:
		return m.AccessOrgList()
	case task.FieldName:
		return m.Name()
	case task.FieldType:
		return m.GetType()
	case task.FieldAlgoID:
		return m.AlgoID()
	case task.FieldAlgoInterval:
		return m.AlgoInterval()
	case task.FieldAlgoExtra:
		return m.AlgoExtra()
	case task.FieldExtend:
		return m.Extend()
	case task.FieldDeviceID:
		return m.DeviceID()
	case task.FieldLastStartTime:
		return m.LastStartTime()
	case task.FieldStatus:
		return m.Status()
	case task.FieldAlgoGroupID:
		return m.AlgoGroupID()
	case task.FieldParentID:
		return m.ParentID()
	case task.FieldIsWarn:
		return m.IsWarn()
	case task.FieldPeriod:
		return m.Period()
	case task.FieldAlgoConfig:
		return m.AlgoConfig()
	case task.FieldReason:
		return m.Reason()
	case task.FieldAllowTimeType:
		return m.AllowTimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case task.FieldTenantID:
		return m.OldTenantID(ctx)
	case task.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldAlgoID:
		return m.OldAlgoID(ctx)
	case task.FieldAlgoInterval:
		return m.OldAlgoInterval(ctx)
	case task.FieldAlgoExtra:
		return m.OldAlgoExtra(ctx)
	case task.FieldExtend:
		return m.OldExtend(ctx)
	case task.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case task.FieldLastStartTime:
		return m.OldLastStartTime(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldAlgoGroupID:
		return m.OldAlgoGroupID(ctx)
	case task.FieldParentID:
		return m.OldParentID(ctx)
	case task.FieldIsWarn:
		return m.OldIsWarn(ctx)
	case task.FieldPeriod:
		return m.OldPeriod(ctx)
	case task.FieldAlgoConfig:
		return m.OldAlgoConfig(ctx)
	case task.FieldReason:
		return m.OldReason(ctx)
	case task.FieldAllowTimeType:
		return m.OldAllowTimeType(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case task.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case task.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldType:
		v, ok := value.(biz.TaskType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldAlgoID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoID(v)
		return nil
	case task.FieldAlgoInterval:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoInterval(v)
		return nil
	case task.FieldAlgoExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoExtra(v)
		return nil
	case task.FieldExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	case task.FieldDeviceID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case task.FieldLastStartTime:
		v, ok := value.(*sql.NullTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStartTime(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(biz.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldAlgoGroupID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoGroupID(v)
		return nil
	case task.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case task.FieldIsWarn:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWarn(v)
		return nil
	case task.FieldPeriod:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case task.FieldAlgoConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoConfig(v)
		return nil
	case task.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case task.FieldAllowTimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowTimeType(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addalgo_interval != nil {
		fields = append(fields, task.FieldAlgoInterval)
	}
	if m.addalgo_group_id != nil {
		fields = append(fields, task.FieldAlgoGroupID)
	}
	if m.addis_warn != nil {
		fields = append(fields, task.FieldIsWarn)
	}
	if m.addperiod != nil {
		fields = append(fields, task.FieldPeriod)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldAlgoInterval:
		return m.AddedAlgoInterval()
	case task.FieldAlgoGroupID:
		return m.AddedAlgoGroupID()
	case task.FieldIsWarn:
		return m.AddedIsWarn()
	case task.FieldPeriod:
		return m.AddedPeriod()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldAlgoInterval:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlgoInterval(v)
		return nil
	case task.FieldAlgoGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlgoGroupID(v)
		return nil
	case task.FieldIsWarn:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsWarn(v)
		return nil
	case task.FieldPeriod:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldDeletedAt) {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.FieldCleared(task.FieldTenantID) {
		fields = append(fields, task.FieldTenantID)
	}
	if m.FieldCleared(task.FieldAccessOrgList) {
		fields = append(fields, task.FieldAccessOrgList)
	}
	if m.FieldCleared(task.FieldLastStartTime) {
		fields = append(fields, task.FieldLastStartTime)
	}
	if m.FieldCleared(task.FieldAlgoConfig) {
		fields = append(fields, task.FieldAlgoConfig)
	}
	if m.FieldCleared(task.FieldAllowTimeType) {
		fields = append(fields, task.FieldAllowTimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case task.FieldTenantID:
		m.ClearTenantID()
		return nil
	case task.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	case task.FieldLastStartTime:
		m.ClearLastStartTime()
		return nil
	case task.FieldAlgoConfig:
		m.ClearAlgoConfig()
		return nil
	case task.FieldAllowTimeType:
		m.ClearAllowTimeType()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case task.FieldTenantID:
		m.ResetTenantID()
		return nil
	case task.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldAlgoID:
		m.ResetAlgoID()
		return nil
	case task.FieldAlgoInterval:
		m.ResetAlgoInterval()
		return nil
	case task.FieldAlgoExtra:
		m.ResetAlgoExtra()
		return nil
	case task.FieldExtend:
		m.ResetExtend()
		return nil
	case task.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case task.FieldLastStartTime:
		m.ResetLastStartTime()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldAlgoGroupID:
		m.ResetAlgoGroupID()
		return nil
	case task.FieldParentID:
		m.ResetParentID()
		return nil
	case task.FieldIsWarn:
		m.ResetIsWarn()
		return nil
	case task.FieldPeriod:
		m.ResetPeriod()
		return nil
	case task.FieldAlgoConfig:
		m.ResetAlgoConfig()
		return nil
	case task.FieldReason:
		m.ResetReason()
		return nil
	case task.FieldAllowTimeType:
		m.ResetAllowTimeType()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.camera != nil {
		edges = append(edges, task.EdgeCamera)
	}
	if m.algorithm != nil {
		edges = append(edges, task.EdgeAlgorithm)
	}
	if m.device != nil {
		edges = append(edges, task.EdgeDevice)
	}
	if m.task_camera != nil {
		edges = append(edges, task.EdgeTaskCamera)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeCamera:
		ids := make([]ent.Value, 0, len(m.camera))
		for id := range m.camera {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeAlgorithm:
		if id := m.algorithm; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeTaskCamera:
		ids := make([]ent.Value, 0, len(m.task_camera))
		for id := range m.task_camera {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcamera != nil {
		edges = append(edges, task.EdgeCamera)
	}
	if m.removedtask_camera != nil {
		edges = append(edges, task.EdgeTaskCamera)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeCamera:
		ids := make([]ent.Value, 0, len(m.removedcamera))
		for id := range m.removedcamera {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskCamera:
		ids := make([]ent.Value, 0, len(m.removedtask_camera))
		for id := range m.removedtask_camera {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcamera {
		edges = append(edges, task.EdgeCamera)
	}
	if m.clearedalgorithm {
		edges = append(edges, task.EdgeAlgorithm)
	}
	if m.cleareddevice {
		edges = append(edges, task.EdgeDevice)
	}
	if m.clearedtask_camera {
		edges = append(edges, task.EdgeTaskCamera)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeCamera:
		return m.clearedcamera
	case task.EdgeAlgorithm:
		return m.clearedalgorithm
	case task.EdgeDevice:
		return m.cleareddevice
	case task.EdgeTaskCamera:
		return m.clearedtask_camera
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeAlgorithm:
		m.ClearAlgorithm()
		return nil
	case task.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeCamera:
		m.ResetCamera()
		return nil
	case task.EdgeAlgorithm:
		m.ResetAlgorithm()
		return nil
	case task.EdgeDevice:
		m.ResetDevice()
		return nil
	case task.EdgeTaskCamera:
		m.ResetTaskCamera()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskCameraMutation represents an operation that mutates the TaskCamera nodes in the graph.
type TaskCameraMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	tenant_id       *string
	access_org_list *string
	multi_img_box   *string
	clearedFields   map[string]struct{}
	camera          *uint64
	clearedcamera   bool
	task            *uint64
	clearedtask     bool
	done            bool
	oldValue        func(context.Context) (*TaskCamera, error)
	predicates      []predicate.TaskCamera
}

var _ ent.Mutation = (*TaskCameraMutation)(nil)

// taskcameraOption allows management of the mutation configuration using functional options.
type taskcameraOption func(*TaskCameraMutation)

// newTaskCameraMutation creates new mutation for the TaskCamera entity.
func newTaskCameraMutation(c config, op Op, opts ...taskcameraOption) *TaskCameraMutation {
	m := &TaskCameraMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskCameraID sets the ID field of the mutation.
func withTaskCameraID(id uint64) taskcameraOption {
	return func(m *TaskCameraMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskCamera
		)
		m.oldValue = func(ctx context.Context) (*TaskCamera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskCamera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskCamera sets the old TaskCamera of the mutation.
func withTaskCamera(node *TaskCamera) taskcameraOption {
	return func(m *TaskCameraMutation) {
		m.oldValue = func(context.Context) (*TaskCamera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskCameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskCameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskCamera entities.
func (m *TaskCameraMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskCameraMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskCameraMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskCamera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskCameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskCameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskCameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskCameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskCameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskCameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TaskCameraMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TaskCameraMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *TaskCameraMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[taskcamera.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *TaskCameraMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[taskcamera.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TaskCameraMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, taskcamera.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *TaskCameraMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *TaskCameraMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *TaskCameraMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[taskcamera.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *TaskCameraMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[taskcamera.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *TaskCameraMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, taskcamera.FieldAccessOrgList)
}

// SetTaskID sets the "task_id" field.
func (m *TaskCameraMutation) SetTaskID(u uint64) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskCameraMutation) TaskID() (r uint64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldTaskID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskCameraMutation) ResetTaskID() {
	m.task = nil
}

// SetCameraID sets the "camera_id" field.
func (m *TaskCameraMutation) SetCameraID(u uint64) {
	m.camera = &u
}

// CameraID returns the value of the "camera_id" field in the mutation.
func (m *TaskCameraMutation) CameraID() (r uint64, exists bool) {
	v := m.camera
	if v == nil {
		return
	}
	return *v, true
}

// OldCameraID returns the old "camera_id" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldCameraID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCameraID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCameraID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCameraID: %w", err)
	}
	return oldValue.CameraID, nil
}

// ResetCameraID resets all changes to the "camera_id" field.
func (m *TaskCameraMutation) ResetCameraID() {
	m.camera = nil
}

// SetMultiImgBox sets the "multi_img_box" field.
func (m *TaskCameraMutation) SetMultiImgBox(s string) {
	m.multi_img_box = &s
}

// MultiImgBox returns the value of the "multi_img_box" field in the mutation.
func (m *TaskCameraMutation) MultiImgBox() (r string, exists bool) {
	v := m.multi_img_box
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiImgBox returns the old "multi_img_box" field's value of the TaskCamera entity.
// If the TaskCamera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCameraMutation) OldMultiImgBox(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiImgBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiImgBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiImgBox: %w", err)
	}
	return oldValue.MultiImgBox, nil
}

// ResetMultiImgBox resets all changes to the "multi_img_box" field.
func (m *TaskCameraMutation) ResetMultiImgBox() {
	m.multi_img_box = nil
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *TaskCameraMutation) ClearCamera() {
	m.clearedcamera = true
	m.clearedFields[taskcamera.FieldCameraID] = struct{}{}
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *TaskCameraMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *TaskCameraMutation) CameraIDs() (ids []uint64) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *TaskCameraMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskCameraMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[taskcamera.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskCameraMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskCameraMutation) TaskIDs() (ids []uint64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskCameraMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the TaskCameraMutation builder.
func (m *TaskCameraMutation) Where(ps ...predicate.TaskCamera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskCameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskCameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskCamera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskCameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskCameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskCamera).
func (m *TaskCameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskCameraMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, taskcamera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskcamera.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, taskcamera.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, taskcamera.FieldAccessOrgList)
	}
	if m.task != nil {
		fields = append(fields, taskcamera.FieldTaskID)
	}
	if m.camera != nil {
		fields = append(fields, taskcamera.FieldCameraID)
	}
	if m.multi_img_box != nil {
		fields = append(fields, taskcamera.FieldMultiImgBox)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskCameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskcamera.FieldCreatedAt:
		return m.CreatedAt()
	case taskcamera.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskcamera.FieldTenantID:
		return m.TenantID()
	case taskcamera.FieldAccessOrgList:
		return m.AccessOrgList()
	case taskcamera.FieldTaskID:
		return m.TaskID()
	case taskcamera.FieldCameraID:
		return m.CameraID()
	case taskcamera.FieldMultiImgBox:
		return m.MultiImgBox()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskCameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskcamera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskcamera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskcamera.FieldTenantID:
		return m.OldTenantID(ctx)
	case taskcamera.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case taskcamera.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskcamera.FieldCameraID:
		return m.OldCameraID(ctx)
	case taskcamera.FieldMultiImgBox:
		return m.OldMultiImgBox(ctx)
	}
	return nil, fmt.Errorf("unknown TaskCamera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskCameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskcamera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskcamera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskcamera.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case taskcamera.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case taskcamera.FieldTaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskcamera.FieldCameraID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCameraID(v)
		return nil
	case taskcamera.FieldMultiImgBox:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiImgBox(v)
		return nil
	}
	return fmt.Errorf("unknown TaskCamera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskCameraMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskCameraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskCameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskCamera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskCameraMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskcamera.FieldTenantID) {
		fields = append(fields, taskcamera.FieldTenantID)
	}
	if m.FieldCleared(taskcamera.FieldAccessOrgList) {
		fields = append(fields, taskcamera.FieldAccessOrgList)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskCameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskCameraMutation) ClearField(name string) error {
	switch name {
	case taskcamera.FieldTenantID:
		m.ClearTenantID()
		return nil
	case taskcamera.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	}
	return fmt.Errorf("unknown TaskCamera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskCameraMutation) ResetField(name string) error {
	switch name {
	case taskcamera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskcamera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskcamera.FieldTenantID:
		m.ResetTenantID()
		return nil
	case taskcamera.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case taskcamera.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskcamera.FieldCameraID:
		m.ResetCameraID()
		return nil
	case taskcamera.FieldMultiImgBox:
		m.ResetMultiImgBox()
		return nil
	}
	return fmt.Errorf("unknown TaskCamera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskCameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.camera != nil {
		edges = append(edges, taskcamera.EdgeCamera)
	}
	if m.task != nil {
		edges = append(edges, taskcamera.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskCameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskcamera.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case taskcamera.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskCameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskCameraMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskCameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcamera {
		edges = append(edges, taskcamera.EdgeCamera)
	}
	if m.clearedtask {
		edges = append(edges, taskcamera.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskCameraMutation) EdgeCleared(name string) bool {
	switch name {
	case taskcamera.EdgeCamera:
		return m.clearedcamera
	case taskcamera.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskCameraMutation) ClearEdge(name string) error {
	switch name {
	case taskcamera.EdgeCamera:
		m.ClearCamera()
		return nil
	case taskcamera.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown TaskCamera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskCameraMutation) ResetEdge(name string) error {
	switch name {
	case taskcamera.EdgeCamera:
		m.ResetCamera()
		return nil
	case taskcamera.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown TaskCamera edge %s", name)
}

// TaskLimitsMutation represents an operation that mutates the TaskLimits nodes in the graph.
type TaskLimitsMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	model            *string
	maxCameraNum     *uint64
	addmaxCameraNum  *int64
	algoNum          *uint64
	addalgoNum       *int64
	maxSubTaskNum    *uint64
	addmaxSubTaskNum *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TaskLimits, error)
	predicates       []predicate.TaskLimits
}

var _ ent.Mutation = (*TaskLimitsMutation)(nil)

// tasklimitsOption allows management of the mutation configuration using functional options.
type tasklimitsOption func(*TaskLimitsMutation)

// newTaskLimitsMutation creates new mutation for the TaskLimits entity.
func newTaskLimitsMutation(c config, op Op, opts ...tasklimitsOption) *TaskLimitsMutation {
	m := &TaskLimitsMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskLimits,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskLimitsID sets the ID field of the mutation.
func withTaskLimitsID(id uint64) tasklimitsOption {
	return func(m *TaskLimitsMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskLimits
		)
		m.oldValue = func(ctx context.Context) (*TaskLimits, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskLimits.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskLimits sets the old TaskLimits of the mutation.
func withTaskLimits(node *TaskLimits) tasklimitsOption {
	return func(m *TaskLimitsMutation) {
		m.oldValue = func(context.Context) (*TaskLimits, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskLimitsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskLimitsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskLimits entities.
func (m *TaskLimitsMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskLimitsMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskLimitsMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskLimits.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskLimitsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskLimitsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskLimitsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskLimitsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskLimitsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskLimitsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskLimitsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskLimitsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskLimitsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tasklimits.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskLimitsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tasklimits.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskLimitsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tasklimits.FieldDeletedAt)
}

// SetModel sets the "model" field.
func (m *TaskLimitsMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *TaskLimitsMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *TaskLimitsMutation) ClearModel() {
	m.model = nil
	m.clearedFields[tasklimits.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *TaskLimitsMutation) ModelCleared() bool {
	_, ok := m.clearedFields[tasklimits.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *TaskLimitsMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, tasklimits.FieldModel)
}

// SetMaxCameraNum sets the "maxCameraNum" field.
func (m *TaskLimitsMutation) SetMaxCameraNum(u uint64) {
	m.maxCameraNum = &u
	m.addmaxCameraNum = nil
}

// MaxCameraNum returns the value of the "maxCameraNum" field in the mutation.
func (m *TaskLimitsMutation) MaxCameraNum() (r uint64, exists bool) {
	v := m.maxCameraNum
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxCameraNum returns the old "maxCameraNum" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldMaxCameraNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxCameraNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxCameraNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxCameraNum: %w", err)
	}
	return oldValue.MaxCameraNum, nil
}

// AddMaxCameraNum adds u to the "maxCameraNum" field.
func (m *TaskLimitsMutation) AddMaxCameraNum(u int64) {
	if m.addmaxCameraNum != nil {
		*m.addmaxCameraNum += u
	} else {
		m.addmaxCameraNum = &u
	}
}

// AddedMaxCameraNum returns the value that was added to the "maxCameraNum" field in this mutation.
func (m *TaskLimitsMutation) AddedMaxCameraNum() (r int64, exists bool) {
	v := m.addmaxCameraNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxCameraNum resets all changes to the "maxCameraNum" field.
func (m *TaskLimitsMutation) ResetMaxCameraNum() {
	m.maxCameraNum = nil
	m.addmaxCameraNum = nil
}

// SetAlgoNum sets the "algoNum" field.
func (m *TaskLimitsMutation) SetAlgoNum(u uint64) {
	m.algoNum = &u
	m.addalgoNum = nil
}

// AlgoNum returns the value of the "algoNum" field in the mutation.
func (m *TaskLimitsMutation) AlgoNum() (r uint64, exists bool) {
	v := m.algoNum
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgoNum returns the old "algoNum" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldAlgoNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgoNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgoNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgoNum: %w", err)
	}
	return oldValue.AlgoNum, nil
}

// AddAlgoNum adds u to the "algoNum" field.
func (m *TaskLimitsMutation) AddAlgoNum(u int64) {
	if m.addalgoNum != nil {
		*m.addalgoNum += u
	} else {
		m.addalgoNum = &u
	}
}

// AddedAlgoNum returns the value that was added to the "algoNum" field in this mutation.
func (m *TaskLimitsMutation) AddedAlgoNum() (r int64, exists bool) {
	v := m.addalgoNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlgoNum resets all changes to the "algoNum" field.
func (m *TaskLimitsMutation) ResetAlgoNum() {
	m.algoNum = nil
	m.addalgoNum = nil
}

// SetMaxSubTaskNum sets the "maxSubTaskNum" field.
func (m *TaskLimitsMutation) SetMaxSubTaskNum(u uint64) {
	m.maxSubTaskNum = &u
	m.addmaxSubTaskNum = nil
}

// MaxSubTaskNum returns the value of the "maxSubTaskNum" field in the mutation.
func (m *TaskLimitsMutation) MaxSubTaskNum() (r uint64, exists bool) {
	v := m.maxSubTaskNum
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSubTaskNum returns the old "maxSubTaskNum" field's value of the TaskLimits entity.
// If the TaskLimits object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLimitsMutation) OldMaxSubTaskNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSubTaskNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSubTaskNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSubTaskNum: %w", err)
	}
	return oldValue.MaxSubTaskNum, nil
}

// AddMaxSubTaskNum adds u to the "maxSubTaskNum" field.
func (m *TaskLimitsMutation) AddMaxSubTaskNum(u int64) {
	if m.addmaxSubTaskNum != nil {
		*m.addmaxSubTaskNum += u
	} else {
		m.addmaxSubTaskNum = &u
	}
}

// AddedMaxSubTaskNum returns the value that was added to the "maxSubTaskNum" field in this mutation.
func (m *TaskLimitsMutation) AddedMaxSubTaskNum() (r int64, exists bool) {
	v := m.addmaxSubTaskNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxSubTaskNum resets all changes to the "maxSubTaskNum" field.
func (m *TaskLimitsMutation) ResetMaxSubTaskNum() {
	m.maxSubTaskNum = nil
	m.addmaxSubTaskNum = nil
}

// Where appends a list predicates to the TaskLimitsMutation builder.
func (m *TaskLimitsMutation) Where(ps ...predicate.TaskLimits) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskLimitsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskLimitsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskLimits, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskLimitsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskLimitsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskLimits).
func (m *TaskLimitsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskLimitsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, tasklimits.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tasklimits.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tasklimits.FieldDeletedAt)
	}
	if m.model != nil {
		fields = append(fields, tasklimits.FieldModel)
	}
	if m.maxCameraNum != nil {
		fields = append(fields, tasklimits.FieldMaxCameraNum)
	}
	if m.algoNum != nil {
		fields = append(fields, tasklimits.FieldAlgoNum)
	}
	if m.maxSubTaskNum != nil {
		fields = append(fields, tasklimits.FieldMaxSubTaskNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskLimitsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasklimits.FieldCreatedAt:
		return m.CreatedAt()
	case tasklimits.FieldUpdatedAt:
		return m.UpdatedAt()
	case tasklimits.FieldDeletedAt:
		return m.DeletedAt()
	case tasklimits.FieldModel:
		return m.Model()
	case tasklimits.FieldMaxCameraNum:
		return m.MaxCameraNum()
	case tasklimits.FieldAlgoNum:
		return m.AlgoNum()
	case tasklimits.FieldMaxSubTaskNum:
		return m.MaxSubTaskNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskLimitsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasklimits.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasklimits.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tasklimits.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tasklimits.FieldModel:
		return m.OldModel(ctx)
	case tasklimits.FieldMaxCameraNum:
		return m.OldMaxCameraNum(ctx)
	case tasklimits.FieldAlgoNum:
		return m.OldAlgoNum(ctx)
	case tasklimits.FieldMaxSubTaskNum:
		return m.OldMaxSubTaskNum(ctx)
	}
	return nil, fmt.Errorf("unknown TaskLimits field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskLimitsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasklimits.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasklimits.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tasklimits.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tasklimits.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case tasklimits.FieldMaxCameraNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxCameraNum(v)
		return nil
	case tasklimits.FieldAlgoNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgoNum(v)
		return nil
	case tasklimits.FieldMaxSubTaskNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSubTaskNum(v)
		return nil
	}
	return fmt.Errorf("unknown TaskLimits field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskLimitsMutation) AddedFields() []string {
	var fields []string
	if m.addmaxCameraNum != nil {
		fields = append(fields, tasklimits.FieldMaxCameraNum)
	}
	if m.addalgoNum != nil {
		fields = append(fields, tasklimits.FieldAlgoNum)
	}
	if m.addmaxSubTaskNum != nil {
		fields = append(fields, tasklimits.FieldMaxSubTaskNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskLimitsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tasklimits.FieldMaxCameraNum:
		return m.AddedMaxCameraNum()
	case tasklimits.FieldAlgoNum:
		return m.AddedAlgoNum()
	case tasklimits.FieldMaxSubTaskNum:
		return m.AddedMaxSubTaskNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskLimitsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tasklimits.FieldMaxCameraNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxCameraNum(v)
		return nil
	case tasklimits.FieldAlgoNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlgoNum(v)
		return nil
	case tasklimits.FieldMaxSubTaskNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxSubTaskNum(v)
		return nil
	}
	return fmt.Errorf("unknown TaskLimits numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskLimitsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tasklimits.FieldDeletedAt) {
		fields = append(fields, tasklimits.FieldDeletedAt)
	}
	if m.FieldCleared(tasklimits.FieldModel) {
		fields = append(fields, tasklimits.FieldModel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskLimitsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskLimitsMutation) ClearField(name string) error {
	switch name {
	case tasklimits.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tasklimits.FieldModel:
		m.ClearModel()
		return nil
	}
	return fmt.Errorf("unknown TaskLimits nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskLimitsMutation) ResetField(name string) error {
	switch name {
	case tasklimits.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasklimits.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tasklimits.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tasklimits.FieldModel:
		m.ResetModel()
		return nil
	case tasklimits.FieldMaxCameraNum:
		m.ResetMaxCameraNum()
		return nil
	case tasklimits.FieldAlgoNum:
		m.ResetAlgoNum()
		return nil
	case tasklimits.FieldMaxSubTaskNum:
		m.ResetMaxSubTaskNum()
		return nil
	}
	return fmt.Errorf("unknown TaskLimits field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskLimitsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskLimitsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskLimitsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskLimitsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskLimitsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskLimitsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskLimitsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskLimits unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskLimitsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskLimits edge %s", name)
}

// UpPlatformMutation represents an operation that mutates the UpPlatform nodes in the graph.
type UpPlatformMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	tenant_id             *string
	access_org_list       *string
	sip_id                *string
	sip_domain            *string
	sip_ip                *string
	sip_port              *int32
	addsip_port           *int32
	sip_user              *string
	sip_password          *string
	description           *string
	heartbeat_interval    *int32
	addheartbeat_interval *int32
	register_interval     *int32
	addregister_interval  *int32
	trans_type            *string
	gb_id                 *string
	cascadestatus         *string
	registration_status   *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*UpPlatform, error)
	predicates            []predicate.UpPlatform
}

var _ ent.Mutation = (*UpPlatformMutation)(nil)

// upplatformOption allows management of the mutation configuration using functional options.
type upplatformOption func(*UpPlatformMutation)

// newUpPlatformMutation creates new mutation for the UpPlatform entity.
func newUpPlatformMutation(c config, op Op, opts ...upplatformOption) *UpPlatformMutation {
	m := &UpPlatformMutation{
		config:        c,
		op:            op,
		typ:           TypeUpPlatform,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpPlatformID sets the ID field of the mutation.
func withUpPlatformID(id int) upplatformOption {
	return func(m *UpPlatformMutation) {
		var (
			err   error
			once  sync.Once
			value *UpPlatform
		)
		m.oldValue = func(ctx context.Context) (*UpPlatform, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpPlatform.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpPlatform sets the old UpPlatform of the mutation.
func withUpPlatform(node *UpPlatform) upplatformOption {
	return func(m *UpPlatformMutation) {
		m.oldValue = func(context.Context) (*UpPlatform, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpPlatformMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpPlatformMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpPlatformMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpPlatformMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpPlatform.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UpPlatformMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UpPlatformMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *UpPlatformMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[upplatform.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *UpPlatformMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[upplatform.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UpPlatformMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, upplatform.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *UpPlatformMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *UpPlatformMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *UpPlatformMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[upplatform.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *UpPlatformMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[upplatform.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *UpPlatformMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, upplatform.FieldAccessOrgList)
}

// SetSipID sets the "sip_id" field.
func (m *UpPlatformMutation) SetSipID(s string) {
	m.sip_id = &s
}

// SipID returns the value of the "sip_id" field in the mutation.
func (m *UpPlatformMutation) SipID() (r string, exists bool) {
	v := m.sip_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSipID returns the old "sip_id" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldSipID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipID: %w", err)
	}
	return oldValue.SipID, nil
}

// ResetSipID resets all changes to the "sip_id" field.
func (m *UpPlatformMutation) ResetSipID() {
	m.sip_id = nil
}

// SetSipDomain sets the "sip_domain" field.
func (m *UpPlatformMutation) SetSipDomain(s string) {
	m.sip_domain = &s
}

// SipDomain returns the value of the "sip_domain" field in the mutation.
func (m *UpPlatformMutation) SipDomain() (r string, exists bool) {
	v := m.sip_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldSipDomain returns the old "sip_domain" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldSipDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipDomain: %w", err)
	}
	return oldValue.SipDomain, nil
}

// ResetSipDomain resets all changes to the "sip_domain" field.
func (m *UpPlatformMutation) ResetSipDomain() {
	m.sip_domain = nil
}

// SetSipIP sets the "sip_ip" field.
func (m *UpPlatformMutation) SetSipIP(s string) {
	m.sip_ip = &s
}

// SipIP returns the value of the "sip_ip" field in the mutation.
func (m *UpPlatformMutation) SipIP() (r string, exists bool) {
	v := m.sip_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldSipIP returns the old "sip_ip" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldSipIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipIP: %w", err)
	}
	return oldValue.SipIP, nil
}

// ResetSipIP resets all changes to the "sip_ip" field.
func (m *UpPlatformMutation) ResetSipIP() {
	m.sip_ip = nil
}

// SetSipPort sets the "sip_port" field.
func (m *UpPlatformMutation) SetSipPort(i int32) {
	m.sip_port = &i
	m.addsip_port = nil
}

// SipPort returns the value of the "sip_port" field in the mutation.
func (m *UpPlatformMutation) SipPort() (r int32, exists bool) {
	v := m.sip_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSipPort returns the old "sip_port" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldSipPort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipPort: %w", err)
	}
	return oldValue.SipPort, nil
}

// AddSipPort adds i to the "sip_port" field.
func (m *UpPlatformMutation) AddSipPort(i int32) {
	if m.addsip_port != nil {
		*m.addsip_port += i
	} else {
		m.addsip_port = &i
	}
}

// AddedSipPort returns the value that was added to the "sip_port" field in this mutation.
func (m *UpPlatformMutation) AddedSipPort() (r int32, exists bool) {
	v := m.addsip_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetSipPort resets all changes to the "sip_port" field.
func (m *UpPlatformMutation) ResetSipPort() {
	m.sip_port = nil
	m.addsip_port = nil
}

// SetSipUser sets the "sip_user" field.
func (m *UpPlatformMutation) SetSipUser(s string) {
	m.sip_user = &s
}

// SipUser returns the value of the "sip_user" field in the mutation.
func (m *UpPlatformMutation) SipUser() (r string, exists bool) {
	v := m.sip_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSipUser returns the old "sip_user" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldSipUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipUser: %w", err)
	}
	return oldValue.SipUser, nil
}

// ResetSipUser resets all changes to the "sip_user" field.
func (m *UpPlatformMutation) ResetSipUser() {
	m.sip_user = nil
}

// SetSipPassword sets the "sip_password" field.
func (m *UpPlatformMutation) SetSipPassword(s string) {
	m.sip_password = &s
}

// SipPassword returns the value of the "sip_password" field in the mutation.
func (m *UpPlatformMutation) SipPassword() (r string, exists bool) {
	v := m.sip_password
	if v == nil {
		return
	}
	return *v, true
}

// OldSipPassword returns the old "sip_password" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldSipPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSipPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSipPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSipPassword: %w", err)
	}
	return oldValue.SipPassword, nil
}

// ResetSipPassword resets all changes to the "sip_password" field.
func (m *UpPlatformMutation) ResetSipPassword() {
	m.sip_password = nil
}

// SetDescription sets the "description" field.
func (m *UpPlatformMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpPlatformMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UpPlatformMutation) ResetDescription() {
	m.description = nil
}

// SetHeartbeatInterval sets the "heartbeat_interval" field.
func (m *UpPlatformMutation) SetHeartbeatInterval(i int32) {
	m.heartbeat_interval = &i
	m.addheartbeat_interval = nil
}

// HeartbeatInterval returns the value of the "heartbeat_interval" field in the mutation.
func (m *UpPlatformMutation) HeartbeatInterval() (r int32, exists bool) {
	v := m.heartbeat_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldHeartbeatInterval returns the old "heartbeat_interval" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldHeartbeatInterval(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeartbeatInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeartbeatInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeartbeatInterval: %w", err)
	}
	return oldValue.HeartbeatInterval, nil
}

// AddHeartbeatInterval adds i to the "heartbeat_interval" field.
func (m *UpPlatformMutation) AddHeartbeatInterval(i int32) {
	if m.addheartbeat_interval != nil {
		*m.addheartbeat_interval += i
	} else {
		m.addheartbeat_interval = &i
	}
}

// AddedHeartbeatInterval returns the value that was added to the "heartbeat_interval" field in this mutation.
func (m *UpPlatformMutation) AddedHeartbeatInterval() (r int32, exists bool) {
	v := m.addheartbeat_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeartbeatInterval resets all changes to the "heartbeat_interval" field.
func (m *UpPlatformMutation) ResetHeartbeatInterval() {
	m.heartbeat_interval = nil
	m.addheartbeat_interval = nil
}

// SetRegisterInterval sets the "register_interval" field.
func (m *UpPlatformMutation) SetRegisterInterval(i int32) {
	m.register_interval = &i
	m.addregister_interval = nil
}

// RegisterInterval returns the value of the "register_interval" field in the mutation.
func (m *UpPlatformMutation) RegisterInterval() (r int32, exists bool) {
	v := m.register_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterInterval returns the old "register_interval" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldRegisterInterval(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterInterval: %w", err)
	}
	return oldValue.RegisterInterval, nil
}

// AddRegisterInterval adds i to the "register_interval" field.
func (m *UpPlatformMutation) AddRegisterInterval(i int32) {
	if m.addregister_interval != nil {
		*m.addregister_interval += i
	} else {
		m.addregister_interval = &i
	}
}

// AddedRegisterInterval returns the value that was added to the "register_interval" field in this mutation.
func (m *UpPlatformMutation) AddedRegisterInterval() (r int32, exists bool) {
	v := m.addregister_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegisterInterval resets all changes to the "register_interval" field.
func (m *UpPlatformMutation) ResetRegisterInterval() {
	m.register_interval = nil
	m.addregister_interval = nil
}

// SetTransType sets the "trans_type" field.
func (m *UpPlatformMutation) SetTransType(s string) {
	m.trans_type = &s
}

// TransType returns the value of the "trans_type" field in the mutation.
func (m *UpPlatformMutation) TransType() (r string, exists bool) {
	v := m.trans_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransType returns the old "trans_type" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldTransType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransType: %w", err)
	}
	return oldValue.TransType, nil
}

// ResetTransType resets all changes to the "trans_type" field.
func (m *UpPlatformMutation) ResetTransType() {
	m.trans_type = nil
}

// SetGBID sets the "gb_id" field.
func (m *UpPlatformMutation) SetGBID(s string) {
	m.gb_id = &s
}

// GBID returns the value of the "gb_id" field in the mutation.
func (m *UpPlatformMutation) GBID() (r string, exists bool) {
	v := m.gb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGBID returns the old "gb_id" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldGBID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGBID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGBID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGBID: %w", err)
	}
	return oldValue.GBID, nil
}

// ResetGBID resets all changes to the "gb_id" field.
func (m *UpPlatformMutation) ResetGBID() {
	m.gb_id = nil
}

// SetCascadestatus sets the "cascadestatus" field.
func (m *UpPlatformMutation) SetCascadestatus(s string) {
	m.cascadestatus = &s
}

// Cascadestatus returns the value of the "cascadestatus" field in the mutation.
func (m *UpPlatformMutation) Cascadestatus() (r string, exists bool) {
	v := m.cascadestatus
	if v == nil {
		return
	}
	return *v, true
}

// OldCascadestatus returns the old "cascadestatus" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldCascadestatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCascadestatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCascadestatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCascadestatus: %w", err)
	}
	return oldValue.Cascadestatus, nil
}

// ResetCascadestatus resets all changes to the "cascadestatus" field.
func (m *UpPlatformMutation) ResetCascadestatus() {
	m.cascadestatus = nil
}

// SetRegistrationStatus sets the "registration_status" field.
func (m *UpPlatformMutation) SetRegistrationStatus(s string) {
	m.registration_status = &s
}

// RegistrationStatus returns the value of the "registration_status" field in the mutation.
func (m *UpPlatformMutation) RegistrationStatus() (r string, exists bool) {
	v := m.registration_status
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationStatus returns the old "registration_status" field's value of the UpPlatform entity.
// If the UpPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpPlatformMutation) OldRegistrationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationStatus: %w", err)
	}
	return oldValue.RegistrationStatus, nil
}

// ResetRegistrationStatus resets all changes to the "registration_status" field.
func (m *UpPlatformMutation) ResetRegistrationStatus() {
	m.registration_status = nil
}

// Where appends a list predicates to the UpPlatformMutation builder.
func (m *UpPlatformMutation) Where(ps ...predicate.UpPlatform) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpPlatformMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpPlatformMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpPlatform, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpPlatformMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpPlatformMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpPlatform).
func (m *UpPlatformMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpPlatformMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.tenant_id != nil {
		fields = append(fields, upplatform.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, upplatform.FieldAccessOrgList)
	}
	if m.sip_id != nil {
		fields = append(fields, upplatform.FieldSipID)
	}
	if m.sip_domain != nil {
		fields = append(fields, upplatform.FieldSipDomain)
	}
	if m.sip_ip != nil {
		fields = append(fields, upplatform.FieldSipIP)
	}
	if m.sip_port != nil {
		fields = append(fields, upplatform.FieldSipPort)
	}
	if m.sip_user != nil {
		fields = append(fields, upplatform.FieldSipUser)
	}
	if m.sip_password != nil {
		fields = append(fields, upplatform.FieldSipPassword)
	}
	if m.description != nil {
		fields = append(fields, upplatform.FieldDescription)
	}
	if m.heartbeat_interval != nil {
		fields = append(fields, upplatform.FieldHeartbeatInterval)
	}
	if m.register_interval != nil {
		fields = append(fields, upplatform.FieldRegisterInterval)
	}
	if m.trans_type != nil {
		fields = append(fields, upplatform.FieldTransType)
	}
	if m.gb_id != nil {
		fields = append(fields, upplatform.FieldGBID)
	}
	if m.cascadestatus != nil {
		fields = append(fields, upplatform.FieldCascadestatus)
	}
	if m.registration_status != nil {
		fields = append(fields, upplatform.FieldRegistrationStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpPlatformMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upplatform.FieldTenantID:
		return m.TenantID()
	case upplatform.FieldAccessOrgList:
		return m.AccessOrgList()
	case upplatform.FieldSipID:
		return m.SipID()
	case upplatform.FieldSipDomain:
		return m.SipDomain()
	case upplatform.FieldSipIP:
		return m.SipIP()
	case upplatform.FieldSipPort:
		return m.SipPort()
	case upplatform.FieldSipUser:
		return m.SipUser()
	case upplatform.FieldSipPassword:
		return m.SipPassword()
	case upplatform.FieldDescription:
		return m.Description()
	case upplatform.FieldHeartbeatInterval:
		return m.HeartbeatInterval()
	case upplatform.FieldRegisterInterval:
		return m.RegisterInterval()
	case upplatform.FieldTransType:
		return m.TransType()
	case upplatform.FieldGBID:
		return m.GBID()
	case upplatform.FieldCascadestatus:
		return m.Cascadestatus()
	case upplatform.FieldRegistrationStatus:
		return m.RegistrationStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpPlatformMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upplatform.FieldTenantID:
		return m.OldTenantID(ctx)
	case upplatform.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case upplatform.FieldSipID:
		return m.OldSipID(ctx)
	case upplatform.FieldSipDomain:
		return m.OldSipDomain(ctx)
	case upplatform.FieldSipIP:
		return m.OldSipIP(ctx)
	case upplatform.FieldSipPort:
		return m.OldSipPort(ctx)
	case upplatform.FieldSipUser:
		return m.OldSipUser(ctx)
	case upplatform.FieldSipPassword:
		return m.OldSipPassword(ctx)
	case upplatform.FieldDescription:
		return m.OldDescription(ctx)
	case upplatform.FieldHeartbeatInterval:
		return m.OldHeartbeatInterval(ctx)
	case upplatform.FieldRegisterInterval:
		return m.OldRegisterInterval(ctx)
	case upplatform.FieldTransType:
		return m.OldTransType(ctx)
	case upplatform.FieldGBID:
		return m.OldGBID(ctx)
	case upplatform.FieldCascadestatus:
		return m.OldCascadestatus(ctx)
	case upplatform.FieldRegistrationStatus:
		return m.OldRegistrationStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UpPlatform field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpPlatformMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upplatform.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case upplatform.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case upplatform.FieldSipID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipID(v)
		return nil
	case upplatform.FieldSipDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipDomain(v)
		return nil
	case upplatform.FieldSipIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipIP(v)
		return nil
	case upplatform.FieldSipPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipPort(v)
		return nil
	case upplatform.FieldSipUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipUser(v)
		return nil
	case upplatform.FieldSipPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSipPassword(v)
		return nil
	case upplatform.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upplatform.FieldHeartbeatInterval:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeartbeatInterval(v)
		return nil
	case upplatform.FieldRegisterInterval:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterInterval(v)
		return nil
	case upplatform.FieldTransType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransType(v)
		return nil
	case upplatform.FieldGBID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGBID(v)
		return nil
	case upplatform.FieldCascadestatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCascadestatus(v)
		return nil
	case upplatform.FieldRegistrationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UpPlatform field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpPlatformMutation) AddedFields() []string {
	var fields []string
	if m.addsip_port != nil {
		fields = append(fields, upplatform.FieldSipPort)
	}
	if m.addheartbeat_interval != nil {
		fields = append(fields, upplatform.FieldHeartbeatInterval)
	}
	if m.addregister_interval != nil {
		fields = append(fields, upplatform.FieldRegisterInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpPlatformMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upplatform.FieldSipPort:
		return m.AddedSipPort()
	case upplatform.FieldHeartbeatInterval:
		return m.AddedHeartbeatInterval()
	case upplatform.FieldRegisterInterval:
		return m.AddedRegisterInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpPlatformMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upplatform.FieldSipPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSipPort(v)
		return nil
	case upplatform.FieldHeartbeatInterval:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeartbeatInterval(v)
		return nil
	case upplatform.FieldRegisterInterval:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterInterval(v)
		return nil
	}
	return fmt.Errorf("unknown UpPlatform numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpPlatformMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upplatform.FieldTenantID) {
		fields = append(fields, upplatform.FieldTenantID)
	}
	if m.FieldCleared(upplatform.FieldAccessOrgList) {
		fields = append(fields, upplatform.FieldAccessOrgList)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpPlatformMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpPlatformMutation) ClearField(name string) error {
	switch name {
	case upplatform.FieldTenantID:
		m.ClearTenantID()
		return nil
	case upplatform.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	}
	return fmt.Errorf("unknown UpPlatform nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpPlatformMutation) ResetField(name string) error {
	switch name {
	case upplatform.FieldTenantID:
		m.ResetTenantID()
		return nil
	case upplatform.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case upplatform.FieldSipID:
		m.ResetSipID()
		return nil
	case upplatform.FieldSipDomain:
		m.ResetSipDomain()
		return nil
	case upplatform.FieldSipIP:
		m.ResetSipIP()
		return nil
	case upplatform.FieldSipPort:
		m.ResetSipPort()
		return nil
	case upplatform.FieldSipUser:
		m.ResetSipUser()
		return nil
	case upplatform.FieldSipPassword:
		m.ResetSipPassword()
		return nil
	case upplatform.FieldDescription:
		m.ResetDescription()
		return nil
	case upplatform.FieldHeartbeatInterval:
		m.ResetHeartbeatInterval()
		return nil
	case upplatform.FieldRegisterInterval:
		m.ResetRegisterInterval()
		return nil
	case upplatform.FieldTransType:
		m.ResetTransType()
		return nil
	case upplatform.FieldGBID:
		m.ResetGBID()
		return nil
	case upplatform.FieldCascadestatus:
		m.ResetCascadestatus()
		return nil
	case upplatform.FieldRegistrationStatus:
		m.ResetRegistrationStatus()
		return nil
	}
	return fmt.Errorf("unknown UpPlatform field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpPlatformMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpPlatformMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpPlatformMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpPlatformMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpPlatformMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpPlatformMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpPlatformMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpPlatform unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpPlatformMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpPlatform edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// WarnPushMutation represents an operation that mutates the WarnPush nodes in the graph.
type WarnPushMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	tenant_id       *string
	access_org_list *string
	name            *string
	_type           *biz.WarnPushType
	url             *string
	remark          *string
	mode            *biz.WarnPushMode
	status          *biz.WarnPushStatus
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*WarnPush, error)
	predicates      []predicate.WarnPush
}

var _ ent.Mutation = (*WarnPushMutation)(nil)

// warnpushOption allows management of the mutation configuration using functional options.
type warnpushOption func(*WarnPushMutation)

// newWarnPushMutation creates new mutation for the WarnPush entity.
func newWarnPushMutation(c config, op Op, opts ...warnpushOption) *WarnPushMutation {
	m := &WarnPushMutation{
		config:        c,
		op:            op,
		typ:           TypeWarnPush,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarnPushID sets the ID field of the mutation.
func withWarnPushID(id uint64) warnpushOption {
	return func(m *WarnPushMutation) {
		var (
			err   error
			once  sync.Once
			value *WarnPush
		)
		m.oldValue = func(ctx context.Context) (*WarnPush, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WarnPush.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarnPush sets the old WarnPush of the mutation.
func withWarnPush(node *WarnPush) warnpushOption {
	return func(m *WarnPushMutation) {
		m.oldValue = func(context.Context) (*WarnPush, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarnPushMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarnPushMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WarnPush entities.
func (m *WarnPushMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarnPushMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarnPushMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WarnPush.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WarnPushMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WarnPushMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WarnPushMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WarnPushMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WarnPushMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WarnPushMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WarnPushMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WarnPushMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WarnPushMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[warnpush.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WarnPushMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[warnpush.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WarnPushMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, warnpush.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *WarnPushMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WarnPushMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *WarnPushMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[warnpush.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *WarnPushMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[warnpush.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WarnPushMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, warnpush.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *WarnPushMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *WarnPushMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *WarnPushMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[warnpush.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *WarnPushMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[warnpush.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *WarnPushMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, warnpush.FieldAccessOrgList)
}

// SetName sets the "name" field.
func (m *WarnPushMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WarnPushMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WarnPushMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *WarnPushMutation) SetType(bpt biz.WarnPushType) {
	m._type = &bpt
}

// GetType returns the value of the "type" field in the mutation.
func (m *WarnPushMutation) GetType() (r biz.WarnPushType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldType(ctx context.Context) (v biz.WarnPushType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WarnPushMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *WarnPushMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WarnPushMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WarnPushMutation) ResetURL() {
	m.url = nil
}

// SetRemark sets the "remark" field.
func (m *WarnPushMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *WarnPushMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *WarnPushMutation) ResetRemark() {
	m.remark = nil
}

// SetMode sets the "mode" field.
func (m *WarnPushMutation) SetMode(bpm biz.WarnPushMode) {
	m.mode = &bpm
}

// Mode returns the value of the "mode" field in the mutation.
func (m *WarnPushMutation) Mode() (r biz.WarnPushMode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldMode(ctx context.Context) (v biz.WarnPushMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *WarnPushMutation) ResetMode() {
	m.mode = nil
}

// SetStatus sets the "status" field.
func (m *WarnPushMutation) SetStatus(bps biz.WarnPushStatus) {
	m.status = &bps
}

// Status returns the value of the "status" field in the mutation.
func (m *WarnPushMutation) Status() (r biz.WarnPushStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WarnPush entity.
// If the WarnPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushMutation) OldStatus(ctx context.Context) (v biz.WarnPushStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WarnPushMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the WarnPushMutation builder.
func (m *WarnPushMutation) Where(ps ...predicate.WarnPush) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarnPushMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarnPushMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WarnPush, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarnPushMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarnPushMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WarnPush).
func (m *WarnPushMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarnPushMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, warnpush.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, warnpush.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, warnpush.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, warnpush.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, warnpush.FieldAccessOrgList)
	}
	if m.name != nil {
		fields = append(fields, warnpush.FieldName)
	}
	if m._type != nil {
		fields = append(fields, warnpush.FieldType)
	}
	if m.url != nil {
		fields = append(fields, warnpush.FieldURL)
	}
	if m.remark != nil {
		fields = append(fields, warnpush.FieldRemark)
	}
	if m.mode != nil {
		fields = append(fields, warnpush.FieldMode)
	}
	if m.status != nil {
		fields = append(fields, warnpush.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarnPushMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warnpush.FieldCreatedAt:
		return m.CreatedAt()
	case warnpush.FieldUpdatedAt:
		return m.UpdatedAt()
	case warnpush.FieldDeletedAt:
		return m.DeletedAt()
	case warnpush.FieldTenantID:
		return m.TenantID()
	case warnpush.FieldAccessOrgList:
		return m.AccessOrgList()
	case warnpush.FieldName:
		return m.Name()
	case warnpush.FieldType:
		return m.GetType()
	case warnpush.FieldURL:
		return m.URL()
	case warnpush.FieldRemark:
		return m.Remark()
	case warnpush.FieldMode:
		return m.Mode()
	case warnpush.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarnPushMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warnpush.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warnpush.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warnpush.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case warnpush.FieldTenantID:
		return m.OldTenantID(ctx)
	case warnpush.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case warnpush.FieldName:
		return m.OldName(ctx)
	case warnpush.FieldType:
		return m.OldType(ctx)
	case warnpush.FieldURL:
		return m.OldURL(ctx)
	case warnpush.FieldRemark:
		return m.OldRemark(ctx)
	case warnpush.FieldMode:
		return m.OldMode(ctx)
	case warnpush.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown WarnPush field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarnPushMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warnpush.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warnpush.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warnpush.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case warnpush.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case warnpush.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case warnpush.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case warnpush.FieldType:
		v, ok := value.(biz.WarnPushType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case warnpush.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case warnpush.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case warnpush.FieldMode:
		v, ok := value.(biz.WarnPushMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case warnpush.FieldStatus:
		v, ok := value.(biz.WarnPushStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown WarnPush field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarnPushMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarnPushMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarnPushMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WarnPush numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarnPushMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warnpush.FieldDeletedAt) {
		fields = append(fields, warnpush.FieldDeletedAt)
	}
	if m.FieldCleared(warnpush.FieldTenantID) {
		fields = append(fields, warnpush.FieldTenantID)
	}
	if m.FieldCleared(warnpush.FieldAccessOrgList) {
		fields = append(fields, warnpush.FieldAccessOrgList)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarnPushMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarnPushMutation) ClearField(name string) error {
	switch name {
	case warnpush.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case warnpush.FieldTenantID:
		m.ClearTenantID()
		return nil
	case warnpush.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	}
	return fmt.Errorf("unknown WarnPush nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarnPushMutation) ResetField(name string) error {
	switch name {
	case warnpush.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warnpush.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warnpush.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case warnpush.FieldTenantID:
		m.ResetTenantID()
		return nil
	case warnpush.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case warnpush.FieldName:
		m.ResetName()
		return nil
	case warnpush.FieldType:
		m.ResetType()
		return nil
	case warnpush.FieldURL:
		m.ResetURL()
		return nil
	case warnpush.FieldRemark:
		m.ResetRemark()
		return nil
	case warnpush.FieldMode:
		m.ResetMode()
		return nil
	case warnpush.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown WarnPush field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarnPushMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarnPushMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarnPushMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarnPushMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarnPushMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarnPushMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarnPushMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WarnPush unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarnPushMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WarnPush edge %s", name)
}

// WarnPushLogMutation represents an operation that mutates the WarnPushLog nodes in the graph.
type WarnPushLogMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	tenant_id       *string
	access_org_list *string
	param           *string
	remark          *string
	status          *biz.WarnPushLogStatus
	clearedFields   map[string]struct{}
	push            *uint64
	clearedpush     bool
	done            bool
	oldValue        func(context.Context) (*WarnPushLog, error)
	predicates      []predicate.WarnPushLog
}

var _ ent.Mutation = (*WarnPushLogMutation)(nil)

// warnpushlogOption allows management of the mutation configuration using functional options.
type warnpushlogOption func(*WarnPushLogMutation)

// newWarnPushLogMutation creates new mutation for the WarnPushLog entity.
func newWarnPushLogMutation(c config, op Op, opts ...warnpushlogOption) *WarnPushLogMutation {
	m := &WarnPushLogMutation{
		config:        c,
		op:            op,
		typ:           TypeWarnPushLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarnPushLogID sets the ID field of the mutation.
func withWarnPushLogID(id uint64) warnpushlogOption {
	return func(m *WarnPushLogMutation) {
		var (
			err   error
			once  sync.Once
			value *WarnPushLog
		)
		m.oldValue = func(ctx context.Context) (*WarnPushLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WarnPushLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarnPushLog sets the old WarnPushLog of the mutation.
func withWarnPushLog(node *WarnPushLog) warnpushlogOption {
	return func(m *WarnPushLogMutation) {
		m.oldValue = func(context.Context) (*WarnPushLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarnPushLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarnPushLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WarnPushLog entities.
func (m *WarnPushLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarnPushLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarnPushLogMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WarnPushLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WarnPushLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WarnPushLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WarnPushLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WarnPushLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WarnPushLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WarnPushLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WarnPushLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WarnPushLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WarnPushLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[warnpushlog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WarnPushLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[warnpushlog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WarnPushLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, warnpushlog.FieldDeletedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *WarnPushLogMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WarnPushLogMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *WarnPushLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[warnpushlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *WarnPushLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[warnpushlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WarnPushLogMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, warnpushlog.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *WarnPushLogMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *WarnPushLogMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *WarnPushLogMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[warnpushlog.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *WarnPushLogMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[warnpushlog.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *WarnPushLogMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, warnpushlog.FieldAccessOrgList)
}

// SetPushID sets the "push_id" field.
func (m *WarnPushLogMutation) SetPushID(u uint64) {
	m.push = &u
}

// PushID returns the value of the "push_id" field in the mutation.
func (m *WarnPushLogMutation) PushID() (r uint64, exists bool) {
	v := m.push
	if v == nil {
		return
	}
	return *v, true
}

// OldPushID returns the old "push_id" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldPushID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushID: %w", err)
	}
	return oldValue.PushID, nil
}

// ResetPushID resets all changes to the "push_id" field.
func (m *WarnPushLogMutation) ResetPushID() {
	m.push = nil
}

// SetParam sets the "param" field.
func (m *WarnPushLogMutation) SetParam(s string) {
	m.param = &s
}

// Param returns the value of the "param" field in the mutation.
func (m *WarnPushLogMutation) Param() (r string, exists bool) {
	v := m.param
	if v == nil {
		return
	}
	return *v, true
}

// OldParam returns the old "param" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldParam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParam: %w", err)
	}
	return oldValue.Param, nil
}

// ResetParam resets all changes to the "param" field.
func (m *WarnPushLogMutation) ResetParam() {
	m.param = nil
}

// SetRemark sets the "remark" field.
func (m *WarnPushLogMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *WarnPushLogMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *WarnPushLogMutation) ResetRemark() {
	m.remark = nil
}

// SetStatus sets the "status" field.
func (m *WarnPushLogMutation) SetStatus(bpls biz.WarnPushLogStatus) {
	m.status = &bpls
}

// Status returns the value of the "status" field in the mutation.
func (m *WarnPushLogMutation) Status() (r biz.WarnPushLogStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WarnPushLog entity.
// If the WarnPushLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnPushLogMutation) OldStatus(ctx context.Context) (v biz.WarnPushLogStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WarnPushLogMutation) ResetStatus() {
	m.status = nil
}

// ClearPush clears the "push" edge to the WarnPush entity.
func (m *WarnPushLogMutation) ClearPush() {
	m.clearedpush = true
	m.clearedFields[warnpushlog.FieldPushID] = struct{}{}
}

// PushCleared reports if the "push" edge to the WarnPush entity was cleared.
func (m *WarnPushLogMutation) PushCleared() bool {
	return m.clearedpush
}

// PushIDs returns the "push" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PushID instead. It exists only for internal usage by the builders.
func (m *WarnPushLogMutation) PushIDs() (ids []uint64) {
	if id := m.push; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPush resets all changes to the "push" edge.
func (m *WarnPushLogMutation) ResetPush() {
	m.push = nil
	m.clearedpush = false
}

// Where appends a list predicates to the WarnPushLogMutation builder.
func (m *WarnPushLogMutation) Where(ps ...predicate.WarnPushLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarnPushLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarnPushLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WarnPushLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarnPushLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarnPushLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WarnPushLog).
func (m *WarnPushLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarnPushLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, warnpushlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, warnpushlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, warnpushlog.FieldDeletedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, warnpushlog.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, warnpushlog.FieldAccessOrgList)
	}
	if m.push != nil {
		fields = append(fields, warnpushlog.FieldPushID)
	}
	if m.param != nil {
		fields = append(fields, warnpushlog.FieldParam)
	}
	if m.remark != nil {
		fields = append(fields, warnpushlog.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, warnpushlog.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarnPushLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warnpushlog.FieldCreatedAt:
		return m.CreatedAt()
	case warnpushlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case warnpushlog.FieldDeletedAt:
		return m.DeletedAt()
	case warnpushlog.FieldTenantID:
		return m.TenantID()
	case warnpushlog.FieldAccessOrgList:
		return m.AccessOrgList()
	case warnpushlog.FieldPushID:
		return m.PushID()
	case warnpushlog.FieldParam:
		return m.Param()
	case warnpushlog.FieldRemark:
		return m.Remark()
	case warnpushlog.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarnPushLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warnpushlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warnpushlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warnpushlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case warnpushlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case warnpushlog.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case warnpushlog.FieldPushID:
		return m.OldPushID(ctx)
	case warnpushlog.FieldParam:
		return m.OldParam(ctx)
	case warnpushlog.FieldRemark:
		return m.OldRemark(ctx)
	case warnpushlog.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown WarnPushLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarnPushLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warnpushlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warnpushlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warnpushlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case warnpushlog.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case warnpushlog.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case warnpushlog.FieldPushID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushID(v)
		return nil
	case warnpushlog.FieldParam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParam(v)
		return nil
	case warnpushlog.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case warnpushlog.FieldStatus:
		v, ok := value.(biz.WarnPushLogStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown WarnPushLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarnPushLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarnPushLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarnPushLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WarnPushLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarnPushLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warnpushlog.FieldDeletedAt) {
		fields = append(fields, warnpushlog.FieldDeletedAt)
	}
	if m.FieldCleared(warnpushlog.FieldTenantID) {
		fields = append(fields, warnpushlog.FieldTenantID)
	}
	if m.FieldCleared(warnpushlog.FieldAccessOrgList) {
		fields = append(fields, warnpushlog.FieldAccessOrgList)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarnPushLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarnPushLogMutation) ClearField(name string) error {
	switch name {
	case warnpushlog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case warnpushlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case warnpushlog.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	}
	return fmt.Errorf("unknown WarnPushLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarnPushLogMutation) ResetField(name string) error {
	switch name {
	case warnpushlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warnpushlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warnpushlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case warnpushlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case warnpushlog.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case warnpushlog.FieldPushID:
		m.ResetPushID()
		return nil
	case warnpushlog.FieldParam:
		m.ResetParam()
		return nil
	case warnpushlog.FieldRemark:
		m.ResetRemark()
		return nil
	case warnpushlog.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown WarnPushLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarnPushLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.push != nil {
		edges = append(edges, warnpushlog.EdgePush)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarnPushLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case warnpushlog.EdgePush:
		if id := m.push; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarnPushLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarnPushLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarnPushLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpush {
		edges = append(edges, warnpushlog.EdgePush)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarnPushLogMutation) EdgeCleared(name string) bool {
	switch name {
	case warnpushlog.EdgePush:
		return m.clearedpush
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarnPushLogMutation) ClearEdge(name string) error {
	switch name {
	case warnpushlog.EdgePush:
		m.ClearPush()
		return nil
	}
	return fmt.Errorf("unknown WarnPushLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarnPushLogMutation) ResetEdge(name string) error {
	switch name {
	case warnpushlog.EdgePush:
		m.ResetPush()
		return nil
	}
	return fmt.Errorf("unknown WarnPushLog edge %s", name)
}

// WarnSmsErrMutation represents an operation that mutates the WarnSmsErr nodes in the graph.
type WarnSmsErrMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	tenant_id       *string
	access_org_list *string
	app_name        *string
	record_id       *uint64
	addrecord_id    *int64
	error_msg       *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*WarnSmsErr, error)
	predicates      []predicate.WarnSmsErr
}

var _ ent.Mutation = (*WarnSmsErrMutation)(nil)

// warnsmserrOption allows management of the mutation configuration using functional options.
type warnsmserrOption func(*WarnSmsErrMutation)

// newWarnSmsErrMutation creates new mutation for the WarnSmsErr entity.
func newWarnSmsErrMutation(c config, op Op, opts ...warnsmserrOption) *WarnSmsErrMutation {
	m := &WarnSmsErrMutation{
		config:        c,
		op:            op,
		typ:           TypeWarnSmsErr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarnSmsErrID sets the ID field of the mutation.
func withWarnSmsErrID(id uint64) warnsmserrOption {
	return func(m *WarnSmsErrMutation) {
		var (
			err   error
			once  sync.Once
			value *WarnSmsErr
		)
		m.oldValue = func(ctx context.Context) (*WarnSmsErr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WarnSmsErr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarnSmsErr sets the old WarnSmsErr of the mutation.
func withWarnSmsErr(node *WarnSmsErr) warnsmserrOption {
	return func(m *WarnSmsErrMutation) {
		m.oldValue = func(context.Context) (*WarnSmsErr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarnSmsErrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarnSmsErrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WarnSmsErr entities.
func (m *WarnSmsErrMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarnSmsErrMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarnSmsErrMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WarnSmsErr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WarnSmsErrMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WarnSmsErrMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WarnSmsErrMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WarnSmsErrMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WarnSmsErrMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WarnSmsErrMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *WarnSmsErrMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WarnSmsErrMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *WarnSmsErrMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[warnsmserr.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *WarnSmsErrMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[warnsmserr.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WarnSmsErrMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, warnsmserr.FieldTenantID)
}

// SetAccessOrgList sets the "access_org_list" field.
func (m *WarnSmsErrMutation) SetAccessOrgList(s string) {
	m.access_org_list = &s
}

// AccessOrgList returns the value of the "access_org_list" field in the mutation.
func (m *WarnSmsErrMutation) AccessOrgList() (r string, exists bool) {
	v := m.access_org_list
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessOrgList returns the old "access_org_list" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldAccessOrgList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessOrgList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessOrgList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessOrgList: %w", err)
	}
	return oldValue.AccessOrgList, nil
}

// ClearAccessOrgList clears the value of the "access_org_list" field.
func (m *WarnSmsErrMutation) ClearAccessOrgList() {
	m.access_org_list = nil
	m.clearedFields[warnsmserr.FieldAccessOrgList] = struct{}{}
}

// AccessOrgListCleared returns if the "access_org_list" field was cleared in this mutation.
func (m *WarnSmsErrMutation) AccessOrgListCleared() bool {
	_, ok := m.clearedFields[warnsmserr.FieldAccessOrgList]
	return ok
}

// ResetAccessOrgList resets all changes to the "access_org_list" field.
func (m *WarnSmsErrMutation) ResetAccessOrgList() {
	m.access_org_list = nil
	delete(m.clearedFields, warnsmserr.FieldAccessOrgList)
}

// SetAppName sets the "app_name" field.
func (m *WarnSmsErrMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *WarnSmsErrMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *WarnSmsErrMutation) ResetAppName() {
	m.app_name = nil
}

// SetRecordID sets the "record_id" field.
func (m *WarnSmsErrMutation) SetRecordID(u uint64) {
	m.record_id = &u
	m.addrecord_id = nil
}

// RecordID returns the value of the "record_id" field in the mutation.
func (m *WarnSmsErrMutation) RecordID() (r uint64, exists bool) {
	v := m.record_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordID returns the old "record_id" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldRecordID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordID: %w", err)
	}
	return oldValue.RecordID, nil
}

// AddRecordID adds u to the "record_id" field.
func (m *WarnSmsErrMutation) AddRecordID(u int64) {
	if m.addrecord_id != nil {
		*m.addrecord_id += u
	} else {
		m.addrecord_id = &u
	}
}

// AddedRecordID returns the value that was added to the "record_id" field in this mutation.
func (m *WarnSmsErrMutation) AddedRecordID() (r int64, exists bool) {
	v := m.addrecord_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecordID resets all changes to the "record_id" field.
func (m *WarnSmsErrMutation) ResetRecordID() {
	m.record_id = nil
	m.addrecord_id = nil
}

// SetErrorMsg sets the "error_msg" field.
func (m *WarnSmsErrMutation) SetErrorMsg(s string) {
	m.error_msg = &s
}

// ErrorMsg returns the value of the "error_msg" field in the mutation.
func (m *WarnSmsErrMutation) ErrorMsg() (r string, exists bool) {
	v := m.error_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMsg returns the old "error_msg" field's value of the WarnSmsErr entity.
// If the WarnSmsErr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarnSmsErrMutation) OldErrorMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMsg: %w", err)
	}
	return oldValue.ErrorMsg, nil
}

// ResetErrorMsg resets all changes to the "error_msg" field.
func (m *WarnSmsErrMutation) ResetErrorMsg() {
	m.error_msg = nil
}

// Where appends a list predicates to the WarnSmsErrMutation builder.
func (m *WarnSmsErrMutation) Where(ps ...predicate.WarnSmsErr) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarnSmsErrMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarnSmsErrMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WarnSmsErr, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarnSmsErrMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarnSmsErrMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WarnSmsErr).
func (m *WarnSmsErrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarnSmsErrMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, warnsmserr.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, warnsmserr.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, warnsmserr.FieldTenantID)
	}
	if m.access_org_list != nil {
		fields = append(fields, warnsmserr.FieldAccessOrgList)
	}
	if m.app_name != nil {
		fields = append(fields, warnsmserr.FieldAppName)
	}
	if m.record_id != nil {
		fields = append(fields, warnsmserr.FieldRecordID)
	}
	if m.error_msg != nil {
		fields = append(fields, warnsmserr.FieldErrorMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarnSmsErrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warnsmserr.FieldCreatedAt:
		return m.CreatedAt()
	case warnsmserr.FieldUpdatedAt:
		return m.UpdatedAt()
	case warnsmserr.FieldTenantID:
		return m.TenantID()
	case warnsmserr.FieldAccessOrgList:
		return m.AccessOrgList()
	case warnsmserr.FieldAppName:
		return m.AppName()
	case warnsmserr.FieldRecordID:
		return m.RecordID()
	case warnsmserr.FieldErrorMsg:
		return m.ErrorMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarnSmsErrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warnsmserr.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warnsmserr.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warnsmserr.FieldTenantID:
		return m.OldTenantID(ctx)
	case warnsmserr.FieldAccessOrgList:
		return m.OldAccessOrgList(ctx)
	case warnsmserr.FieldAppName:
		return m.OldAppName(ctx)
	case warnsmserr.FieldRecordID:
		return m.OldRecordID(ctx)
	case warnsmserr.FieldErrorMsg:
		return m.OldErrorMsg(ctx)
	}
	return nil, fmt.Errorf("unknown WarnSmsErr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarnSmsErrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warnsmserr.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warnsmserr.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warnsmserr.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case warnsmserr.FieldAccessOrgList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessOrgList(v)
		return nil
	case warnsmserr.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case warnsmserr.FieldRecordID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordID(v)
		return nil
	case warnsmserr.FieldErrorMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMsg(v)
		return nil
	}
	return fmt.Errorf("unknown WarnSmsErr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarnSmsErrMutation) AddedFields() []string {
	var fields []string
	if m.addrecord_id != nil {
		fields = append(fields, warnsmserr.FieldRecordID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarnSmsErrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case warnsmserr.FieldRecordID:
		return m.AddedRecordID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarnSmsErrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case warnsmserr.FieldRecordID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecordID(v)
		return nil
	}
	return fmt.Errorf("unknown WarnSmsErr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarnSmsErrMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warnsmserr.FieldTenantID) {
		fields = append(fields, warnsmserr.FieldTenantID)
	}
	if m.FieldCleared(warnsmserr.FieldAccessOrgList) {
		fields = append(fields, warnsmserr.FieldAccessOrgList)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarnSmsErrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarnSmsErrMutation) ClearField(name string) error {
	switch name {
	case warnsmserr.FieldTenantID:
		m.ClearTenantID()
		return nil
	case warnsmserr.FieldAccessOrgList:
		m.ClearAccessOrgList()
		return nil
	}
	return fmt.Errorf("unknown WarnSmsErr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarnSmsErrMutation) ResetField(name string) error {
	switch name {
	case warnsmserr.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warnsmserr.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warnsmserr.FieldTenantID:
		m.ResetTenantID()
		return nil
	case warnsmserr.FieldAccessOrgList:
		m.ResetAccessOrgList()
		return nil
	case warnsmserr.FieldAppName:
		m.ResetAppName()
		return nil
	case warnsmserr.FieldRecordID:
		m.ResetRecordID()
		return nil
	case warnsmserr.FieldErrorMsg:
		m.ResetErrorMsg()
		return nil
	}
	return fmt.Errorf("unknown WarnSmsErr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarnSmsErrMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarnSmsErrMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarnSmsErrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarnSmsErrMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarnSmsErrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarnSmsErrMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarnSmsErrMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WarnSmsErr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarnSmsErrMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WarnSmsErr edge %s", name)
}

// WarningTypeMutation represents an operation that mutates the WarningType nodes in the graph.
type WarningTypeMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	alarm_type    *string
	alarm_name    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WarningType, error)
	predicates    []predicate.WarningType
}

var _ ent.Mutation = (*WarningTypeMutation)(nil)

// warningtypeOption allows management of the mutation configuration using functional options.
type warningtypeOption func(*WarningTypeMutation)

// newWarningTypeMutation creates new mutation for the WarningType entity.
func newWarningTypeMutation(c config, op Op, opts ...warningtypeOption) *WarningTypeMutation {
	m := &WarningTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeWarningType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarningTypeID sets the ID field of the mutation.
func withWarningTypeID(id uint64) warningtypeOption {
	return func(m *WarningTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *WarningType
		)
		m.oldValue = func(ctx context.Context) (*WarningType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WarningType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarningType sets the old WarningType of the mutation.
func withWarningType(node *WarningType) warningtypeOption {
	return func(m *WarningTypeMutation) {
		m.oldValue = func(context.Context) (*WarningType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarningTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarningTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WarningType entities.
func (m *WarningTypeMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarningTypeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarningTypeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WarningType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WarningTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WarningTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WarningType entity.
// If the WarningType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarningTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WarningTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WarningTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WarningTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WarningType entity.
// If the WarningType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarningTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WarningTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WarningTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WarningTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WarningType entity.
// If the WarningType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarningTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WarningTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[warningtype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WarningTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[warningtype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WarningTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, warningtype.FieldDeletedAt)
}

// SetAlarmType sets the "alarm_type" field.
func (m *WarningTypeMutation) SetAlarmType(s string) {
	m.alarm_type = &s
}

// AlarmType returns the value of the "alarm_type" field in the mutation.
func (m *WarningTypeMutation) AlarmType() (r string, exists bool) {
	v := m.alarm_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmType returns the old "alarm_type" field's value of the WarningType entity.
// If the WarningType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarningTypeMutation) OldAlarmType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmType: %w", err)
	}
	return oldValue.AlarmType, nil
}

// ResetAlarmType resets all changes to the "alarm_type" field.
func (m *WarningTypeMutation) ResetAlarmType() {
	m.alarm_type = nil
}

// SetAlarmName sets the "alarm_name" field.
func (m *WarningTypeMutation) SetAlarmName(s string) {
	m.alarm_name = &s
}

// AlarmName returns the value of the "alarm_name" field in the mutation.
func (m *WarningTypeMutation) AlarmName() (r string, exists bool) {
	v := m.alarm_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmName returns the old "alarm_name" field's value of the WarningType entity.
// If the WarningType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarningTypeMutation) OldAlarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmName: %w", err)
	}
	return oldValue.AlarmName, nil
}

// ResetAlarmName resets all changes to the "alarm_name" field.
func (m *WarningTypeMutation) ResetAlarmName() {
	m.alarm_name = nil
}

// Where appends a list predicates to the WarningTypeMutation builder.
func (m *WarningTypeMutation) Where(ps ...predicate.WarningType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarningTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarningTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WarningType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarningTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarningTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WarningType).
func (m *WarningTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarningTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, warningtype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, warningtype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, warningtype.FieldDeletedAt)
	}
	if m.alarm_type != nil {
		fields = append(fields, warningtype.FieldAlarmType)
	}
	if m.alarm_name != nil {
		fields = append(fields, warningtype.FieldAlarmName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarningTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warningtype.FieldCreatedAt:
		return m.CreatedAt()
	case warningtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case warningtype.FieldDeletedAt:
		return m.DeletedAt()
	case warningtype.FieldAlarmType:
		return m.AlarmType()
	case warningtype.FieldAlarmName:
		return m.AlarmName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarningTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warningtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warningtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warningtype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case warningtype.FieldAlarmType:
		return m.OldAlarmType(ctx)
	case warningtype.FieldAlarmName:
		return m.OldAlarmName(ctx)
	}
	return nil, fmt.Errorf("unknown WarningType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarningTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warningtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warningtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warningtype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case warningtype.FieldAlarmType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmType(v)
		return nil
	case warningtype.FieldAlarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmName(v)
		return nil
	}
	return fmt.Errorf("unknown WarningType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarningTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarningTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarningTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WarningType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarningTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warningtype.FieldDeletedAt) {
		fields = append(fields, warningtype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarningTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarningTypeMutation) ClearField(name string) error {
	switch name {
	case warningtype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown WarningType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarningTypeMutation) ResetField(name string) error {
	switch name {
	case warningtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warningtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warningtype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case warningtype.FieldAlarmType:
		m.ResetAlarmType()
		return nil
	case warningtype.FieldAlarmName:
		m.ResetAlarmName()
		return nil
	}
	return fmt.Errorf("unknown WarningType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarningTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarningTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarningTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarningTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarningTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarningTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarningTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WarningType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarningTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WarningType edge %s", name)
}
